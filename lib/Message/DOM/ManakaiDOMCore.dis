Namespace:
  @DOMXML:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @MDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @MDOM_EXCEPTION:
     http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @TreeCore: \
  @xhtml1:
    http://www.w3.org/1999/xhtml
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/
Module:
  @Name: ManakaiDOMCore
  @FullName:
    @@lang:en
    @@@: Manakai DOM Core Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  
  @Description:
    @@lang:en
    @@@:
      The Manakai DOM Core Module provides supplemental interfaces 
      that should be used with the DOM Core Module.
  
  @License:
     license:Perl
  @Date.RCS:
     $Date: 2004/09/26 11:43:06 $

  @ConditionDef:
    @@Name: DOM1
  @ConditionDef:
    @@Name: DOM2
  @ConditionDef:
    @@Name: DOM3
  
  @Require:
    @@Module:
      @@@Name: DOMCore
      @@@Namespace:
        http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#

  @Feature:
    @@QName: 
      ManakaiDOM:ManakaiDOMCore
    @@Version: 1.0
    @@Condition[list]:
      DOM1
      DOM2
      DOM3
    @@Description:
      @@@lang:en
      @@@@: The Manakai DOM Core Module, Level 1.
  @Feature:
    @@QName:
      ManakaiDOM:ManakaiDOMCore
    @@Version: 2.0
    @@Condition[list]:
      DOM2
      DOM3
    @@Description:
      @@@lang:en
      @@@@: The Manakai DOM Core Module, Level 2.
  @Feature:
    @@QName:
      ManakaiDOM:ManakaiDOMCore
    @@Version: 3.0
    @@Condition[list]:
      DOM3
    @@Description:
      @@@lang:en
      @@@@: The Manakai DOM Core Module, Level 3.

IF:
  @Name: ManakaiDOMNodeObjectNode
  @Description:
    @@lang:en
    @@@:
      The extended internal interface for the "ManakaiDOMNodeObject" 
      object used as a "Node".
  @ISA:
    ManakaiDOM:ManakaiDOMNodeObject
  @IntAttr:
    @@Name: textContent
    @@Description:
      @@@lang:en
      @@@@:
        Get text content of this node.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This attribute is parallel to the attribute "textContent" of 
        the "Node" interface.
    @@Get:
      @@@Type:
        DOMMain:DOMString
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ({
                <Q:infoset:Element> => 1,
                <Q:infoset:Attribute> => 1,
                <Q:DOMXML:Entity> => 1,
                <Q:DOMXML:EntityReference> => 1,
                <Q:DOMCore:DocumentFragment> => 1,
              }->{$self->{<Q:DOMCore:nodeType>}}) {
            __DEEP{
              for (@{$self->{<Q:infoset:children>}}) {
                if ($_->{<Q:DOMCore:nodeType>} eq <Q:DOMCore:Text>) {
                  unless ($_->{<Q:infoset:elementContentWhitespace>}) {
                    $r .= $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
                  }
                } elsif ($_->{<Q:DOMCore:nodeType>} ne <Q:infoset:Comment> and
                   $_->{<Q:DOMCore:nodeType>} ne
                                       <Q:infoset:ProcessingInstruction>) {
                  $r .= $_->__SUPER{ManakaiDOMNodeObjectNode}__::__INT{textContent}__;
                }
              }
            }__;
          } elsif ({
                     <Q:DOMCore:Text> => 1,
                     <Q:DOMXML:CDATASection> => 1,
                     <Q:infoset:Comment> => 1,
                     <Q:infoset:ProcessingInstruction> => 1,
                   }->{$self->{<Q:DOMCore:nodeType>}}) {
            $r = $self->{<Q:infoset:content>};
          } else {
            $r = null;
          }
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            ISSUE: Element content does not allow non-whitespace 
            character data or CDATA section.  In invalid document, 
            how this is?
      @@ImplNote:
        @@@lang:en
        @@@@:
          Setting is not defined - use the attribute "textContent" of 
          the  "Node" interface.
      @@Level: 1
      @@SpecLevel:1
  @IntMethod:
    @@Name: contentBaseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI by which URI references in the content of 
        this node should be resolved, as per the XML Base Specification.
    @@Param:
      @@@Name:useInfosetProperty
      @@@Type:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether the <InfosetP:base URI> property of the XML Infoset, 
          if any, should be used to compute the base URI.
    @@Return:
      @@@Type:
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
          if ($useInfosetProperty and defined $self->{<Q:infoset:baseURI>}) {
            ## Note: In XML Infoset, <Q:infoset:Document>, 
            ##       <Q:infoset:Element> and <Q:infoset:ProcessingInstruction>
            ##       allow <Q:infoset:baseURI>.  In addition, 
            ##       <Q:DOMCore:Entity> and <Q:DOMCore:EntityReference>
            ##       may have it, if it is <Q:ManakaiDOM:isExternalEntity>,
            ##       in this implementation.
            $r = $self->{<Q:infoset:baseURI>};
          } else {
            if ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
              if ($self->{<Q:infoset:attributes>}
                       ->{<Q:xml:>}->{'base'}) {
                $r = $self->{<Q:infoset:attributes>}
                          ->{<Q:xml:>}->{'base'}
                              ## Condition insensitive
                          ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                     ($useInfosetProperty);
              } elsif ($self->{<Q:infoset:attributes>}
                            ->{<Q:ManakaiDOM:noNS>}->{'xml:base'}) {
                $r = $self->{<Q:infoset:attributes>}
                          ->{<Q:ManakaiDOM:noNS>}->{'xml:base'}
                              ## Condition insensitive
                          ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                     ($useInfosetProperty);
              }
              if (not defined $r and $self->{<Q:infoset:parent>}) {
                $r = $self->{<Q:infoset:parent>}
                          ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                     ($useInfosetProperty);  
              }
            } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Attribute>) {
              if ((defined $self->{<Q:infoset:localName>} and
                   $self->{<Q:infoset:localName>} eq 'base' and
                   defined $self->{<Q:infoset:namespaceName>} and
                   $self->{<Q:infoset:namespaceName>} eq <Q:xml:>) or
                  (not defined $self->{<Q:infoset:localName>} and
                   $self->{<Q:DOMCore:name>} eq 'xml:base')) {
                $r = $self->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
                if (defined $r and __CODE{isRelativeDOMURI: in => r}__) {
                  if ($self->{<Q:infoset:ownerElement>} and
                      $self->{<Q:infoset:ownerElement>}->{<Q:infoset:parent>}) {
                    my $base = $self->{<Q:infoset:ownerElement>}
                                    ->{<Q:infoset:parent>}
                                    ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                     ($useInfosetProperty);
                    if (defined $base) {
                      require URI;
                      $r = URI->new_abs ($r, $base)->as_string;
                    } else {
                      $r = null;
                    }
                  } else {
                    $r = null;
                  }
                }
              } else { # not xml:base
                if ($self->{<Q:infoset:ownerElement>}) {
                  $r = $self->{<Q:infoset:ownerElement>}
                            ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                      ($useInfosetProperty);
                }
              }
            } elsif ({
                       <Q:DOMCore:Text> => 1,
                       <Q:DOMXML:CDATASection> => 1,
                       <Q:infoset:DocumentTypeDeclaration> => 1,
                       <Q:infoset:Comment> => 1,
                       <Q:infoset:ProcessingInstruction> => 1,
                       <Q:DOMXML:Notation> => 1, ## but does not have content
                     }->{$self->{<Q:DOMCore:nodeType>}}) {
              if ($self->{<Q:infoset:parent>}) {
                $r = $self->{<Q:infoset:parent>}
                          ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                      ($useInfosetProperty);
              }
            } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
              ## 2. The base URI of the protocol entity
                # <Q:infoset:baseURI>
              ## 3. The URI to retrieve the protocol entity
              ## 4. The application defined base URI
              if (defined $self->{<Q:DOMCore:documentURI>} and
                  not __CODE{isRelativeDOMURI: in => r}__) {
                $r = $self->{<Q:DOMCore:documentURI>};
              }
            } elsif ({
                       <Q:DOMXML:Entity> => 1,
                       <Q:DOMXML:EntityReference> => 1,
                     }->{$self->{<Q:DOMCore:nodeType>}}) {
              if ($self->{<Q:ManakaiDOM:isExpanded>}) {
                if ($self->{<Q:ManakaiDOM:isExternalEntity>}) {
                  ## 2. Tge base URI of the protocol entity
                    # <Q:infoset:baseURI>
                  ## 3. The URI to retrieve the protocol entity
                  ## 4. The application defined base URI
                  if (defined $self->{<Q:DOMCore:documentURI>} and
                    not __CODE{isRelativeDOMURI: in => r}__) {
                    $r = $self->{<Q:DOMCore:documentURI>};
                  }
                  ## Should <Q:infoset:systemIdentifier> +
                  ## <Q:infoset:declarationBaseURI> also be used?
                }
              } else {
                if ($self->{<Q:infoset:parent>}) {
                  $r = $self->{<Q:infoset:parent>}
                            ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                      ($useInfosetProperty);
                }
              }
            } else {
              # <Q:DOMCore:DocumentFragment> or 
              # unknown node types
            }
          }
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method assumes that the document is an XML 
        document and the base URI is computed by the XML Base 
        Specification.
    @@ImplNote:
      @@@lang:en
      @@@@:
        ISSUE: More study required for the base URI of document type- 
        or entity-related node types.
  @IntMethod:
    @@Name:htmlBaseURI
    @@Description:
      @@@lang:en
      @@@@:
        Return the base URI, as the document is an HTML document.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          An absolute URI.  Although the HTML 4 Specification 
          refers the RFC 2396, the return value is a DOM URI 
          (URI reference, IRI reference or some other identifier), 
          if the source document is broken (see HTML 4 Appendix) or 
          the base URI is provided from the source other than 
          the content of the HTML document (ex. the DOM URI 
          used to retrieve the document or the value of 
          the <A:Document.documentURI>).
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation was not able to obtain an 
            absolute URI.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
          my $doc = $self->{<Q:TreeCore:node>}->{<Q:DOMCore:ownerDocument>};
          if ($doc and $doc->{<Q:DOMCore:hasFeature>}->{HTML}) {
            HTML: {
              DOC: for (@{$doc->{<Q:infoset:children>}}) {
                if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element> and
                    (defined $_->{<Q:infoset:localName>} and
                     $_->{<Q:infoset:localName>} eq 'html' and
                     ((defined $_->{<Q:infoset:namespaceName>} and
                       $_->{<Q:infoset:namespaceName>} eq <Q:xhtml1:>) or
                      not defined $_->{<Q:infoset:namespaceName>})) or
                    (not defined $_->{<Q:infoset:localName>} and
                     $_->{<Q:DOMCore:name>} eq 'html')) {
                  for (@{$_->{<Q:infoset:children>}}) {
                    if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element> and
                        (defined $_->{<Q:infoset:localName>} and
                         $_->{<Q:infoset:localName>} eq 'head' and
                         ((defined $_->{<Q:infoset:namespaceName>} and
                           $_->{<Q:infoset:namespaceName>} eq <Q:xhtml1:>) or
                          not defined $_->{<Q:infoset:namespaceName>})) or
                        (not defined $_->{<Q:infoset:localName>} and
                         $_->{<Q:DOMCore:name>} eq 'head')) {
                      for (@{$_->{<Q:infoset:children>}}) {
                        if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element> and
                            (defined $_->{<Q:infoset:localName>} and
                             $_->{<Q:infoset:localName>} eq 'base' and
                             ((defined $_->{<Q:infoset:namespaceName>} and
                               $_->{<Q:infoset:namespaceName>} eq <Q:xhtml1:>) or
                              not defined $_->{<Q:infoset:namespaceName>})) or
                            (not defined $_->{<Q:infoset:localName>} and
                             $_->{<Q:DOMCore:name>} eq 'base')) {
                          my $a = $_->{<Q:infoset:attributes>}
                                    ->{<Q:null:>}->{href} ||
                                  $_->{<Q:infoset:attributes>}
                                    ->{<Q:ManakaiDOM:noNS>}->{href};
                          if ($a) {
                            $r = $a->__SUPER{ManakaiDOMNodeObjectNode}__::__INT{textContent}__;
                            unless (__CODE{isRelativeDOMURI: in => r}__) {
                              $r = null;
                            } else {
                              last HTML;
                            }
                          }
                          last DOC;
                        }
                      }
                      last DOC;
                    }
                  }
                  last DOC;
                }
              } # DOC
              if (defined $doc->{<Q:infoset:baseURI>}) {
                $r = $doc->{<Q:infoset:baseURI>};
                $r = null if __CODE{isRelativeDOMURI: in => r}__;
              } elsif (defined $doc->{<Q:DOMCore:documentURI>}) {
                $r = $doc->{<Q:DOMCore:documentURI>};
                $r = null if __CODE{isRelativeDOMURI: in => r}__;
              }
            } # HTML
          }
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           TODO: <HTML:codebase> attribute should be considered by option.
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           ISSUE: How treat base URI of <IF:DocumentType>, ...
  @IntMethod:
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Lookup the namespace prefix associated to the given namespace URI. 
        This node must be of type <IF:Element>. 
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM:lookupNamespacePrefix> 
        <SRC:<CITE:DOM Level 3 Core Specification> B.2 Namespace Prefix Lookup>.
    @@SpecLevel:3
    @@Param:
      @@@Name:namespaceURI
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI.  <DOM:null> is not allowed; it must be 
          checked before the call of this internal method.
    @@Param:
      @@@Name:originalElement
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The element node object to which the original request to lookup the 
          <P:namespaceURI> is issued.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The original node the request is issued is not an <IF:Element> node.
    @@Return:
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace prefix.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The associated namespace prefix does not found.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
          FIND: {
          if ($originalElement) {
            if (defined $self->{<Q:infoset:namespaceName>} and
                $self->{<Q:infoset:namespaceName>} eq $namespaceURI and
                defined $self->{<Q:infoset:prefix>} and
                $originalElement->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                      ($self->{<Q:infoset:prefix>}) eq $namespaceURI) {
              $r = $self->{<Q:infoset:prefix>};
              last FIND;
            }
            for (values %{$self->{<Q:infoset:attributes>}->{<Q:xmlns:>}||{}}) {
              if (defined $_->{<Q:infoset:prefix>} and
                  $_->{<Q:infoset:prefix>} eq 'xmlns' and
                  $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__
                    eq $namespaceURI and
                  $originalElement->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                            ($_->{<Q:infoset:localName>}) eq $namespaceURI) {
                $r = $_->{<Q:infoset:localName>};
                last FIND;
              }
            }
          }
            ## If element has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q:infoset:parent>}) {
                $n = $n->{<Q:infoset:parent>};
                if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                  $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespacePrefix}__
                                               ($namespaceURI, $originalElement);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } # FIND
     @@ImplNote:
       @@@lang:en
       @@@@:
         Before returning found prefix, the algorithm needs to make 
         sure that the prefix is not redefined.  This is why 
         <P:originalElement> is required.
  @IntMethod:
    @@Name:isDefaultNamespace
    @@Description:
      @@@lang:en
      @@@@:
        Return whether the given namespace URI is the 
        default namespace.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM:isDefaultNamespace> 
        <SRC:<CITE:DOM Level 3 Core Specification> B.3 Default Namespace Lookup>.
    @@SpecLevel:3
    @@Param:
      @@@Name:namespaceURI
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace URI to look for.
    @@Return:
      @@@Type:boolean
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
            if (not defined $self->{<Q:infoset:prefix>}) {
              if (defined $namespaceURI and
                  defined $self->{<Q:infoset:namespaceName>} and
                  $namespaceURI eq $self->{<Q:infoset:namespaceName>}) {
                $r = true;
              } elsif (not defined $namespaceURI and
                       not defined $self->{<Q:infoset:namespaceName>}) {
                $r = true;
              }
              # else false
            } elsif ($self->{<Q:infoset:attributes>}
                          ->{<Q:infoset:xmlns:>}->{xmlns}) {
              my $v = $self->{<Q:infoset:attributes>}
                           ->{<Q:infoset:xmlns:>}->{xmlns}
                           ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
              if (defined $namespaceURI and $namespaceURI eq $v) {
                $r = true;
              } elsif (not defined $namespaceURI and not length $v) {
                $r = true;
              }
              # else false
            } else {
              ## If element has ancestor element
              my $n = $self;
              ANCESTOR: {
                if ($n->{<Q:infoset:parent>}) {
                  $n = $n->{<Q:infoset:parent>};
                  if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                    $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{isDefaultNamespace}__
                                               ($namespaceURI);
                    last ANCESTOR;
                  } else {
                    redo ANCESTOR;
                  }
                }
                # false
              }
            }
          } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
            for (@{$self->{<Q:infoset:children>}}) {
              if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{isDefaultNamespace}__
                                               ($namespaceURI);
                last;
              }
            }
          } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Attribute>) {
            if ($self->{<Q:infoset:ownerElement>}) {
              $r = $self->{<Q:infoset:ownerElement>}
                        ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{isDefaultNamespace}__
                                               ($namespaceURI);
              last FIND;
            }
          } elsif ({
                     <Q:DOMXML:Entity> => 1,
                     <Q:DOMXML:Notation> => 1,
                     <Q:DOMXML:DocumentType> => 1,
                     <Q:DOMCore:DocumentFragment> => 1,
                   }->{$self->{<Q:DOMCore:nodeType>}}) {
            #
          } else {
          #} elsif ({
          #           <Q:DOMCore:Text> => 1,
          #           <Q:DOMCore:Comment> => 1,
          #           <Q:DOMXML:EntityReference> => 1,
          #           <Q:DOMXML:CDATASection> => 1,
          #           <Q:infoset:ProcessingInstruction> => 1,
          #         }->{$self->{<Q:DOMCore:nodeType>}}) {
            ## If node has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q:infoset:parent>}) {
                $n = $n->{<Q:infoset:parent>};
                if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                  $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{isDefaultNamespace}__
                                               ($namespaceURI);
                  last ANCESTOR;
                } else {
                  redo ANCESTOR;
                }
              }
              # false
            }
          } # nodeType
  @IntMethod:
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Lookup the namespace URI associated to the given prefix.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM:lookupNamespaceURI> 
        <SRC:<CITE:DOM Level 3 Core Specification> B.4 Namespace URI Lookup>.
    @@SpecLevel:3
    @@Param:
      @@@Name:prefix
      @@@Type:
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace prefix.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Look for the default namespace URI.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: No namespace URI associated.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
          FIND: {
          if ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
            if (defined $self->{<Q:infoset:localName>} and
                defined $self->{<Q:infoset:namespaceName>} and
                ((defined $self->{<Q:infoset:prefix>} and defined $prefix and
                  $self->{<Q:infoset:prefix>} eq $prefix) or
                 (not defined $self->{<Q:infoset:prefix>} and
                  not defined $prefix))) {
              $r = $self->{<Q:infoset:namespaceName>};
              last FIND;
            }
            for (values %{$self->{<Q:infoset:attributes>}->{<Q:xmlns:>}||{}}) {
              if (defined $_->{<Q:infoset:prefix>} and defined $prefix and
                  $_->{<Q:infoset:prefix>} eq 'xmlns' and
                  $_->{<Q:infoset:localName>} eq $prefix) {
                ## Non default namespace
                $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
                $r = null unless length $r;
                last FIND;
              } elsif (not defined $prefix and
                       $_->{<Q:infoset:localName>} eq 'xmlns') {
                ## Default namespace
                $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
                $r = null unless length $r;
                last FIND;
              }
            }
            ## If element has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q:infoset:parent>}) {
                $n = $n->{<Q:infoset:parent>};
                if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                  $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                                               ($prefix);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
            for (@{$self->{<Q:infoset:children>}}) {
              if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                                               ($prefix);
                last FIND;
              }
            }
          } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Attribute>) {
            if ($self->{<Q:infoset:ownerElement>}) {
              $r = $self->{<Q:infoset:ownerElement>}
                        ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                                               ($prefix);
              last FIND;
            }
          } elsif ({
                     <Q:DOMXML:Entity> => 1,
                     <Q:DOMXML:Notation> => 1,
                     <Q:DOMXML:DocumentType> => 1,
                     <Q:DOMCore:DocumentFragment> => 1,
                   }->{$self->{<Q:DOMCore:nodeType>}}) {
            #
          } else {
          #} elsif ({
          #           <Q:DOMCore:Text> => 1,
          #           <Q:DOMCore:Comment> => 1,
          #           <Q:DOMXML:EntityReference> => 1,
          #           <Q:DOMXML:CDATASection> => 1,
          #           <Q:infoset:ProcessingInstruction> => 1,
          #         }->{$self->{<Q:DOMCore:nodeType>}}) {
            ## If node has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q:infoset:parent>}) {
                $n = $n->{<Q:infoset:parent>};
                if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                  $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                                               ($prefix);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } # nodeType
          } # FIND
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          No-namespace nodes are ignored <SRC:DOM 3>.

  @IntMethod:
    @@Name:isEqualNode
    @@Operator:
      @@@Type:
        lang:Perl
      @@@@:==
    @@Description:
      @@@lang:en
      @@@@:
        Check whether two nodes are equal.
    @@Param:
      @@@Name:arg
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node object to compare equality with.
    @@Return:
      @@@Type:boolean
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          __CLASS{Node::DOM3}__->__INT{getNodeReference}__ ($self, true) ==
          __CLASS{Node::DOM3}__->__INT{getNodeReference}__ ($arg, true)
            ? true : false;
    @@ImplNote:
      @@@lang:en
      @@@@:
        See <M:Node.isEqualNode>.  This internal method might need to 
        be modified if future version of DOM modify the specification.
    @@SpecLevel:3
    
## IF:ManakaiDOMNodeObjectNode

IF:
  @Name:  ManakaiDOMChildNodeList
  @ISA:
    ManakaiDOM:ManakaiDOMNodeReference
  @ISA: 
    DOMCore:NodeList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of child nodes.
  @ReMethod:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@:
         Return a child node.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the node into the child node list.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The child node at the "index"th position.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in the list.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:children>}->[$index];
            if (defined $r) {
                   ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r);
            }
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
    @@Redefine:
      DOMCore:NodeList
  @ReAttr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@:
         The number of nodes in the list.
     @@Get:
        @@@Type:  unsigned-long
        @@@Def:
          @@@@Type:
             lang:dis
          @@@@@:
            $r = @{$self->{<Q:TreeCore:node>}->{<Q:infoset:children>}};
    @@Redefine:
       DOMCore:NodeList

  @IntMethod:
    @@Name: isEqualNodeList
    @@Operator:
      @@@Type:
        lang:Perl
      @@@@:==
    @@Description:
      @@@lang:en
      @@@@:
        Return whether two <IF:NodeList>s are equal.
    @@Param:
      @@@Name:arg
      @@@Type:ManakaiDOMChildNodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to compare equality with.
    @@Return:
      @@@Type:boolean
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
   \      EQ: {
   \        last EQ unless @{$self->{<Q:TreeCore:node>}
   \                              ->{<Q:infoset:children>}} ==
   \                       @{$arg->{<Q:TreeCore:node>}
                                 ->{<Q:infoset:children>}};
            for my $i (0..$#{$self->{<Q:TreeCore:node>}
                                  ->{<Q:infoset:children>}}) {
              unless ($self->{<Q:TreeCore:node>}
                                  ->{<Q:infoset:children>}->[$i] ==
                      $arg->{<Q:TreeCore:node>}
                                  ->{<Q:infoset:children>}->[$i]) {
                last EQ;
              }
            }
            $r = true;
          }
    @@ImplNote:
      @@@lang:en
      @@@@:
        See: <M:Node.isEqualNode>.
    @@SpecLevel:3
## IF:ManakaiDOMChildNodeList

IF:
  @Name: ManakaiDOMGetElementsNodeList
  @ISA:
    DOMCore:NodeList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of nodes, returned by "getElementsBy"-methods.
  @ReMethod:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@:
         Return an item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into the collection.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node at the "index"th position in the collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in the list.

    @@Redefine:
      DOMCore:NodeList
  @ReAttr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@:
         The number of nodes in the list.
     @@Get:
        @@@Type:  unsigned-long
    @@Redefine:
      DOMCore:NodeList
## IF:ManakaiDOMGetElementsNodeList

IF:
  @Name: ManakaiDOMAttributes
  @ISA:
    ManakaiDOM:ManakaiDOMNodeReference
  @ISA:
    DOMCore:NamedNodeMap
  @Description:
    @@lang:en
    @@@:
      A list of attributes attached to an <IF:Element> node.

  @ImplNote:
    @@lang:en
    @@@:
      An element may have two (or more) attributes that have the same 
      <A:Node.nodeName>, but different <A:Node.namespaceURI>s. 
      Which of them is returned by DOM Level 1 methods is 
      implementation dependent.  The only guarantee is 
      that all methods that access a named item by its <A:Node.nodeName> 
      will access the same item, and all methods by its namespace URI
      and local name will access the same item. 
      <SRC:<CITE:DOM Level 2 Core> 1.4.8 XML Namespaces,
      <CITE:DOM Level 3 Core> 1.3.3 XML Namespaces>

  @IntMethod:
    @@Name:selectAttrNodeObject
    @@Description:
      @@@lang:en
      @@@@:
        Select an <IF:ManakaiDOMNodeObject> object that represents an 
        <IF:Attr> node.
    @@NSVersion:selectAttrNodeObjectNS
    @@Param:
      @@@Name:name
      @@@Type:
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of the attribute to select.
    @@Return:
      @@@Type: 
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF:ManakaiDOMNodeObject> object.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: There is no such attribute.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
            my $attr = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>};
            if ($attr->{<Q:ManakaiDOM:noNS>}->{$name}) {
              $r = $attr->{<Q:ManakaiDOM:noNS>}->{$name};
              __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                delete $attr->{<Q:ManakaiDOM:noNS>};
              }__;
            } elsif ($name eq 'xmlns') {
              for my $a (keys %{$attr->{<Q:xmlns:>}||{}}) {
                if ($attr->{<Q:xmlns:>}->{$a}->{<Q:infoset:localName>}) {
                  $r = $attr->{<Q:xmlns:>}->{$a};
                  __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                    delete $attr->{<Q:xmlns:>}->{$a};
                  }__;
                  last;
                }
              }
            } elsif ($name eq 'xmlns:xmlns') {
              # 
            } else {
              for my $ns (keys %$attr) {
                if ($ns eq <Q:ManakaiDOM:noNS>) {
                  # 
                } else {
                  for my $a (keys %{$attr->{$ns}||{}}) {
                    if (defined $attr->{$ns}->{$a}->{<Q:infoset:prefix>} and
                        $attr->{$ns}->{$a}->{<Q:infoset:prefix>}.':'.
                        $attr->{$ns}->{$a}->{<Q:infoset:localName>} eq $name) {
                      $r = $attr->{$ns}->{$a};
                      __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                        delete $attr->{$ns}->{$a};
                      }__;
                      last;
                    } elsif (not defined $attr->{$ns}->{$a}->{<Q:infoset:prefix>}
                         and
                         $attr->{$ns}->{$a}->{<Q:infoset:localName>} eq $name) {
                      $r = $attr->{$ns}->{$a};
                      __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                        delete $attr->{$ns}->{$a};
                      }__;
                      last;
                    }
                  }
                }
              }
            }
    @@ImplNote:
      @@@lang:en
      @@@@:
        The same internal method is defined in <IF:Element>.

  @ReMethod:
     @@Name:  getNamedItem
     @@Description:
       @@@lang:en
       @@@@: Retrieve an attribute node specified by name.
     @@NSVersion:getNamedItemNS
     @@Param:
        @@@Name:  name
        @@@Type:  
           DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <A:nodeName> of a node to retrieve, i.e. 
            the qualified name of the attribute.
     @@Return:
        @@@Type:  
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P:name> does not identify any node in this map.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObject}}__;
            if ($r) {
                         ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self);
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This code is same as <M:Element.getAttributeNode>.
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
    @@Redefine:
      DOMCore:NamedNodeMap
  @ReMethod:
     @@Name:  setNamedItem
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its <A:nodeName> attribute.  If a node with 
         that name is already present in this map, it is replaced 
         by the new one.
         \
         Replacing a node by itself has no effect.
     @@ImplNote:
       @@@lang:en
       @@@@: 
         <QUOTE:Replacing ... no effect> is clarified by the DOM Level 2 Errata. 
     @@NSVersion:setNamedItemNS
     @@Param:
        @@@Name:  arg
        @@@Type:  
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: A node to store in this map.
     @@Return:
        @@@Type:  
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node does not replace any node in the map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has added by the DOM Level 2 Errata.
         @@@Def:
           @@@@Type:
             lang:Perl
           @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $attrNode = $arg->{<Q:TreeCore:node>};
            if ($attrNode->{<Q:infoset:ownerElement>}) {
              __EXCEPTION{
                DOMException.INUSE_ATTRIBUTE_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
              }__;
            } elsif ($attrNode->{<Q:DOMCore:ownerDocument>}
                              ->{<Q:TreeCore:nodeID>} ne
                     $self->{<Q:TreeCore:node>}->{<Q:DOMCore:ownerDocument>}
                          ->{<Q:TreeCore:nodeID>}) {
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
              }__;
            } elsif ($attrNode->{<Q:DOMCore:nodeType>} ne
                     <Q:infoset:Attribute>) {
              __EXCEPTION{
                DOMException.HIERARCHY_REQUEST_ERR.
                MDOM_EXCEPTION:HIERARCHY_BAD_TYPE::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
                  <Q:DOMCore:nodeType> => $attrNode->{<Q:DOMCore:nodeType>},
              }__;
            }

            if (defined $attrNode->{<Q:infoset:localName>}) {
              $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}};
            } else {
              $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{<Q:ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q:DOMCore:name>}};
            }

            if ($r->{<Q:TreeCore:nodeID>} eq $attrNode->{<Q:TreeCore:nodeID>}) {
              __WARNING{
                ManakaiDOMImplementationException.
                MDOM_REPLACE_BY_ITSELF_NO_EFFECT::
              }__;
              $r = $arg;
            } else {
              $attrNode->{<Q:infoset:ownerElement>} = $self->{<Q:TreeCore:node>};
              if (defined $attrNode->{<Q:infoset:localName>}) {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}} = $attrNode;
              } else {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{<Q:ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q:DOMCore:name>}} = $attrNode;
              }
              if ($r) {
                delete $r->{<Q:infoset:parent>};
                $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
              }
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether the node should be returned if 
              the node is <QUOTE:replaced> by itself.
            \
              This code is almost same as <M:Element.setAttributeNode>.
              The parameter <P:newAttr> in that method is named as 
              <P:arg> in this method.
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
    @@Redefine:
      DOMCore:NamedNodeMap
  @ReMethod:
     @@Name:  removeNamedItem
     @@Description:
        @@@lang:en
        @@@@:
          Remove an attribute node specified by name.
     @@ImplNote:
       @@@lang:en
       @@@@:
         New non-<A:specified> attribute will be generated if the schema 
         defines some default value for the attribute removed.
     @@NSVersion:removeNamedItemNS
     @@Param:
        @@@Name:  name
        @@@Type:  
           DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The "nodeName" of the node to remove.
     @@Return:
        @@@Type:  
            DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: The attribute node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no node named "name" in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
          @@@@SpecLevel:1
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This exception is added by the DOM Level 1 First Edition Errata.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            __INT{{selectAttrNodeObject: <Q:DOMCore:removeAttribute>}}__;
            if ($r) {
              delete $r->{<Q:infoset:ownerElement>};
              $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                  ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
            } else {
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR::
              }__;
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Default attribute
            \
              This code is almost same as <M:Element.removeAttribute>. 
              This method returns an <IF:Attr> removed but that method 
              does not (<M:Element.removeAttributeNode> does).
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
    @@Redefine:
      DOMCore:NamedNodeMap
  @ReMethod:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@:
         Return an attribute attached to the element.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into this map.
     @@Return:
        @@@Type: 
           DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node at the <P:index>th position in the map.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in this map.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $i = 0;
            FIND: for my $ns (sort keys %{$self->{<Q:TreeCore:node>}
                                               ->{<Q:infoset:attributes>}}) {
              for my $ln (sort keys %{$self->{<Q:TreeCore:node>}
                                           ->{<Q:infoset:attributes>}->{$ns}}) {
                if ($i++ == $index) {
                  $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                            ->{$ns}->{$ln};
                  last FIND;
                }
              }
            }
    @@ImplNote:
      @@@lang:en
      @@@@:
        How ordering attributes is not specified.
    @@Redefine:
      DOMCore:NamedNodeMap
  @ReAttr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: The number of attribute nodes attached to the element.
     @@Get:
        @@@Type:  unsigned-long
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            for (values %{$self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}}) {
              $r += keys %$_;
            }
    @@Redefine:
      DOMCore:NamedNodeMap

  @IntMethod:
     @@Name: selectAttrNodeObjectNS
     @@Description:
       @@@lang:en
       @@@@:
         Select a <IF:ManakaiDOMNodeObject> object that represents 
         an <IF:Attr> node, by namespace URI and local name.
     @@NoNSVersion:selectAttrNodeObject
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to select.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to select has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to select.
     @@Return:
        @@@Type:
          ManakaiDOM:ManakaiDOMNodeObject
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF:ManakaiDOMNOdeObject> object.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $attr = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>};
            $namespaceURI = <Q:null:> unless defined $namespaceURI;
            $r = $attr->{$namespaceURI}->{$localName};
            __WHEN{IS{<Q:DOMCore:removeAttribute>}::
              delete $attr->{$namespaceURI}->{$localName} if $r;
            }__;
    @@ImplNote:
      @@@lang:en
      @@@@:
        The same internal method is defined in <IF:Element>.

  @ReMethod:
     @@Name:  getNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an attribute node specified by local name and namespace URI.
     @@NoNSVersion:getNamedItem
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the node to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to retrieve has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to retrieve.
     @@Return:
        @@@Type:
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attribute node with the specified local name and 
            namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "namespaceURI" and "localName" does not identify 
              any node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the feature "XML" and 
              the language exposed through the "Document" does not 
              support XML Namespaces.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObjectNS}}__;
            if ($r) {
                         ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self);
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Same code as <M:Element.getAttributeNodeNS>.
     @@Level[list]:
        2
        3
     @@SpecLevel:2
    @@Redefine:
      DOMCore:NamedNodeMap
  @ReMethod:
     @@Name:  setNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its "namespaceURI" and "localName". 
         If a node with that namespace URI and that local name 
         is already present in this map, it is replaced by the new one. 
         Replacing a node by itself has no effect.
     @@NoNSVersion:setNamedItem
     @@Param:
        @@@Name:  arg
        @@@Type:
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: An attribute node to set to this attribute.
     @@Return:
        @@@Type:
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node replaces no existing node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node was created from a different document.
         @@@Exception:
           @@@@Name:NO_MODIFICATION_ALLOWED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName: 
               MDOM_EXCEPTION:NOMOD_THIS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has been added by the DOM Level 2 Errata. 
         @@@Exception:
           @@@@Name:NOT_SUPPORTED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName:
               MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The DOM implementation does not support the feature 
                 <Feature:XML> and the language exposed through the 
                 <IF:Document> does not support XML Namespaces.
             @@@@@SpecLevel:2
           @@@@SubType:
             @@@@@QName:
               MDOM_EXCEPTION:MDOM_NODE_NOSUPPORT_XMLNS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The <P:arg> node does not support XML Namespace.
             @@@@@SpecLevel[list]:
         @@@Def:
           @@@@Type:
             lang:Perl
           @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $attrNode = $arg->{<Q:TreeCore:node>};
            if ($attrNode->{<Q:infoset:ownerElement>}) {
              __EXCEPTION{
                DOMException.INUSE_ATTRIBUTE_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
              }__;
            } elsif ($attrNode->{<Q:DOMCore:ownerDocument>}
                              ->{<Q:TreeCore:nodeID>} ne
                     $self->{<Q:TreeCore:node>}->{<Q:DOMCore:ownerDocument>}
                          ->{<Q:TreeCore:nodeID>}) {
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
              }__;
            } elsif ($attrNode->{<Q:DOMCore:nodeType>} ne
                     <Q:infoset:Attribute>) {
              __EXCEPTION{
                DOMException.HIERARCHY_REQUEST_ERR.
                MDOM_EXCEPTION:HIERARCHY_BAD_TYPE::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
                  <Q:DOMCore:nodeType> => $attrNode->{<Q:DOMCore:nodeType>},
              }__;
            }

            if (defined $attrNode->{<Q:infoset:localName>}) {
              $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}};
            } else {
              __EXCEPTION{
                DOMException.NOT_SUPPORTED_ERR.
                MDOM_EXCEPTION:MDOM_NODE_NOSUPPORT_XMLNS::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
              }__;
            }

            if ($r->{<Q:TreeCore:nodeID>} eq $attrNode->{<Q:TreeCore:nodeID>}) {
              __WARNING{
                ManakaiDOMImplementationException.
                MDOM_REPLACE_BY_ITSELF_NO_EFFECT::
              }__;
              $r = $arg;
            } else {
              $attrNode->{<Q:infoset:ownerElement>} = $self->{<Q:TreeCore:node>};
              if (defined $attrNode->{<Q:infoset:localName>}) {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}} = $attrNode;
              } else {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{<Q:ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q:DOMCore:name>}} = $attrNode;
              }
              if ($r) {
                delete $r->{<Q:infoset:parent>};
                $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
              }
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether the node should be returned if 
              the node is <QUOTE:replaced> by itself.
             \
              This code is almost same as <M:Element.setAttributeNodeNS>
              without some points.
     @@Level[list]:  
        2
        3
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@SpecLevel:2
    @@Redefine:
      DOMCore:NamedNodeMap
  @ReMethod:
     @@Name:  removeNamedItemNS
     @@Description:
        @@@lang:en
        @@@@:
          Remove a node specified by local name and namespace URI.
     @@ImplNote:
       @@@lang:en
       @@@@:
         New non-"specified" attribute will be generated if the schema 
         defines some default value for the attribute removed.
     @@NoNSVersion:removeNamedItem
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the node to remove.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to remove has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to remove.
     @@Return:
        @@@Type: 
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no node with the specified "namespaceURI" and 
              "localName" in the map.
        @@@Exception:
          @@@@Type: 
             DOMCore:DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
         @@@Exception:
           @@@@Type: 
             DOMCore:DOMException
           @@@@Name: NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature:XML> and the language exposed through 
                the <IF:Document> does not support XML Namespaces.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            __INT{{selectAttrNodeObjectNS: <Q:DOMCore:removeAttribute>}}__;
            if ($r) {
              delete $r->{<Q:infoset:ownerElement>};
              $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                     ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
            } else {
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR::
              }__;
            }
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             TODO: default attribute
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             Almost same as <M:Element.removeAttributeNS>.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@Level[list]:  
        2
        3
     @@SpecLevel:2
    @@Redefine:
      DOMCore:NamedNodeMap

  @IntMethod:
    @@Name: isEqualNamedNodeMap
    @@Operator:
      @@@Type:
        lang:Perl
      @@@@:==
    @@Description:
      @@@lang:en
      @@@@:
        Return whether two <IF:NamedNodeMap>s are equal.
    @@Param:
      @@@Name:arg
      @@@Type:ManakaiDOMAttributes
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to compare equality with.
    @@Return:
      @@@Type:boolean
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          EQ: {
            for my $ns (keys %{$self->{<Q:TreeCore:node>}
                                    ->{<Q:infoset:attributes>}}) {
              last EQ unless $arg->{<Q:TreeCore:node>}
                                 ->{<Q:infoset:attributes>}->{$ns};
              last EQ unless keys (%{$arg->{<Q:TreeCore:node>}
                                 ->{<Q:infoset:attributes>}->{$ns}}) ==
                             keys (%{$self->{<Q:TreeCore:node>}
                                 ->{<Q:infoset:attributes>}->{$ns}});
              for my $ln (keys %{$self->{<Q:TreeCore:node>}
                                      ->{<Q:infoset:attributes>}->{$ns}}) {
                last EQ unless $arg->{<Q:TreeCore:node>}
                                   ->{<Q:infoset:attributes>}->{$ns}->{$ln};
                last EQ unless $self->{<Q:TreeCore:node>}
                                    ->{<Q:infoset:attributes>}->{$ns}->{$ln} ==
                               $arg->{<Q:TreeCore:node>}
                                    ->{<Q:infoset:attributes>}->{$ns}->{$ln};
              }
            }
            $r = true;
          }
    @@ImplNote:
      @@@lang:en
      @@@@:
        See: <M:Node.isEqualNode>.
    @@SpecLevel:3
## IF:ManakaiDOMAttributes

ConfigParam:
  @Name: ManakaiDOMConfigurationParameter
  @ISA:
    DOMMain:DOMString
  @Description:
    @@lang:en
    @@@:
      A parameter name used with the <IF:DOMConfiguration>.
    \
      Names are case-insensitive.  To avoid possible conflicts, 
      names referring to parameters defined outside the DOM 
      specification should be made unique.  Names are 
      recommended to follow the Unicode identifier specification 
      with the addition of the character <CHAR:HYPHEN-MINUS>.
  @ImplNote:
    @@lang:en
    @@@:
      DOM implementations must recognize all parameters 
      and some parameter values defined in the DOM Level 3 Core Specification.
    \
      DOM parameters are similar to features and properties of SAX2.
  @Param:
    @@Name: canonical-form
    @@IsSupportRequired:1
    @@Type: boolean
    @@InCase:
      @@@Value: true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Canonicalize the document accoding to the rules specified in 
          the XML C14N Version 1.0 Specification.
        \
          This is limited to what can be represented in the DOM.  
          For example, there is no way to specify the order of 
          the attributes in the DOM.
      @@@SetParam:
        @@@@Name: entities
        @@@@Type: boolean
        @@@@Value: false
      @@@SetParam:
        @@@@Name: normalize-characters
        @@@@Type: boolean
        @@@@Value: false
      @@@SetParam:
        @@@@Name: cdata-sections
        @@@@Type: boolean
        @@@@Value: false
      @@@SetParam:
        @@@@Name: namespaces
        @@@@Type: boolean
        @@@@Value: true
      @@@SetParam:
        @@@@Name: namespace-declarations
        @@@@Type: boolean
        @@@@Value: true
      @@@SetParam:
        @@@@Name: well-formed
        @@@@Type: boolean
        @@@@Value: true
      @@@SetParam:
        @@@@Name: element-content-whitespace
        @@@@Type: boolean
        @@@@Value: true
    @@InCase:
      @@@Value: false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@: Do not canonicalize the document.
  @Param:
    @@Name: cdata-sections
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value: true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep <IF:CDATASection> nodes in the document.
      @@@SetParam:
        @@@@Name: canonicel-form
        @@@@Type:boolean
        @@@@Value:false
    @@InCase:
      @@@Value: false
      @@@IsSupportRequred:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Transform <IF:CDATASection> nodes in the document into 
          <IF:Text> nodes.  The new <IF:Text> node is then 
          combined with any adjacent <IF:Text> node.
  @Param:
    @@Name: check-character-normalization
    @@IsSupportRequired
    @@Type:boolean
    @@InCase:
      @@@Value: true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Check whether the characters in the document are fully normalized 
          as defined in Appendix B of the XML 1.1 Specification.  When 
          a sequence of characters is encountered that fails 
          normalization checking, an error with the 
          <A:DOMError.type> equals to 
          <DOM:check-character-normalization-failure> is issued.
    @@InCase:
      @@@Value: false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@: Do not check whether characters are normalized.
  @Param:
    @@Name: comments
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep <IF:Comment> nodes in the document.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
           Discard <IF:Comment> nodes in the document.
  @Param:
    @@Name: datatype-normalization
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Expose schema normalized values in the tree.
        \
          This parameter required to have <DOM:validate> parameter 
          equals to <DOM:true>, or this parameter has no effect.
        \
          Note that the attribute value normalization as defined 
          in the XML Specifications does not applied.  This 
          parameter is only meant for schema languages other 
          than the DTD.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:0
      @@@Description:
        @@@@lang:en
        @@@@@: Do not perform schema normalization on the tree.
  @Param:
    @@Name: element-content-whitespace
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep all whitespaces in the document.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Discard all <IF:Text> nodes that contain whitespaces 
          in element content.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          DOM implementations are expected to use the attribute 
          <A:Text.isElementContentWhitespace> to determine 
          whether a <IF:Text> node should be discarded.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
  @Param:
    @@Name: entities
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep <IF:EntityReferences> nodes in the document.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Remove all <IF:EntityReference> nodes from the document, 
          putting the entity expansions directly in their place. 
          <IF:Text> nodes are normalized as defined in 
          <M:Node.normalize>.  Only unexpanded entity references 
          are kept in the document.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          This parameter does not affect <IF:Entity> nodes.
  @Param:
    @@Name: error-handler
    @@Type: 
      DOMCore:DOMErrorHandler
    @@IsSupportRequired:1
    @@Description:
      @@@lang:en
      @@@@:
        If an error is encountered in the document, the DOM 
        implementation will callback the <IF:DOMErrorHandler>. 
      \
        When called, <A:DOMError.relatedData> will contain 
        the closest node to where the error occurred. 
        If the implementation is unable to determine the node 
        where the error occurs, <A:DOMError.relatedData> will 
        contain the <IF:Document> node. 
      \
        Mutations to the document from within an error handler 
        will result in implementation dependent behavior.
    @@ImplNote:
      @@@lang:en
      @@@@:
        DOM implementations may provide a default <IF:DOMErrorHandler> 
        object.  
  @Param:
    @@Name: infoset
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep in the document information defined in the 
          XML Infoset Specification.
      @@@SetParam:
        @@@@Name: validate-if-schema
        @@@@Type: boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name: entities
        @@@@Type:boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name:datatype-normalization
        @@@@Type:boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name:cdata-sections
        @@@@Type:boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name:namespace-declarations
        @@@@Type:boolean
        @@@@Value:true
      @@@SetParam:
        @@@@Name:well-formed
        @@@@Type:boolean
        @@@@Value:true
      @@@SetParam:
        @@@@Name:element-content-whitespace
        @@@@Type:boolean
        @@@@Value:true
      @@@SetParam:
        @@@@Name:comments
        @@@@Type:boolean
        @@@@Value:true
      @@@SetParam:
        @@@@Name:namespaces
        @@@@Type:boolean
        @@@@Value:true
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          <M:DOMConfiguration.getParameter> with this parameter 
          returns <DOM:true> iif <CODE:!<DOM:validate-if-schema> && 
          !<DOM:entities> && !<DOM:datatype-normalization> && 
          !<DOM:cdata-sections> && <DOM:namespace-declarations> && 
          <DOM:well-formed> && <DOM:element-content-whitespace> && 
          <DOM:comment> && <DOM:namespaces>>.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Setting <DOM:infoset> to <DOM:false> has no effect.
    @@Get:
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = !$cfg->{<Q:DOMCoreParam:validate-if-schema>} &&
               !$cfg->{<Q:DOMCoreParam:entities>} &&
               !$cfg->{<Q:DOMCoreParam:datatype-normalization>} &&
               !$cfg->{<Q:DOMCoreParam:cdata-sections>} && 
               $cfg->{<Q:DOMCoreParam:namespace-declarations>} &&
               $cfg->{<Q:DOMCoreParam:well-formed>} &&
               $cfg->{<Q:DOMCoreParam:element-content-whitespace>} &&
               $cfg->{<Q:DOMCoreParam:comment>} && 
               $cfg->{<Q:DOMCoreParam:namespaces>}
             ? true : false;
  @Param:
    @@Name: namespaces
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Perform the namespace normalization processing.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Do not perform the namespace processing.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
  @Param:
    @@Name: namespace-declarations
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Include namespace declaration attributes, specified or 
          defaulted from the schema, in the document.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Discade all namespace declaration attributes.  The namespace 
          prefixes are retained.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
  @Param:
    @@Name: normalize-characters
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@: 
          Fully normalize the characters in the document as defined in 
          the Appendix B of the XML 1.1 Specification.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@: Do not perform character normalization.
  @Param:
    @@Name:schema-location
    @@IsSupportRequired:1
    @@Type:
      DOMMain:DOMString
    @@InCase:
      @@@Label:
        @@@@lang:en
        @@@@@: A list of DOM URIs, separated by whitespaces
      @@@IsSupportRequired:0
      @@@Description:
        @@@@lang:en
        @@@@@:
          The schemas against which validation should occur, i.e. 
          the current schema.
      \
        The types of schemas must match the <DOM:schema-type>, 
        otherwise the behaviour is undefined.
      \
        The schemas specified here take precedence to the schema 
        specified in the document itself.  For namespace aware schema, 
        if a schema specified using this parameter and a schema 
        specified in the document instance in a schema document 
        share the same <CODE:targetNamespace>, the schema specified 
        by the DOM application will be used.  If two schemas 
        specified by the application share the same 
        <CODE:targetNamespace> or have no namespace, the behavior 
        is implementation dependent.
      \
        This parameter is ignored unless the <DOM:schema-type> 
        value is set.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
        Whitespace = <XML:S> in the XML 1.0 Specification.
      \
        It is strongly recommended that the <A:Document.documentURI>, 
        will be set so that an implementation can successfully resolve 
        any external entities referred. 
    @@InCase:
      @@@Value:
        @@@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@: No location has been provided.
  @Param:
    @@Name:schema-type
    @@IsSupportRequired:1
    @@Type:
      ManakaiDOM:ManakaiDOMURI
    @@InCase:
      @@@Label:
        @@@@lang:en
        @@@@@:
          An absolute DOM URI
      @@@IsSupportRequired:0
      @@@Description:
        @@@@lang:en
        @@@@@:
          The type of the schema language used to validate a document against.
        \
          No lexical cheking is done on the absolute URI.
        \
          A default value may be provided by the DOM implementation, 
          based on the schema languages supported and on the 
          schema language used at load time.
    @@InCase:
      @@@Value:
        http://www.w3.org/TR/REC-xml
      @@@Description:
        @@@@lang:en
        @@@@@: The XML DTD.
    @@InCase:
      @@@Value:
        http://www.w3.org/2001/XMLSchema
      @@@Description:
        @@@@lang:en
        @@@@@: The XML Schema.
    @@InCase:
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@: No valus is provided.
    @@ImplNote:
      @@@lang:en
      @@@@:
        Other schema languages are outside the scope of the W3C 
        and should recommentd an absolute URI in order to use here.
  @Param:
    @@Name: split-cdata-sections
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Split CDATA sections containing the <SGML:MSE> 
          (<XML:]]<gt>>).
        \
          When CDATA section is split, a warning is issued with 
          a <A:DOMError.type> equals to <DOM:cdata-sections-splitted> 
          and <A:DOMError.relatedData> equals to the first 
          <IF:CDATASection> node in document order.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Signal an error if <IF:CDATASection> contains an 
          unrepresentable character.
  @Param:
    @@Name:validate
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Require the validation against a schema of the document 
          as it is being normalized as defined by the XML 1.0 Specification. 
        \
          If validation errors are found or no schema was found, 
          the error handler is notified.
        \
          Schema-normalized values will not exposed unless the 
          parameter <DOM:datatype-normalization> is <DOM:true>.
        \
          Following attributes are revaluated:
        \
          - Attribute nodes with <A:Attr.specified> equals to <DOM:false>.
        \
          - The value of the attribute <A:Text.isElementContentWhitespace> 
          for all <IF:Text> nodes.
        \
          - The value of the attribute <A:Attr.isId> for all <IF:Attr> nodes.
        \
          - The attributes <A:Element.schemaTypeInfo> and 
          <A:Attr.schemaTypeInfo>.
        \
          DOM applications should consider setting the parameter 
          <DOM:well-formed> to <DOM:true>.
      @@@SetParam:
        @@@@Name: validate-if-schema
        @@@@Type:boolean
        @@@@Value: false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Do not accomplish schema processing, including internal subset 
          processing.  Default attribute information are kept.
        \
          Note that validation might still happen in case 
          <DOM:validate-if-schema> is <DOM:true>.
  @Param:
    @@Name:validate-if-schema
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Enable validation only if a declaration for the document 
          element can be found in a schema.  If validation is enabled, 
          this parameter has the same behavior as the parameter 
          <DOM:validate> set to <DOM:true>.
      @@@SetParam:
        @@@@Name:validate
        @@@@Type:boolean
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          No schema processing should be performed if the document has 
          a schema, including internal subset 
          processing.  Default attribute information are kept.
        \
          Note that validation might still happen in case 
          <DOM:validate> is <DOM:true>.
  @Param:
    @@Name:well-formed
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Check if all nodes are well-formed according to the XML 
          version in use (<A:Document.xmlVersion>), i.e.:
        \
          - Check if the attribute <A:Node.nodeName> contains 
          invalid characters according to its node type and generate 
          a <IF:DOMError> of type <DOM:wf-invalid-character-in-node-name>, 
          with a <DOM:SEVERITY_ERROR> severity, if necessary.
        \
          - Check if the text content inside <IF:Attr>, <IF:Element>, 
          <IF:Comment>, <IF:Text> and <IF:CDATASection> nodes for 
          invalid characters and generate a <IF:DOMError> of type 
          <DOM:wf-invalid-character>, with a 
          <DOM:SEVERITY_ERROR> severity, if necessary.
        \
          - Check if the data inside <IF:ProcessingInstruction> nodes 
          for invalid characters and generate a <IF:DOMError> 
          of type <DOM:wf-invalid-character>, with a
          <DOM:SEVERITY_ERROR> severity, if necessary.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@: Do not check for XML well-formedness.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false

## ManakaiDOMCore.dis ends here
