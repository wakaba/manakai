Module:
  @QName: MDOM|Element
  @enFN:
    DOM Element Module
  @enDesc:
    The manakai DOM Element Module implements a part of the W3C DOM
    Core module related to elements in the tree structural model 
    for HTML or XML documents.

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/11/04 12:25:13 $

  @Require:
    @@Module:
      @@@QName: MDOM|TreeCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|Document
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XDoctype
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM1
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM2
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM3
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @dxm:
    http://suika.fam.cx/~wakaba/archive/2004/dis/XML#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @ev:
    http://www.w3.org/2001/xml-events
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mg:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Grove/
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @tcd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/CharacterData/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xml-dtd:
    http://www.w3.org/TR/REC-xml
  @xmlns:
    http://www.w3.org/2000/xmlns/

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: L12Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM
  ## Modified in DOM Level 2

ElementTypeBinding:
  @Name: L13Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM
  ## Modified in DOM Level 3

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IL1OnlyMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck:
      !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1 !ManakaiDOM|DOM2
      ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: L2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: CL2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: CL3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: L2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L12Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1
  # Modified in DOM Level 2

ElementTypeBinding:
  @Name: L13Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1
  # Modified in DOM Level 3

ElementTypeBinding:
  @Name: CL2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3
  ## Note that there are attributes introduced in DOM Level 3
  ## but also defined for lower levels as internal attributes
  ## for the purpose of internal use.

ElementTypeBinding:
  @Name: CL3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: LXSet
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: Constants
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: L3Bitmasks
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const

ElementTypeBinding:
  @Name: LXConst
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const
    @@Description:
      @@@lang:en
      @@@ddid:manakai
      @@@@:
        {NOTE::
          This is a manakai extension.
        }

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlDefC
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: XML2Feature
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@ImplNote:
      @@@lang:en
      @@@@:
        The <CITE::DOM Level 2 Core> specification said that HTML-only 
        DOM Level 2 implementations does not need to implement this member. 
        The DOM Level 2 Errata withdraws it and it requires HTML-only 
        DOM implementations throw a <X::DOMException.NOT_SUPPORTED_ERR>. 

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: NodeTypeDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@ISA:
      @@@@: Node
      @@@ForCheck: ManakaiDOM|ForIF
    @@ISA:
      @@@@: tc|ManakaiDOMNode
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: DOMCore|CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: tx|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11
ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Code
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISCore|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: RPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: LXTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: XDTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: Document
  @AliasFor: td|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMImpl
  @AliasFor: c|DOMImplementation
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: unsignedLong
  @AliasFor: idl|unsignedLong||ManakaiDOM|all

ResourceDef:
  @QName: unsignedShort
  @AliasFor: idl|unsignedShort||ManakaiDOM|all

ResourceDef:
  @QName: ARRAY
  @AliasFor: DISPerl|ARRAY||ManakaiDOM|all

ResourceDef:
  @QName: HASH
  @AliasFor: DISPerl|HASH||ManakaiDOM|all

ResourceDef:
  @QName: DocumentX
  @AliasFor: d|DocumentXDoctype
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: DTDef
  @AliasFor: d|DocumentTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ETDef
  @AliasFor: d|ElementTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ATDef
  @AliasFor: d|AttributeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Text
  @AliasFor: tcd|Text
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: NodeList
  @AliasFor: tc|NodeList
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: NamedNodeMap
  @AliasFor: tc|NamedNodeMap
  @For: ManakaiDOM|DOM

ElementTypeBinding:
  @Name: iRaises
  @ElementType:
    dx:raises
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

NodeTypeDef:
  @IFQName: Element
  @ClsQName: ManakaiDOMElement

  @DISLang:role: tc|ElementRole

  @enDesc:
    An <IF::Element> object represents an element in a document.
    Elements may have attributes associated with them.
  
  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|children>} = [];
        $obj->{<H::infoset|attributes>} = {};
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|namespaceName>}},
          $given => {${$opt->{<H::infoset|namespaceName>}}},
        }__;
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|prefix>}},
          $given => {${$opt->{<H::infoset|prefix>}}},
        }__;
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|localName>}},
          $given => {${$opt->{<H::infoset|localName>}}},
        }__;
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:subnode1a: infoset|children
  @mg:subnode2hh: infoset|attributes
  @mg:owner0: tc|ownerDocument
  @mg:origin0: infoset|parent

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|children>, <Q::infoset|attributes>.

        - <Q::infoset|localName>.

      }

      {P:: Optional internal properties:

        - <Q::infoset|parent>.

        - <Q::infoset|prefix>, <Q::infoset|namespaceName>.

        - <Q::c|read-only>.

      }

  @IntMethod:
    @@Operator: mg|CreateNodeRefMethod
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        my $class;
        CLS: {
          if (defined $opt->{<H::mg|nodeRefClass>}) {
            $class = $opt->{<H::mg|nodeRefClass>};
            IFCHK: {
              for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                last IFCHK unless $$class->isa ($_);
              }
              last CLS;
            } # IFCHK
          }

          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $class,
            $prop => {<H::tc|defaultNodeRefClass>},
            $ref => $obj,
          }__;
          if (defined $class) {
            IFCHK: {
              for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                last IFCHK unless $$class->isa ($_);
              }
              last CLS;
            } # IFCHK
          }

          my $nsuri;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $nsuri,
            $prop => {<H::infoset|namespaceName>},
            $ref => $obj,
          }__;
          $nsuri = \'' unless defined $nsuri;
          my $ln;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $ln,
            $prop => {<H::infoset|localName>},
            $ref => $obj,
          }__;

          A: {
            ## Use cases:
            ##   - |html5:a| element type
            ##   - |html5:*| element types

            for my $nm (
              [$nsuri, $ln],
              [$nsuri, \'*'],
            ) {
              unless ($Message::DOM::Element::ElementClass
                  ->{${$nm->[0]}}->{${$nm->[1]}}) {
                if ($Message::Util::AutoLoad::Registry::ElementType
                    ->{${$nm->[0]}}->{${$nm->[1]}}) {
                  eval qq{require $Message::Util::AutoLoad::Registry::ElementType
                      ->{${$nm->[0]}}->{${$nm->[1]}}->{module}};
                  die $@ if $@;
                }
              }

              if ($Message::DOM::Element::ElementClass
                  ->{${$nm->[0]}}->{${$nm->[1]}}) {
                $class = \($Message::DOM::Element::ElementClass
                  ->{${$nm->[0]}}->{${$nm->[1]}});
                last A;
              }
            }

            for my $nm (
              [$nsuri, $ln],
              [$nsuri, \'*'],
            ) {
              for my $__class (sort {
                $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
              } grep {
                $Message::DOM::DOMFeature::ClassInfo
                    ->{<ClassName::ManakaiDOMElement>}
                    ->{compat_class_by_type}
                    ->{${$nm->[0]}}->{${$nm->[1]}}->{$_}
              } keys %{$Message::DOM::DOMFeature::ClassInfo
                           ->{<ClassName::ManakaiDOMElement>}
                           ->{compat_class_by_type}
                           ->{${$nm->[0]}}->{${$nm->[1]}} or {}}) {
                if ($Message::DOM::DOMFeature::ClassInfo->{$__class}
                        ->{has_feature}->{xml}->{'3.0'}) {
                  $class = \$__class;
                  IFCHK: {
                    for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                      last IFCHK unless $$class->isa ($_);
                    }
                    last A;
                  } # IFCHK
                }
              }
            }

            ## Generic
            CLASS: for my $__class (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::DOMFeature::ClassInfo
                  ->{<ClassName::ManakaiDOMElement>}
                  ->{compat_class}->{$_}
            } keys %{$Message::DOM::DOMFeature::ClassInfo
                         ->{<ClassName::ManakaiDOMElement>}
                         ->{compat_class} or {}}) {
              if ($Message::DOM::DOMFeature::ClassInfo->{$__class}
                      ->{has_feature}->{xml}->{'3.0'}) {
                $class = \$__class;
                IFCHK: {
                  for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                    last IFCHK unless $$class->isa ($_);
                  }
                  last A;
                } # IFCHK
              }
            }

            ## Default
            $class = \$self;
          } # A

          __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
            $given => $class,
            $prop => {<H::tc|defaultNodeRefClass>},
            $ref => $obj,
          }__;
        } # CLS
        $r = bless $obj, $$class;

  @CODE:
    @@QName: tc|createElementForTest
    @@PerlDef:
      my $__doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__doc}__;
      $el = $__doc-><M::Document.createElementNS>
                    ('http://www.example.net/', 'ex:element');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.ELEMENT_NODE

    @@Test:
      @@@QName: Element.nodeType.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.nodeType>,
                  expected_value => <C::Node.ELEMENT_NODE>);

  @CL2Attr:
    @@Name: prefix
    @@enDesc:
      The namespace prefix of the node.
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the namespace prefix is unspecified.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;
        $r = defined $v ? $$v : null;
    @@Set:
      @@@nullCase:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified value contains an illegal character according to
          the XML version in use specified in the <A::Document.xmlVersion>
          attribute.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_BAD_NCNAME
        @@@@enDesc:
          If the specified prefix is malformed per the XML Namespaces
          specification.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <A::Node.namespaceURI> of the node is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the specified prefix is <XML::xml> and
          the <A::Node.namespaceURI> of the node is different
          from <URI::http://www.w3.org/XML/1998/namespace>.
      @@@PerlDef:
        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking>) {
          __CODE{tc|NodeReadOnlyError:: $node => $self}__;
          my $nsuri;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $nsuri,
            $prop => {<H::infoset|namespaceName>},
            $ref => $self,
          }__;
          if (not defined $nsuri) {
            __EXCEPTION{MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {null},
            }__;
          } elsif ($$nsuri ne <Q::xml:> and
                   defined $given and $given eq 'xml') {
            __EXCEPTION{MDOMX|MDOM_NS_XML_WITH_OTHER_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {$self-><AG::Node.namespaceURI>},
            }__;
          }
          my $version = $od-><AG::Document.xmlVersion>;
          __CODE{DOMMain:ensureNamespacePrefix::
            $INPUT => $given, $INPUT_PARAM_NAME => '',
            $XMLVERSION => $version,
          }__;
        } # strict
        my $v = defined $given ? \$given : null;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $v,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;

    @@L2Test:
      @@@QName: Element.localName.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         (null, 'el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, null);

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, null);

        $test->id ('prefix.set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Element.localName.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.ns.example/', 'p:el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>,
                              'http://www.ns.example/');

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

        $test->id ('prefix.set');
        $el-><AS::Node.prefix> ('pre');
        $test->assert_equals ($el-><AG::Node.prefix>, 'pre');

    @@L2Test:
      @@@QName: Element.prefix.1.test
      @@@enDesc:
        <M::Document.createElementNS> node with no namespace URI,
        no prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('reset');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> (null);
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Element.prefix.2.test
      @@@enDesc:
        <M::Document.createElement> node.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('reset');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> (null);
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Element.prefix.3.test
      @@@enDesc:
        <M::Document.createElementNS> node with namespace URI, no prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $el-><AS::Node.prefix> ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'prefix');

        $test->id ('reset');
        $el-><AS::Node.prefix> (null);
        $test->assert_equals ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Element.prefix.4.test
      @@@enDesc:
        <M::Document.createElementNS> node with namespace URI and prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'p:el');

        $test->id ('get');
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

        $test->id ('set');
        $el-><AS::Node.prefix> ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'prefix');

        $test->id ('reset');
        $el-><AS::Node.prefix> (null);
        $test->assert_equals ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Element.prefix.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'p:el');

        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('new-prefix');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@L2Test:
      @@@QName: Element.prefix.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'p:el');

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('0120');
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);

    @@L2Test:
      @@@QName: Element.prefix.7.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'p:el');

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('a:b');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_BAD_NCNAME>);

    @@enImplNote:
      @@@ddid: moretest
      @@@@:
        {TODO::
          More tests for namespace errors and XML 1.1 error are necessary.
        }

  @Test:
    @@QName: Element.parentNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');

      $test->assert_null ($el-><AG::Node.parentNode>);

  @Test:
    @@QName: Element.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');

      my $el2 = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Element.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');

      my $el2 = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: Element.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createElementNS> (null, 'el');

      $test->id ('default');
      $test->assert_false ($el-><AG::Node.manakaiReadOnly>);
  
  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: td|DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::td|DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        if ($self_od-><AG::Document.strictErrorChecking>) {
          my $anode = $self;
          while (defined $anode) {
            if ($anode eq $newChild) {
              __EXCEPTION{MDOMX|HIERARCHY_ANCESTOR_OR_SELF::
                MDOMX|param-name => 'newChild',
                c|node => {$newChild},
              }__;
            }
            $anode = $anode-><AG::Node.parentNode>;
          }
        }
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: td|DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::td|DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        if ($self_od-><AG::Document.strictErrorChecking>) {
          my $anode = $self;
          while (defined $anode) {
            if ($anode eq $newChild) {
              __EXCEPTION{MDOMX|HIERARCHY_ANCESTOR_OR_SELF::
                MDOMX|param-name => 'newChild',
                c|node => {$newChild},
              }__;
            }
            $anode = $anode-><AG::Node.parentNode>;
          }
        }
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: td|DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::td|DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        if ($self_od-><AG::Document.strictErrorChecking>) {
          my $anode = $self;
          while (defined $anode) {
            if ($anode eq $newChild) {
              __EXCEPTION{MDOMX|HIERARCHY_ANCESTOR_OR_SELF::
                MDOMX|param-name => 'newChild',
                c|node => {$newChild},
              }__;
            }
            $anode = $anode-><AG::Node.parentNode>;
          }
        }
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;
  
  @CAttr:
    @@Name: attributes
    @@enDesc:
      A named node map containing the attributes of the node.
    @@Type: NamedNodeMap
    @@Get:
      @@@PerlDef:
        __CODE{tc|getAttrMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: Element.attributes.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        
        my $as = $el-><AG::Node.attributes>;
        $test->assert_isa ($as, <IFName::NamedNodeMap>);

        $el-><M::Element.setAttribute> (at1 => 'value');
        $test->assert_equals 
                 ($as-><M::NamedNodeMap.getNamedItem> ('at1'),
                  $el-><M::Element.getAttributeNode> ('at1'));

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        Same as <A::Element.tagName>.
      @@@disDef:
        @@@@DISPerl:cloneCode:.tagName.get

  @Attr:
    @@Name: tagName
    @@enDesc:
      The name of the element.
    @@enDesc:
      @@@ddid: ns
      @@@@:
        If the <A::Node.localName> is different from <DOM::null>,
        then the attribute value is the qualified name of the 
        element node.  <SRC::DOM3>
    @@enDesc:
      @@@ddid:html
      @@@@:
        In the HTML DOM it is the canonical uppercase form,
        regardless of the case in the source HTML document.
    @@Type: DOMString
    @@Get:
      @@@PerlDef: 
        my $prefix;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $prefix,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;
        my $lname;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $lname,
          $prop => {<H::infoset|localName>},
          $ref => $self,
        }__;
        $r = defined $prefix ? $$prefix.':'.$$lname : $$lname;
    @@enImplNote:
      {ISSUE::
        In HTML?
      }

      {NOTE::
        DOM Level 1 nodes are no longer supported.
      }

    @@Test:
      @@@QName: Element.nodeName.tagName.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('tagName');
        $test->assert_equals ($el-><AG::Element.tagName>, 'element1');

    @@Test:
      @@@QName: Element.nodeName.tagName.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('tagName');
        $test->assert_equals ($el-><AG::Element.tagName>, 'element1');

    @@Test:
      @@@QName: Element.nodeName.tagName.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://el1.test/', 'element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('tagName');
        $test->assert_equals ($el-><AG::Element.tagName>, 'element1');

    @@Test:
      @@@QName: Element.nodeName.tagName.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://el1.test/', 'pfx:element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'pfx:element1');

        $test->id ('tagName');
        $test->assert_equals ($el-><AG::Element.tagName>, 'pfx:element1');

    @@Test:
      @@@QName: Element.appendChild.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Element.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Element.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: Element.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Element.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Element.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);


        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Element.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: Element.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createElement> ('dt');

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: Element.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createElement> ('dt');
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: Element.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: Element.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: Element.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Element.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Element.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Element.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: Element.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.appendChild.ancestor.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        $dtd-><M::Node.appendChild>
                ($doc-><M::Document.createTextNode> ('text1'));

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($dtd);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($dtd);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($dtd, $dtd-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

    @@Test:
      @@@QName: Element.appendChild.ancestor.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        $dtd-><M::Node.appendChild>
                ($doc-><M::Document.createTextNode> ('text1'));
        my $el = $doc-><M::Document.createElement> ('el');
        $el-><M::Node.appendChild> ($dtd);

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($el);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($el);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($el, $dtd-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

    @@Test:
      @@@QName: Element.appendChild.ancestor.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        $dtd-><M::Node.appendChild>
                ($doc-><M::Document.createTextNode> ('text1'));
        my $el = $doc-><M::Document.createElement> ('el');
        $el-><M::Node.appendChild> ($dtd);
        my $el2 = $doc-><M::Document.createElement> ('el');
        $el2-><M::Node.appendChild> ($el);

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($el2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($el2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($el2, $dtd-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMAttr.manakaiAppendText

    @@Test:
      @@@QName: Element..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $node = $doc-><M::Document.createElement> ('node');

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::Element>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.textContent>, 'string');
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRINGtext');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMElement>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Element.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createElementForTest:: $el => $node}__;

        for (
          [Core => '1.0', <IFName::Element||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Element||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Element||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Element||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Element||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Element||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is not available.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|baseURI>},
          $ref => $self,
        }__;
        unless (defined $r) {
          __DEEP{
            my $xb = $self-><M::Element.getAttributeNodeNS>
                              (<Q::xml:>, 'base');
            unless (defined $xb) {
              $xb = $self-><M::Element.getAttributeNodeNS>
                             (null, 'xml:base');
            }
            if ($xb) {
              $r = $xb-><AG::Attr.value>;
              if (<Code::DOMMain|isRelativeDOMURI:: $INPUT = $r>) {
                my $xbbase = $xb-><AG::Node.baseURI>;
                $r = $self-><AG::Node.ownerDocument>
                          -><AG::Document.implementation>
                          -><M::urigen|URIImplementation.createURIReference>
                              ($r)
                          -><M::urigen|URIReference.getAbsoluteReference>
                              ($xbbase)
                          -><AG::urigen|URIReference.uriReference>
                  if defined $xbbase;
              }
            } else {
              my $pe = $self-><AG::Node.parentNode>;
              W: {
                while (defined $pe) {
                  my $nt = $pe-><AG::Node.nodeType>;
                  if ($nt == <C::Node.ELEMENT_NODE> or
                      $nt == <C::Node.DOCUMENT_NODE> or
                      $nt == <C::Node.DOCUMENT_FRAGMENT_NODE> or
                      $nt == <C::Node.ENTITY_NODE>) {
                    $r = $pe-><AG::Node.baseURI>;
                    last W;
                  } elsif ($nt == <C::Node.ENTITY_REFERENCE_NODE>) {
                    if ($pe-><AG::tx|EntityReference.manakaiExternal>) {
                      $r = $pe-><AG::tx|EntityReference.manakaiEntityBaseURI>;
                      last W;
                    }
                  }
                  $pe = $pe-><AG::Node.parentNode>;
                }
                if ($pe) {
                  $r = $pe-><AG::Node.baseURI>;
                } else {
                  $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
                }
              } # W
            }
          }__;
        }

    @@LXTest:
      @@@QName: Element.baseURI.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'el');

        $test->id ('initial');
        $test->assert_null ($el-><AG::Node.baseURI>);
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://foo.example/>);
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://foo.example/>);
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);

        $test->id ('xb.abs');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://www.example.com/>);
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://www.example.com/>);
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);

        $test->id ('xb.rel');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<bar>);
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://foo.example/bar>);
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);

        $test->id ('mbu.set');
        $el-><AS::Element.manakaiBaseURI> (q<http://baz.example/>);
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://baz.example/>);
        $test->assert_equals
                 ($el-><AG::Element.manakaiBaseURI>,
                  q<http://baz.example/>);

        $test->id ('mbu.unset');
        $el-><AS::Element.manakaiBaseURI> (null);
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://foo.example/bar>);
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);
    @@LXTest:
      @@@QName: Element.baseURI.1.nons.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'el');

        $test->id ('initial');
        $test->assert_null ($el-><AG::Node.baseURI>);
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://foo.example/>);
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://foo.example/>);
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);

        $el-><M::Element.setAttribute> ('xml:base',
                                        q<http://www.example.com/>);
        $test->id ('xb.abs.baseURI');
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://www.example.com/>);
        $test->id ('xb.abs.manakaiBaseURI');
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);

        $test->id ('xb.rel');
        $el-><M::Element.setAttribute> ('xml:base', q<bar>);
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://foo.example/bar>);
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);

        $test->id ('mbu.set');
        $el-><AS::Element.manakaiBaseURI> (q<http://baz.example/>);
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://baz.example/>);
        $test->assert_equals
                 ($el-><AG::Element.manakaiBaseURI>,
                  q<http://baz.example/>);

        $test->id ('mbu.unset');
        $el-><AS::Element.manakaiBaseURI> (null);
        $test->assert_equals
                 ($el-><AG::Node.baseURI>,
                  q<http://foo.example/bar>);
        $test->assert_null ($el-><AG::Element.manakaiBaseURI>);
    @@LXTest:
      @@@QName: Element.baseURI.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createElementNS> (null, 'el');
       
        $test->id ('default');
        $test->assert_null ($pi-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://doc.test/>);

        $test->id ('el');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://el.test/>);
        $el-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://el.test/>);

        $test->id ('ent');
        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);
        $ent-><AS::tx|EntityReference.manakaiExternal> (true);
        $ent-><AS::tx|EntityReference.manakaiEntityBaseURI> (q<http://ent.test/>);
        $el-><M::Node.appendChild> ($ent);
        $ent-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://ent.test/>);

  @ResourceDef:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM ManakaiDOM:ForClass
    @@DISCore:resourceType:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !tc|ForSelect !tc|ForRemove
    @@resourceFor: tc|ForSelect
    @@resourceFor: tc|ForRemove

    @@QName:
      @@@@: selectAttrNodeObject
      @@@ForCheck: tc|ForSelect
    @@NSVersion:
      @@@@: selectAttrNodeObjectNS
      @@@ForCheck: tc|ForSelect
      @@@ContentType: DISCore|TFQNames

    @@QName:
      @@@@: selectAttrNodeObjectForRemove
      @@@ForCheck: tc|ForRemove
    @@NSVersion:
      @@@@: selectAttrNodeObjectForRemoveNS
      @@@ForCheck: tc|ForRemove
      @@@ContentType: DISCore|TFQNames

    @@DISCore:resourceType: DISPerl|BlockCode

    @@enDesc:
      Selects an attribute node stem.

    @@Param:
      @@@Name:name
      @@@Type:
        @@@@@:
          DOMMain:ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of the attribute to select.
    @@Param:
      @@@Name: r
      @@@Out: 1
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF::NodeStem> object.  If there is no attribute
          node, then its value is left unchanged.
    @@PerlDef:
      my $__attr;
      __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
        $r => $__attr,
        $prop => {<H::infoset|attributes>},
        $ref => $self,
      }__;

      ## Note that we no longer support DOM Level 1 nodes.

      ## If an attribute's qualified name is equal to
      ## the requested name, then the node is the answer.

      ## Note that if there is a namespace ill-formed attribute,
      ## the result is not the expected one.  For example,
      ## if an |xmlns| attribute in the |http://www.w3.org/2000/xmlns/|
      ## namespace has non-NULL |prefix|, a request to get |xmlns|
      ## attribute will not return that node.

      ## |sort|ing is required so that every |getAttribute|, |setAttribute|,
      ## |hasAttribute|, |removeAttribute|, or any other namespace unaware
      ## methods operates on the same node even if there is 
      ## multiple nodes with the same qualified name.

      NS: for my $__ns (sort {$a cmp $b} keys %$__attr) {
        for my $__ln (sort {$a cmp $b} keys %{$__attr->{$__ns}}) {
          my $__node;
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$__attr->{$__ns}->{$__ln}},
            $ref => $__node,
            $opt => {{
            }},
          }__;
          if ($__node-><AG::Node.nodeName> eq $name) {
            __FOR{!tc:ForRemove::
              $r = $__node;
            }__;
            __FOR{tc:ForRemove::
              $r = $__node;
              $list = $__attr->{$__ns};
              $key = $__ln;
            }__;
            last NS;
          }
        } # ln
      } # NS

  @ResourceDef:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM ManakaiDOM:ForClass
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !tc|ForRemove !tc|ForSelect
    @@resourceFor: tc|ForSelect
    @@resourceFor: tc|ForRemove

    @@QName:
      @@@@: selectAttrNodeObjectNS
      @@@ForCheck: tc|ForSelect
    @@NoNSVersion:
      @@@@: selectAttrNodeObject
      @@@ForCheck: tc|ForSelect
      @@@ContentType: DISCore|TFQNames
    @@rdf:type:
      @@@@: DISPerl|BlockCode
      @@@ForCheck: tc|ForSelect
    
    @@QName:
      @@@@: selectAttrNodeObjectForRemoveNS
      @@@ForCheck: tc|ForRemove
    @@NoNSVersion:
      @@@@: selectAttrNodeObjectForRemove
      @@@ForCheck: tc|ForRemove
      @@@ContentType: DISCore|TFQNames
    @@rdf:type:
      @@@@: DISPerl|BlockCode
      @@@ForCheck: tc|ForRemove

    @@enDesc:
      Selects an attribute node by namespace URI and local name.

      This code is used by the implementations of 
      <M::Element.getAttributeNS>, <M::Element.setAttributeNS>, and
      <M::Element.removeAttributeNS>.

      <Perl::$self> (in): The element node.

      <Perl::$namespaceURI> (in): The namespace URI.  It <kwd:MAY>
          be <DOM::null>.

      <Perl::$localName> (in): The local name.

      <Perl::$r> (out): The selected attribute, if any, or <DOM::null>.

      <Perl::$list> (out; for remove only): The hash that
          contains a reference to the <Perl::$r>.
    @@PerlDef:
      @@@ForCheck: !tc|ForRemove
      @@@@:
        my $__attrs;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $__attrs,
          $prop => {<H::infoset|attributes>},
          $ref => $self,
        }__;
        if (defined $__attrs->{defined $namespaceURI ? $namespaceURI : ''}
                            ->{$localName}) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$__attrs->{defined $namespaceURI ? $namespaceURI : ''}
                                ->{$localName}},
            $ref => $r,
            $opt => {{
            }},
          }__;
        }
    @@PerlDef:
      @@@ForCheck: tc|ForRemove
      @@@@:
        my $__attrs;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $__attrs,
          $prop => {<H::infoset|attributes>},
          $ref => $self,
        }__;
        $list = $__attrs->{defined $namespaceURI ? $namespaceURI : ''};
        if (defined $list and defined $list->{$localName}) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$__attrs->{defined $namespaceURI ? $namespaceURI : ''}
                                ->{$localName}},
            $ref => $r,
            $opt => {{
            }},
          }__;
        }

  @Method:
    @@Name: getAttribute
    @@enDesc:
      Retrueves an attribute value by name.
    @@NSVersion:.getAttribute
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name of the attribute to retrieve.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The value of the <IF::Attr> as a string.
      @@@InCase:
        @@@@Value:
          @@@@@@: \
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          If the attribute does not have a specified or default value.
          <SRC::DOM1, DOM2, DOM3>
      @@@nullCase:
        @@@@enDesc:
          If the attribute does not have a specified or default value.
          <SRC::manakai>
      @@@PerlDef:
        my $node;
        __CODE{selectAttrNodeObject::
          $name => $name,
          $self => $self,
          $r => $node,
        }__;
        if (defined $node) {
          $r = $node-><AG::Attr.value>;
        } else {
          $r = null;
        }

    @@Test:
      @@@QName: Element.getAttribute.1.test
      @@@enDesc:
        No NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttribute> ('a1'));

        $test->id ('specified'); 
        my $attr = $doc-><M::Document.createAttribute> ("a1");
        $attr-><AS::Attr.value> ('value1');

        $el-><M::Element.setAttributeNode> ($attr);

        my $return = $el-><M::Element.getAttribute> ("a1");
        $test->assert_equals ($return, "value1");

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttribute> ('a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttribute.2.test
      @@@enDesc:
        NS = <DOM::null> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttribute> ('a1'));

        $test->id ('specified'); 
        my $attr = $doc-><M::Document.createAttributeNS> (null, "a1");
        $attr-><AS::Attr.value> ('value1');

        $el-><M::Element.setAttributeNodeNS> ($attr);

        my $return = $el-><M::Element.getAttribute> ("a1");
        $test->assert_equals ($return, "value1");

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttribute> ('a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttribute.3.test
      @@@enDesc:
        NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttribute> ('ns:a1'));

        $test->id ('specified'); 
        my $attr = $doc-><M::Document.createAttributeNS>
                           ('http://ns.test/', "ns:a1");
        $attr-><AS::Attr.value> ('value1');

        $el-><M::Element.setAttributeNode> ($attr);

        my $return = $el-><M::Element.getAttribute> ("ns:a1");
        $test->assert_equals ($return, "value1");

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttribute> ('ns:a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttribute.4.test
      @@@enDesc:
        <XA::xmlns> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttribute> ('xmlns'));

        $test->id ('specified'); 
        my $attr = $doc-><M::Document.createAttributeNS>
                           (<Q::xmlns:>, 'xmlns');
        $attr-><AS::Attr.value> ('value1');

        $el-><M::Element.setAttributeNode> ($attr);

        my $return = $el-><M::Element.getAttribute> ('xmlns');
        $test->assert_equals ($return, "value1");

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttribute> ('xmlns');
        $test->assert_equals ($return2, 'value1');

  @L2Method:
    @@Name: getAttributeNS
    @@enDesc:
      Retrieves an attribute value by local name and namespace URI.
    @@NoNSVersion:.getAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to retrieve.
      @@@nullCase:
        @@@@enDesc:
          If the attribute has no namespace.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLLocalName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The local name of the attribute to retrieve.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The value of the <IF::Attr> as a string.
      @@@InCase:
        @@@@Value:
          @@@@@@: \
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          If the attribute does not have a specified or default value.
          <SRC::DOM2, DOM3>
      @@@nullCase:
        @@@@enDesc:
          If the attribute does not have a specified or default value.
          <SRC::manakai>
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature 
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        my $node;
        __CODE{selectAttrNodeObjectNS::
          $self => $self,
          $namespaceURI => $namespaceURI, $localName => $localName,
          $r => $node,
        }__;
        if (defined $node) {
          $r = $node-><AG::Attr.value>;
        } else {
          $r = null;
        }

    @@Test:
      @@@QName: Element.getAttributeNS.1.test
      @@@enDesc:
        NS = <DOM::null> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttributeNS> (null, 'a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $attr-><AS::Attr.value> ('value1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return1 = $el-><M::Element.getAttributeNS> (null, 'a1');
        $test->assert_equals ($return1, 'value1');

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttributeNS> (null, 'a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttributeNS.2.test
      @@@enDesc:
        Non NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttributeNS> (null, 'a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $attr-><AS::Attr.value> ('value1');
        $el-><M::Element.setAttributeNode> ($attr);
        my $return1 = $el-><M::Element.getAttributeNS> (null, 'a1');
        $test->assert_equals ($return1, 'value1');

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttributeNS> (null, 'a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttributeNS.3.test
      @@@enDesc:
        NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $ns = 'http://ns.test/';

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttributeNS> ($ns, 'a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttributeNS> ($ns, 'p:a1');
        $attr-><AS::Attr.value> ('value1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return1 = $el-><M::Element.getAttributeNS> ($ns, 'a1');
        $test->assert_equals ($return1, 'value1');

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttributeNS> ($ns, 'a1');
        $test->assert_equals ($return2, 'value1');

        $test->id ('prefixed');
        $test->assert_null ($el-><M::Element.getAttributeNS> ($ns, 'p:a1'));

  @Method:
    @@Name: getAttributeNode
    @@enDesc:
      Retrieves an attribute node by name.
    @@NSVersion:.getAttributeNodeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name (<A::Node.nodeName>) of the attribute to retrieve.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node with the specified <P::name>.
      @@@nullCase:
        @@@@enDesc:
          If there is no such attribute.
      @@@PerlDef:
        __CODE{selectAttrNodeObject::
          $name => $name,
          $self => $self,
          $r => $r,
        }__;

    @@Test:
      @@@QName: Element.getAttributeNode.1.test
      @@@enDesc:
        No NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNode> ('a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $el-><M::Element.setAttributeNode> ($attr);
        my $return2 = $el-><M::Element.getAttributeNode> ('a1');
        $test->assert_equals ($return2, $attr);
    @@Test:
      @@@QName: Element.getAttributeNode.2.test
      @@@enDesc:
        NS = <DOM::null> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNode> ('a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNode> ($attr);
        my $return2 = $el-><M::Element.getAttributeNode> ('a1');
        $test->assert_equals ($return2, $attr);
    @@Test:
      @@@QName: Element.getAttributeNode.3.test
      @@@enDesc:
        NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $ns = 'http://ns.test/';

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNode> ('p:a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttributeNS> ($ns, 'p:a1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return2 = $el-><M::Element.getAttributeNode> ('p:a1');
        $test->assert_equals ($return2, $attr);

        $test->id ('prefix.changed');
        $attr-><AS::Node.prefix> ('q');
        my $return3 = $el-><M::Element.getAttributeNode> ('p:a1');
        $test->assert_null ($return3);

  @L2Method:
    @@Name: getAttributeNodeNS
    @@enDesc:
      Retrieves an <IF::Attr> node by namespace URI and local name.
    @@NoNSVersion:.getAttributeNode
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to retrieve.
      @@@nullCase:
        @@@@enDesc:
          If the attribute has no namespace.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the attribute to retrieve.
    @@Return:
      @@@Type: Attr
      @@@enDesc: 
        The <IF::Attr> node with the specified namespace URI
        and local name.
      @@@nullCase:
        @@@@enDesc:
          If there is no such attribute.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        __CODE{selectAttrNodeObjectNS::
          $self => $self,
          $namespaceURI => $namespaceURI, $localName => $localName,
          $r => $r,
        }__;

    @@Test:
      @@@QName: Element.getAttributeNodeNS.1.test
      @@@enDesc:
        No NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $el-><M::Element.setAttributeNode> ($attr);
        my $return2 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_equals ($return2, $attr);
    @@Test:
      @@@QName: Element.getAttributeNodeNS.2.test
      @@@enDesc:
        NS = <DOM::null> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return2 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_equals ($return2, $attr);
    @@Test:
      @@@QName: Element.getAttributeNodeNS.3.test
      @@@enDesc:
        NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $ns = 'http://ns.test/';

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttributeNS> ($ns, 'p:a1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return2 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_equals ($return2, $attr);

        $test->id ('prefix.changed');
        $attr-><AS::Node.prefix> ('q');
        my $return3 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_equals ($return3, $attr);

        $test->id ('prefixed');
        my $return4 = $el-><M::Element.getAttributeNodeNS> ($ns, 'q:a1');
        $test->assert_null ($return4);
  
  @L2Method:
    @@Name: hasAttribute
    @@enDesc:
      Returns whether an attribute with a given name is specified
      on the element or has a default value or not.
    @@NSVersion:.hasAttributeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name of the attribute to look for.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If an attribute with the given name is specified
          on the element or has a default value.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        my $node;
        __CODE{selectAttrNodeObject::
          $name => $name,
          $self => $self,
          $r => $node,
        }__;
        $r = defined $node;

    @@Test:
      @@@QName: Element.hasAttribute.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        $test->assert_true ($el-><M::Element.hasAttribute> ('a1'));
    @@Test:
      @@@QName: Element.hasAttribute.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        $test->assert_true ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('prefixed');
        $el-><M::Element.removeAttributeNode> ($attr);
        $el-><M::Element.setAttributeNS> ('about:', 'p:a1', 'v2');
        $test->assert_false ($el-><M::Element.hasAttribute> ('a1'));
    @@Test:
      @@@QName: Element.hasAttribute.3.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttribute> ('m:a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttributeNS> ('mocha:', 'm:a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttribute> ('m:a1'));

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        $test->assert_true ($el-><M::Element.hasAttribute> ('m:a1'));

  @L2Method:
    @@Name: hasAttributeNS
    @@enDesc:
      Returns whether an attribute with a given namespace URI
      and local name is specified on the element or has a default
      value or not.
    @@NoNSVersion:.hasAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to look for.
      @@@nullCase:
        @@@@enDesc:
          The attribute has no namespace.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLLocalName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The local name of the attribute to look for.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If an attribute with the given namespace URI and
          local name is specified on the element or has a default value.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        my $node;
        __CODE{selectAttrNodeObjectNS::
          $self => $self,
          $namespaceURI => $namespaceURI, $localName => $localName,
          $r => $node,
        }__;
        $r = defined $node;

    @@Test:
      @@@QName: Element.hasAttributeNS.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        
        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttributeNS> (null, 'a1'));

        $test->id ('2');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttributeNS> (null, 'a1'));
    @@Test:
      @@@QName: Element.hasAttributeNS.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        
        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttributeNS> (null, 'a1'));

        $test->id ('1');
        my $attr2 = $doc-><M::Document.createAttributeNS> ('about:', 'a:a1');
        $el-><M::Element.setAttributeNodeNS> ($attr2);
        $test->assert_false ($el-><M::Element.hasAttributeNS> (null, 'a1'));

        $test->id ('2');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttributeNS> (null, 'a1'));
    @@Test:
      @@@QName: Element.hasAttributeNS.3.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $ns = 'about:';
        
        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttributeNS> ($ns, 'a1'));

        $test->id ('1');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_false ($el-><M::Element.hasAttributeNS> ($ns, 'a1'));

        $test->id ('2');
        my $attr2 = $doc-><M::Document.createAttributeNS> ($ns, 'a:a1');
        $el-><M::Element.setAttributeNodeNS> ($attr2);
        $test->assert_true ($el-><M::Element.hasAttributeNS> ($ns, 'a1'));

  @Method:
    @@Name: setAttribute
    @@enDesc:
      Adds a new attribute.  If an attribute with that name is
      already present in the element, its value is changed to be
      that of the <P::value> parameter.
    @@NSVersion:.setAttributeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name of the attribute to create or alter.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value to set in string form.
  
        This value is a simple string; it is not parsed to scan
        e.g. entity references as it is being set.
    @@Return:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified <P::name> is not an XML <CODE::Name>
          according to the XML version in use specified in
          the <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_ATTR
        @@@@enDesc:
          If there is the attribute whose <A::Attr.name> is equal
          to the <P::name> and that attribute node is read-only.
          <SRC::manakai>
      @@@PerlDef:
        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking>) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }
          my $version = $od-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name,
            $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $__anode;
        __CODE{selectAttrNodeObject::
          $name => $name,
          $self => $self,
          $r => $__anode,
        }__;
        if (defined $__anode) { ## There is already a node with such a |name|
          if ($__anode-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_ATTR::
              MDOMX|param-name => 'name',
              c|node => {$__anode},
            }__;
          }
        } else { ## There is no such attribute
          __DEEP{
            $__anode = $od-><M::Document.createAttribute> ($name);
            my $__attrs;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $__attrs,
              $prop => {<H::infoset|attributes>},
              $ref => $self,
            }__;
            $__attrs->{''}->{$name}
                = <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $__anode>;
            __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
              $prop => {<H::infoset|ownerElement>},
              $ref => $__anode,
              $given => $self,
            }__;
          }__;
          __CODE{setAttribute.setSchemaTypeInfo::
            $element => $self,
            $attribute => $__anode,
            $attribute_name => $name,
            $ownerDocument => $od,
          }__;
        }
        __DEEP{
          $__anode-><AS::Attr.value> ($value);
          $__anode-><AS::Attr.specified> (true);
        }__;

    @@Test:
      @@@QName: Element.setAttribute.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttribute> ('a1', 'v1');

        my $a1 = $el-><M::Element.getAttributeNode> ('a1');
        $test->id ('new.node.isa');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->id ('new.node.namespaceURI');
        $test->assert_null ($a1-><AG::Node.namespaceURI>);
        $test->id ('new.node.localName');
        $test->assert_equals ($a1-><AG::Node.localName>, 'a1');
        $test->id ('new.node.value');
        $test->assert_equals ($a1-><AG::Attr.value>, 'v1');
        $test->id ('new.node.specified');
        $test->assert_true ($a1-><AG::Attr.specified>);
        $test->id ('new.node.ownerElement');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

        $el-><M::Element.setAttribute> ('a1', 'v2');
        $test->id ('changed.equals');
        my $a2 = $el-><M::Element.getAttributeNode> ('a1');
        $test->assert_equals ($a2, $a1);
        $test->id ('changed.value');
        $test->assert_equals ($a2-><AG::Attr.value>, 'v2');
        $test->id ('changed.node.specified');
        $test->assert_true ($a2-><AG::Attr.specified>);

        $a2-><AS::Attr.specified> (false);

        $test->id ('specified.changed');
        $el-><M::Element.setAttribute> ('a1', 'v2');
        $test->assert_true ($a2-><AG::Attr.specified>);
    @@Test:
      @@@QName: Element.setAttribute.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang', 'ja');

        $el-><M::Element.setAttribute> ('xml:lang', 'en');
        $test->assert_equals
                 ($el-><M::Element.getAttributeNS> (<Q::xml:>, 'lang'), 'en');
    @@Test:
      @@@QName: Element.setAttribute.dtdtype.1.test
      @@@enDesc:
        Non-NS element, non-NS attribute, CDATA.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.declaredType> (<C::ATDef.CDATA_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElement> ('et1');

        $el-><M::Element.setAttribute> ('dattr1', ' attribute  value  ');
        my $attre = $el-><M::Element.getAttributeNode> ('dattr1');

        $test->id ('attributeType');
        $test->assert_num_equals
                 (actual_value => $attre-><AG::Attr.manakaiAttributeType>,
                  expected_value => <C::ATDef.CDATA_ATTR>);
    @@Test:
      @@@QName: Element.setAttribute.dtdtype.2.test
      @@@enDesc:
        Non-NS element, non-NS attribute, IDREFS.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.declaredType> (<C::ATDef.IDREFS_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElement> ('et1');

        $el-><M::Element.setAttribute> ('dattr1', ' attribute  value  ');
        my $attre = $el-><M::Element.getAttributeNode> ('dattr1');

        $test->id ('attributeType');
        $test->assert_num_equals
                 (actual_value => $attre-><AG::Attr.manakaiAttributeType>,
                  expected_value => <C::ATDef.IDREFS_ATTR>);
    @@Test:
      @@@QName: Element.setAttribute.dtdtype.3.test
      @@@enDesc:
        Non-NS element, <XA::xml:lang> attribute, NMTOKEN.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('xml:lang');
            $at-><AS::ATDef.declaredType> (<C::ATDef.NMTOKEN_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElement> ('et1');

        $el-><M::Element.setAttribute> ('xml:lang', ' en  ');
        my $attre = $el-><M::Element.getAttributeNode> ('xml:lang');

        $test->id ('attributeType');
        $test->assert_num_equals
                 (actual_value => $attre-><AG::Attr.manakaiAttributeType>,
                  expected_value => <C::ATDef.NMTOKEN_ATTR>);
    @@L3Test:
      @@@QName: Element.setAttribute.xmlid.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $cfg = $el-><AG::Node.ownerDocument>-><AG::Document.domConfig>;

        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);

        $test->id ('id.xmlid');
        $el-><M::Element.setAttribute> ('xml:id' => 'value');
        my $sti = $el-><M::Element.getAttributeNode> ('xml:id')
                     -><AG::Attr.schemaTypeInfo>;
        $test->assert_equals ($sti-><AG::c|TypeInfo.typeName>, 'ID');
        $test->assert_equals
                 ($sti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);

        $test->id ('id.other');
        $el-><M::Element.setAttribute> ('id' => 'value');
        my $sti2 = $el-><M::Element.getAttributeNode> ('id')
                      -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti2-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti2-><AG::c|TypeInfo.typeNamespace>);

        my $el2 = $el-><AG::Node.ownerDocument>
                     -><M::Document.createElement> ('e');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);

        $test->id ('noid.xmlid');
        $el2-><M::Element.setAttribute> ('xml:id' => 'value');
        my $sti3 = $el2-><M::Element.getAttributeNode> ('xml:id')
                       -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti3-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti3-><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.other');
        $el2-><M::Element.setAttribute> ('id' => 'value');
        my $sti4 = $el2-><M::Element.getAttributeNode> ('id')
                       -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti4-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti4-><AG::c|TypeInfo.typeNamespace>);

  @L2Method:
    @@Name: setAttributeNS
    @@enDesc:
      Adds a new attribute.  If an attribute with the same namespace
      URI and local name is already present on the element, its
      prefix is changed to be the prefix part of the <P::qualifiedName>
      parameter and its value is changed to be the <P::value>
      parameter.
    @@NoNSVersion:.setAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to create or alter.
      @@@nullCase:
        @@@@enDesc:
          If the attribute has no namespace.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@enDesc:
        The qualified name of the attribute to create or alter.
      @@@InCase:
        @@@@Type: ARRAY
        @@@@enDesc:
          A reference to the array that contains the namespace
          prefix (zeroth item) and the local name (first item)
          of the attribute.  The namespace prefix <kwd:MAY>
          be <DOM::null> to indicate that the qualified name
          contains no <CHAR::COLON> character.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value to set in string form.

        This value is a simple string; it is not parsed to scan
        e.g. entity references as it is being set.
    @@Return:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified qualified name is not an <CODE::XML>
          name according to the XML version in use specified
          in the <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_ATTR
        @@@@enDesc:
          If there is the attribute specified by namespace URI and
          local name and that attribute node is read-only.
          <SRC::manakai>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
           If the <P::qualifiedName> is malformed per the XML
           Namespaces specification.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix and the 
          <P::namespaceURI> is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xmlns>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> is <XA::xmlns> and the
          <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM2, DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_OTHER_WITH_XMLNS_URI
        @@@@enDesc:
          If the <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns/>
          and neither the <P::qualifiedName> nor its prefix
          is <XML::xmlns>.  <SRC::DOM3>
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        my ($prefix, $localName) = ref $qualifiedName eq 'ARRAY'
                                     ? @$qualifiedName
                                     : split /:/, $qualifiedName, 2;
        ($prefix, $localName) = (null, $prefix) unless defined $localName;

        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking>) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }
          my $version = $od-><AG::Document.xmlVersion>;
          $qualifiedName = defined $prefix ? $prefix.':'.$localName
                                           : $localName;
          __CODE{DOMMain|ensureXMLQName::
            $INPUT => $qualifiedName, 
            $INPUT_PARAM_NAME => 'qualifiedName',
            $XMLVERSION => $version,
          }__;
          __CODE{DOMMain|checkXMLNamesQName::
            $PREFIX => $prefix, $NSURI => $namespaceURI,
            $LNAME => $localName,
          }__;
        }
        __CODE{tc|setAttrValueNS::
          $namespaceURI => $namespaceURI,
          $prefix => $prefix,
          $localName => $localName,
          $qualifiedName => $qualifiedName,
          $element => $self,
          $value => $value,
          $ownerDocument => $od,
        }__;

    @@Test:
      @@@QName: Element.setAttributeNS.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttributeNS> (null, 'a1', 'v1');
        my $a1 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->id ('new.node');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->id ('new.namespaceURI');
        $test->assert_null ($a1-><AG::Node.namespaceURI>);
        $test->id ('new.localName');
        $test->assert_equals ($a1-><AG::Node.localName>, 'a1');
        $test->id ('new.prefix');
        $test->assert_null ($a1-><AG::Node.prefix>);
        $test->id ('new.value');
        $test->assert_equals ($a1-><AG::Attr.value>, 'v1');
        $test->id ('new.specified');
        $test->assert_true ($a1-><AG::Attr.specified>);
        $test->id ('new.ownerElement');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

        $el-><M::Element.setAttributeNS> (null, 'a1', 'v2');
        $test->id ('changed.node');
        my $a2 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_equals ($a2, $a1);
        $test->id ('changed.value');
        $test->assert_equals ($a2-><AG::Attr.value>, 'v2');
    @@Test:
      @@@QName: Element.setAttributeNS.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $ns = 'about:';

        $el-><M::Element.setAttributeNS> ($ns, 'p:a1', 'v1');
        my $a1 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->id ('new.node');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->id ('new.namespaceURI');
        $test->assert_equals ($a1-><AG::Node.namespaceURI>, $ns);
        $test->id ('new.localName');
        $test->assert_equals ($a1-><AG::Node.localName>, 'a1');
        $test->id ('new.prefix');
        $test->assert_equals ($a1-><AG::Node.prefix>, 'p');
        $test->id ('new.value');
        $test->assert_equals ($a1-><AG::Attr.value>, 'v1');
        $test->id ('new.specified');
        $test->assert_true ($a1-><AG::Attr.specified>);
        $test->id ('new.ownerElement');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

        $el-><M::Element.setAttributeNS> ($ns, 'p:a1', 'v2');
        $test->id ('changed.node');
        my $a2 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_equals ($a2, $a1);
        $test->id ('changed.value');
        $test->assert_equals ($a2-><AG::Attr.value>, 'v2');

        $el-><M::Element.setAttributeNS> ($ns, 'q:a1', 'v3');
        $test->id ('changed2.node');
        my $a3 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_equals ($a3, $a1);
        $test->id ('changed2.value');
        $test->assert_equals ($a3-><AG::Attr.value>, 'v3');
        $test->id ('changed2.prefix');
        $test->assert_equals ($a3-><AG::Node.prefix>, 'q');
    @@Test:
      @@@QName: Element.setAttributeNS.3.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $ns = 'about:';

        $el-><M::Element.setAttributeNS> ($ns, ['p', 'a1'], 'v1');

        $test->assert_equals
                 ($el-><M::Element.getAttributeNS> ($ns, 'a1'), 'v1');
    @@Test:
      @@@QName: Element.setAttributeNS.dtdtype.1.test
      @@@enDesc:
        NS element, null-NS attribute, CDATA.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.declaredType> (<C::ATDef.CDATA_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> ('about:', 'et1');

        $el-><M::Element.setAttributeNS> (null, 'dattr1', ' attribute  value  ');
        my $attre = $el-><M::Element.getAttributeNodeNS> (null, 'dattr1');

        $test->id ('attributeType');
        $test->assert_num_equals
                 (actual_value => $attre-><AG::Attr.manakaiAttributeType>,
                  expected_value => <C::ATDef.CDATA_ATTR>);
    @@Test:
      @@@QName: Element.setAttributeNS.dtdtype.2.test
      @@@enDesc:
        NS element, null-NS attribute, IDREFS.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.declaredType> (<C::ATDef.IDREFS_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> ('about:', 'et1');

        $el-><M::Element.setAttributeNS> (null, 'dattr1', ' attribute  value  ');
        my $attre = $el-><M::Element.getAttributeNodeNS> (null, 'dattr1');

        $test->id ('attributeType');
        $test->assert_num_equals
                 (actual_value => $attre-><AG::Attr.manakaiAttributeType>,
                  expected_value => <C::ATDef.IDREFS_ATTR>);
    @@Test:
      @@@QName: Element.setAttributeNS.dtdtype.3.test
      @@@enDesc:
        NS element, NS attribute, NMTOKENS.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('html:class');
            $at-><AS::ATDef.declaredType> (<C::ATDef.NMTOKENS_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> ('about:', 'et1');
        $el-><M::Element.setAttributeNS> (<Q::xmlns:>, 'xmlns:html',
                                          'http://www.w3.org/1999/xhtml');

        $el-><M::Element.setAttributeNS> ('http://www.w3.org/1999/xhtml',
                                          'html:class', ' attribute  value  ');
        my $attre = $el-><M::Element.getAttributeNodeNS>
                           ('http://www.w3.org/1999/xhtml', 'class');

        $test->id ('attributeType');
        $test->assert_num_equals
                 (actual_value => $attre-><AG::Attr.manakaiAttributeType>,
                  expected_value => <C::ATDef.NMTOKENS_ATTR>);
    @@Test:
      @@@QName: Element.setAttributeNS.dtdtype.4.test
      @@@enDesc:
        NS element, <XA::xml:lang> attribute, NMTOKEN.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('xml:lang');
            $at-><AS::ATDef.declaredType> (<C::ATDef.NMTOKEN_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> ('about:', 'et1');

        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang', ' ja  ');
        my $attre = $el-><M::Element.getAttributeNodeNS> (<Q::xml:>, 'lang');

        $test->id ('attributeType');
        $test->assert_num_equals
                 (actual_value => $attre-><AG::Attr.manakaiAttributeType>,
                  expected_value => <C::ATDef.NMTOKEN_ATTR>);
    @@L3Test:
      @@@QName: Element.setAttributeNS.xmlid.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $cfg = $el-><AG::Node.ownerDocument>-><AG::Document.domConfig>;

        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);

        $test->id ('id.xmlid');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:id' => 'value');
        my $sti = $el-><M::Element.getAttributeNodeNS> (<Q::xml:>, 'id')
                     -><AG::Attr.schemaTypeInfo>;
        $test->assert_equals ($sti-><AG::c|TypeInfo.typeName>, 'ID');
        $test->assert_equals
                 ($sti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);

        $test->id ('id.other');
        $el-><M::Element.setAttributeNS> (null, 'id' => 'value');
        my $sti2 = $el-><M::Element.getAttributeNodeNS> (null, 'id')
                      -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti2-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti2-><AG::c|TypeInfo.typeNamespace>);

        my $el2 = $el-><AG::Node.ownerDocument>
                     -><M::Document.createElementNS> (null, 'e');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);

        $test->id ('noid.xmlid');
        $el2-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:id' => 'value');
        my $sti3 = $el2-><M::Element.getAttributeNodeNS> (<Q::xml:>, 'id')
                       -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti3-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti3-><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.other');
        $el2-><M::Element.setAttributeNS> (null, 'id' => 'value');
        my $sti4 = $el2-><M::Element.getAttributeNodeNS> (null, 'id')
                       -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti4-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti4-><AG::c|TypeInfo.typeNamespace>);

  @ResourceDef:
    @@QName: tc|setAttrValueNS
    @@rdf:type: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:
      my $__anode;
      __CODE{selectAttrNodeObjectNS::
        $namespaceURI => $namespaceURI,
        $localName => $localName,
        $self => $element,
        $r => $__anode,
      }__;
      if (defined $__anode) { ## There is already a node with such a |name|
        if ($__anode-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_ATTR::
            c|node => {$__anode},
          }__;
        }
        $__anode-><AS::Node.prefix> ($prefix) if defined $prefix;
          ## ISSUE: Should NULL be allowed here with |strictErrorChecking| off?
      } else { ## There is no such attribute
        __DEEP{
          $__anode = $ownerDocument-><M::Document.createAttributeNS>
                                      ($namespaceURI, [$prefix, $localName]);
          my $__attrs;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $__attrs,
            $prop => {<H::infoset|attributes>},
            $ref => $element,
          }__;
          $__attrs->{defined $namespaceURI ? $namespaceURI : ''}->{$localName}
              = <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $__anode>;
          __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
            $prop => {<H::infoset|ownerElement>},
            $ref => $__anode,
            $given => $element,
          }__;
        }__;
        __CODE{setAttribute.setSchemaTypeInfo::
          $element => $element,
          $attribute => $__anode,
          $attribute_name => {defined $prefix ? $prefix.':'.$localName
                                              : $localName},
          $ownerDocument => $ownerDocument,
        }__;
      }
      __DEEP{
        $__anode-><AS::Attr.value> (defined $value ? $value : '');
        $__anode-><AS::Attr.specified> (true);
      }__;

  @CODE:
    @@QName: setAttribute.setSchemaTypeInfo
    @@enDesc:
      Sets the <Q::infoset|attributeType> internal property 
      to the attribute node created in <M::Element.setAttribute>
      or similar methods or attributes.

      <Perl::$ownerDocument>: Owner document.

      <Perl::$element>: Element.

      <Perl::$attribute>: Attribute.

      <Perl::$attribute_name>: The name of the attribute.
    @@PerlDef:
      ## NOTE: The |cfg:xml-id| configuration parameter does not matter
      ##       since it can be typed in the |createAttribute| method.

      __DEEP{
        if ($ownerDocument-><AG::Document.domConfig>
                          -><M::c|DOMConfiguration.getParameter>
                              (<Q::cfg|dtd-attribute-type>)) {
          my $__st_doctype = $ownerDocument-><AG::Document.doctype>;
          $__st_doctype = $__st_doctype-><M::Node.getFeature>
                                           (<Q::fe|XDoctype> => '3.0')
            if defined $__st_doctype;
          if (defined $__st_doctype) {
            my $__st_et = $__st_doctype-><M::DTDef.getElementTypeDefinitionNode>
                                           ($element-><AG::Node.nodeName>);
            if (defined $__st_et) {
              my $__st_at = $__st_et-><M::ETDef.getAttributeDefinitionNode>
                                        ($attribute_name);
              if (defined $__st_at) {
                $attribute-><AS::Attr.manakaiAttributeType>
                              ($__st_at-><AG::ATDef.declaredType>);
              }
            }
          }
        }
      }__;

  @Method:
    @@Name: setAttributeNode
    @@enDesc:
      Adds a new attribute node.  If an attribute with that 
      <A::Node.nodeName> is already present in the element,
      it is replaced by the new one.

      Replacing an attribute node by itself has no effect.  <SRC::DOM3>

      In manakai, it is an alias of <M::Node.setAttributeNodeNS>.
    @@NSVersion:.setAttributeNodeNS
    @@Param:
      @@@Name: newAttr
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node to add to the attribute list.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        The replaced <IF::Attr> node.
      @@@nullCase:
        @@@@enDesc:
          If no existing attribute was replaced.
        @@@@enImplNote:
          Although the spec is unclear, when a node is <QUOTE::replaced>
          by itself, it is defined as <QUOTE::no effect>, no node
          is actually replaced and the manakai implementation does
          return <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If <P::newAttr> was created from a different document
          than the <A::Node.ownerDocument> of the element.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element is read-only.
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If the <P::newAttr> node is already used as an attribute
          of another <IF::Element> node.
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::arg> node is same as the attribute node that
          is attached to the element node.  Then, the method call is 
          no effect.
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $strict = $self_od-><AG::Document.strictErrorChecking>;
        if ($strict and
            not $self_od eq $newAttr-><AG::Node.ownerDocument>) {
          __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
            MDOMX|param-name => 'newAttr',
            c|node => {$newAttr},
          }__;
        }

        my $nsuri = $newAttr-><AG::Node.namespaceURI>;
        $nsuri = '' unless defined $nsuri;
        my $ln = $newAttr-><AG::Node.localName>;
        my $attrs;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $attrs,
          $prop => {<H::infoset|attributes>},
          $ref => $self,
        }__;
        my $current;
        if (defined $attrs->{$nsuri}->{$ln}) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$attrs->{$nsuri}->{$ln}},
            $ref => $current,
            $opt => {{
            }},
          }__;
        }

        if (defined $newAttr-><AG::Attr.ownerElement>) {
          if (defined $current and $current eq $newAttr) {
            __c:ERROR{t|replace-by-itself::
              c:relatedData => {$newAttr},
            }__;
            ## No return value
          } else {
            __EXCEPTION{c|INUSE_ATTRIBUTE_ERR::
              MDOMX|param-name => 'newAttr',
              c|node => {$newAttr},
            }__;
          }
        } else { # not in use
          if ($strict and $self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }

          $attrs->{$nsuri}->{$ln} = <Code::mg|getNodeID||ManakaiDOM|all::
                                               $ref = $newAttr>;
          __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
            $prop => {<H::infoset|ownerElement>},
            $ref => $newAttr,
            $given => $self,
          }__;
          $newAttr-><AS::Attr.specified> (true);

          if (defined $current) {
            __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
              $prop => {<H::infoset|ownerElement>},
              $ref => $current,
            }__;
            $r = $current;
          }
        }

    @@Test:
      @@@QName: Element.setAttributeNode.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $a1 = $doc-><M::Document.createAttribute> ('attr1');
        $a1-><AS::Attr.value> ('value1');

        $test->id ('set');
        my $r1 = $el-><M::Element.setAttributeNode> ($a1);

        $test->id ('no.replace.no.return');
        $test->assert_null ($r1);

        $test->id ('get.text');
        $test->assert_equals ($el-><M::Element.getAttribute> ('attr1'),
                              'value1');

        $test->id ('get.return.setten');
        my $r2 = $el-><M::Element.getAttributeNode> ('attr1');
        $test->assert_equals ($r2, $a1);

        $test->id ('owner');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

        $test->id ('specified');
        $test->assert_true ($a1-><AG::Attr.specified>);

        my $a2 = $doc-><M::Document.createAttribute> ('attr1');
        
        $test->id ('replace');
        my $r3 = $el-><M::Element.setAttributeNode> ($a2);
  
        $test->id ('replaced.node.returned');
        $test->assert_equals ($r3, $a1);

        $test->id ('replaced.no.owner');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);

    @@L3Test:
      @@@QName: Element.setAttributeNode.replace-by-itself.Test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           $del-><M::Element.setAttributeNS> (null, 'attr' => 'value');

           my $attr = $del-><M::Element.getAttributeNodeNS> (null, 'attr');

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|replace-by-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $attr);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><M::Element.setAttributeNode> ($attr);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><M::Element.getAttributeNodeNS>
                                   (null, 'attr'), $attr);

           $attr = null;

  @L2Method:
    @@Name: setAttributeNodeNS
    @@enDesc:
      Adds a new attribute.  If an attribute with that namespace URI
      and local name is already present in the element, it is
      replaced by the new one.

      Replacing an attribute node by itself has no effect.  <SRC::DOM3>
    @@NoNSVersion:.setAttributeNS
    @@XML2Feature:
    @@Param:
      @@@Name: newAttr
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node to add to the attribute list.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        The replaced <IF::Attr> node.
      @@@nullCase:
        @@@@enDesc:
          If there is no existing attribute.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newAttr> node was created from a different
          document than the one that created the element.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If the <P::newAttr> node is already an attribute of 
          another <IF::Element>.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_NODE_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the <P::newAttr> node does not support XML namespaces.
          <SRC::manakai>.
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::newAttr> node is same as the node already attached
          to the element.  Then, the method is no effect.
      @@@disDef:
        @@@@DISPerl:cloneCode: .setAttributeNode

    @@Test:
      @@@QName: Element.setAttributeNodeNS.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $a1 = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $a1-><AS::Attr.value> ('v1');

        $el-><M::Element.setAttributeNodeNS> ($a1);

        $test->id ('value');
        $test->assert_equals ($el-><M::Element.getAttributeNS> (null, 'a1'),
                              'v1');
        $test->id ('specified');
        $test->assert_true ($a1-><AG::Attr.specified>);
        $test->id ('ownerElement');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

  @Method:
    @@Name: removeAttribute
    @@enDesc:
      Removes an attribute by name.

      If a default value for the removed attribute is defined
      in the DTD, a new attribute immediately appears with
      the default value as well as corresponding namespace URI,
      local name, and prefix when applicable.  The implementation
      may handle default values from other schemas similarly
      but applications should use the <M::Document.normalizeDocument>
      method to guarantee this information is up-to-date.

      If no attribute with the name is found, this method has no effect.
    @@NSVersion:.removeAttributeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name of the attribute to remove.
    @@Return:
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the <IF::Element> node is read-only.
      @@@PerlDef:
        my $list;
        my $key;
        my $attr;
        __CODE{selectAttrNodeObjectForRemove::
          $self => $self,
          $name => $name,
          $list => $list,
          $key => $key,
          $r => $attr,
        }__;
        if (defined $attr) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }

          ## Remove the attribute node
          CORE::delete $list->{$key};
          __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
            $prop => {<H::infoset|ownerElement>},
            $ref => $attr,
          }__;

          ## Default attribute
          my $doc = $self-><AG::Node.ownerDocument>;
          my $doc_cfg = $doc-><AG::Document.domConfig>;
          if ($doc_cfg-><M::c|DOMConfiguration.getParameter>
                          (<Q::cfg|dtd-default-attribute>)) {
            my $prefix;
            __CODE{tc|generateDefaultAttribute::
              $document => $doc,
              $element_type => {$self-><AG::Node.nodeName>},
              $element => $self,
              $name => $name,
              $prefix => $prefix, $localName => $name,
              $cfg => $doc_cfg,
            }__;
          }
        } # exists

    @@Test:
      @@@QName: Element.removeAttribute.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> (at1 => 'value1');
        my $v1 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('at1');
        my $v2 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
    @@Test:
      @@@QName: Element.removeAttribute.nsattr.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('ns1:at1');

        $test->id ('set.attr.ns');
        $el-><M::Element.setAttributeNS>
               ('http://example./', 'ns1:at1' => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('ns1:at1');
        my $v2 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        undef $v2 if defined $v2 and $v2 eq '';
        $test->assert_null ($v2);
    @@L3Test:
      @@@QName: Element.removeAttribute.defaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElement> ('et1');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> ('dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNode> ('dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('dattr1');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);
    @@L3Test:
      @@@QName: Element.removeAttribute.defaultattr.disabled.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|dtd-default-attribute> => false);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElement> ('et1');
        $test->assert_null ($el-><M::Element.getAttribute> ('dattr1'));

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> ('dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNode> ('dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('dattr1');
        $test->assert_null ($el-><M::Element.getAttribute> ('dattr1'));
    @@Test:
      @@@QName: Element.removeAttribute.ro.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttribute> (a => 'b');
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('remove');
        $test->assert_exception (code => sub {
          $el-><M::Element.removeAttribute> ('a');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('has');
        $test->assert_true ($el-><M::Element.hasAttribute> ('a'));
    @@Test:
      @@@QName: Element.removeAttribute.not.found.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.removeAttribute> ('no.such.attribute');
        
        $test->assert_false ($el-><M::Element.hasAttribute>
                                    ('no.such.attribute'));

  @L2Method:
    @@Name: removeAttributeNS
    @@enDesc:
      Removes an attribute by namespace URI and local name.

      If a default value for the removed attribute is defined in
      the DTD, a new attribute immediately apperas with
      the default value as well as the corresponding namespace URI,
      local name, and prefix when applicable.  The implementation
      may handle default values from other schemas similarly but
      applications should use the <M::Document.normalizeDocument>
      method to guarantee this information is up-to-date.

      If no attribute with the namespace URI and local name is
      found, this method has no effect.
    @@NoNSVersion: .removeAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to remove.
      @@@nullCase:
        @@@@enDesc:
          If the attribute has no namespace.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLLocalName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The local name of the attribute to remove.
    @@Return:
      @@@NodeReadOnlyError:
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        my $list;
        my $attr;
        __CODE{selectAttrNodeObjectForRemoveNS::
          $self => $self,
          $namespaceURI => $namespaceURI,
          $localName => $localName,
          $list => $list,
          $r => $attr,
        }__;
        if (defined $attr) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }
         
          ## Removes the attribute node
          CORE::delete $list->{$localName};
          __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
            $prop => {<H::infoset|ownerElement>},
            $ref => $attr,
          }__;

          ## Default attribute
          my $doc = $self-><AG::Node.ownerDocument>;
          my $doc_cfg = $doc-><AG::Document.domConfig>;
          if ($doc_cfg-><M::c|DOMConfiguration.getParameter>
                          (<Q::cfg|dtd-default-attribute>)) {
            my $pfx = $attr-><AG::Node.prefix>;
            my $name = defined $pfx ? $pfx.':'.$localName : $localName;
            __CODE{tc|generateDefaultAttribute::
              $document => $doc,
              $element_type => {$self-><AG::Node.nodeName>},
              $element => $self,
              $name => $name,
              $prefix => $pfx, $localName => $localName,
              $cfg => $doc_cfg,
            }__;
          }
        } # exists

    @@Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Element.removeAttributeNS.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttributeNS> (null, 'at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS> (null, at1 => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> (null, 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> (null, 'at1');
        my $v2 = $el-><M::Element.getAttributeNS> (null, 'at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
    @@Test:
      @@@QName: Element.removeAttributeNS.global.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $uri = 'http://example.com/';
        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS> ($uri, at1 => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> ($uri, 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'at1');
        my $v2 = $el-><M::Element.getAttributeNS> ($uri, 'at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
    @@L3Test:
      @@@QName: Element.removeAttributeNS.defaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $uri = 'http://www.example.com/';
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('ns1:dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
            my $at2 = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('xmlns:ns1');
            $at2-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at2-><AS::Node.textContent> ($uri);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at2);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElementNS> ($uri, 'et1');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNodeNS>
                                    ($uri, 'dattr1')
                                -><AG::Attr.specified>);

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS>
               ($uri, 'ns1:dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNodeNS> ($uri, 'dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'dattr1');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNodeNS>
                                    ($uri, 'dattr1')
                                -><AG::Attr.specified>);
    @@L3Test:
      @@@QName: Element.removeAttributeNS.defaultattr.disabled.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $uri = 'http://www.example.com/';
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('ns1:dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
            my $at2 = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('xmlns:ns1');
            $at2-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at2-><AS::Node.textContent> ($uri);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at2);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|dtd-default-attribute> => false);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElementNS> ($uri, 'et1');
        $test->assert_null ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'));

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS>
               ($uri, 'ns1:dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNodeNS> ($uri, 'dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'dattr1');
        $test->assert_null ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'));
    @@Test:
      @@@QName: Element.removeAttributeNS.not.found.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.removeAttributeNS> (null, 'no.such.attribute');
        
        $test->assert_false ($el-><M::Element.hasAttributeNS>
                                    (null, 'no.such.attribute'));
    @@Test:
      @@@QName: Element.removeAttributeNS.not.found.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.removeAttributeNS> ('about:', 'no.such.attribute');
        
        $test->assert_false ($el-><M::Element.hasAttributeNS>
                                    ('about:', 'no.such.attribute'));

  @Method:
    @@Name: removeAttributeNode
    @@enDesc:
      Removes the specified attribute node.

      If a default value for the removed attribute is defined
      in the DTD, a new node immediately appears with the 
      default value as well as the corresponding namespace URI,
      local name, and prefix when applicable.  The implementation
      may handle default values from other schemas similarly but
      applications should use the <M::Document.normalizeDocument>
      method to guarantee this information is up-to-date.
    @@Param:
      @@@Name: oldAttr
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node to remove from the attribute list.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node that was removed.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element node is read-only.
      @@@dx:raises:
        @@@@@: c|NOT_ATTR_ERR
        @@@@enDesc:
          If the <P::oldAttr> node is not an attribute of the element.
      @@@PerlDef:
        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking> and
            $self-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_THIS::
          }__;
        }

        my $ln = $oldAttr-><AG::Node.localName>;
        FIND: {
          my $attrs;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $attrs,
            $prop => {<H::infoset|attributes>},
            $ref => $self,
          }__;
          my $nsuri = $oldAttr-><AG::Node.namespaceURI>;
          my $list = $attrs->{defined $nsuri ? $nsuri : ''};
          my $list_nid = $list->{$ln};
          if (defined $list_nid and
              <Code::mg|nodeIDMatch||ManakaiDOM|all::
                        $noderef = $oldAttr,
                        $nodeid = $list_nid>) {
            CORE::delete $list->{$ln};
            last FIND;
          }
          __EXCEPTION{c|NOT_ATTR_ERR::
            MDOMX|param-name => 'oldAttr',
            c|node => {$oldAttr},
          }__;
        } # FIND

        __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
          $prop => {<H::infoset|ownerElement>},
          $ref => $oldAttr,
        }__;
        $r = $oldAttr;
      
        ## Default attribute
        my $doc_cfg = $od-><AG::Document.domConfig>;
        if ($doc_cfg-><M::c|DOMConfiguration.getParameter>
                        (<Q::cfg|dtd-default-attribute>)) {
          my $name = $oldAttr-><AG::Node.nodeName>;
          my $pfx = $oldAttr-><AG::Node.prefix>;
          __CODE{tc|generateDefaultAttribute::
            $document => $od,
            $element_type => {$self-><AG::Node.nodeName>},
            $element => $self,
            $name => $name,
            $prefix => $pfx, $localName => $ln,
            $cfg => $doc_cfg,
          }__;
        }

    @@Test:
      @@@QName: Element.removeAttributeNode.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> (at1 => 'value1');
        my $v1 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('at1');
        $el-><M::Element.removeAttributeNode> ($a1);
        my $v2 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);
    @@L2Test:
      @@@QName: Element.removeAttributeNode.nsattr.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('ns1:at1');

        $test->id ('set.attr.ns');
        $el-><M::Element.setAttributeNS>
               ('http://example./', 'ns1:at1' => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('ns1:at1');
        $el-><M::Element.removeAttributeNode> ($a1);
        my $v2 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);
    @@L3Test:
      @@@QName: Element.removeAttributeNode.defaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElement> ('et1');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> ('dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNode> ('dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('dattr1');
        $el-><M::Element.removeAttributeNode> ($a1);
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);
        $test->assert_null ($a1-><AG::Attr.ownerElement>);
    @@L3Test:
      @@@QName: Element.removeAttributeNode.defaultattr.disabled.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|dtd-default-attribute> => false);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElement> ('et1');
        $test->assert_null ($el-><M::Element.getAttribute> ('dattr1'));

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> ('dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNode> ('dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('dattr1');
        $el-><M::Element.removeAttributeNode> ($a1);
        $test->assert_null ($el-><M::Element.getAttribute> ('dattr1'));
        $test->id ('removed.attr.ownerElement');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);

  @CODE:
    @@QName: tc|generateDefaultAttribute
    @@enDesc:
      <Perl::$cfg>: DOM configuration object of the <Perl::$document>.
    @@PerlDef:
      __DEEP{
        my $__doctype = $document-><AG::Document.doctype>;
        $__doctype = $__doctype-><M::Node.getFeature> (<Q::fe|XDoctype>)
          if $__doctype;
        if (defined $__doctype) {
          my $__et = $__doctype-><M::DTDef.getElementTypeDefinitionNode>
                                   ($element_type);
          if (defined $__et) {
            my $__orig_strict = $document-><AG::Document.strictErrorChecking>;
            $document-><AS::Document.strictErrorChecking> (false);

            my $__at = $__et-><M::ETDef.getAttributeDefinitionNode> ($name);
            if (defined $__at) {
              my $__copy_asis = $cfg-><M::c|DOMConfiguration.getParameter>
                                     (<Q::cfg|clone-entity-reference-subtree>);
              $cfg-><M::c|DOMConfiguration.setParameter>
                        (<Q::cfg|clone-entity-reference-subtree> => true);
              ADD: {
                my $__attr;
                my $__attrs;
                __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
                  $r => $__attrs,
                  $prop => {<H::infoset|attributes>},
                  $ref => $element,
                }__;
                if (defined $prefix) {   ## prefixed attr
                  my $__nsuri = $element-><M::Node.lookupNamespaceURI>
                                            ($prefix);
                  unless (defined $__nsuri) {
                    ## TODO: Namespace well-formedness error
                  }
                  if (defined $__attrs->{defined $__nsuri ? $__nsuri : ''}
                                      ->{$localName}) {
                    ## TODO: Namespace well-formedness warning?
                    last ADD;
                  }
                  $__attr = $document-><M::Document.createAttributeNS>
                                         ($__nsuri, [$prefix, $localName]);
                } else {                ## local attr
                  if ($name eq 'xmlns') {
                    if (defined $__attrs->{<Q::xmlns:>}->{xmlns}) {
                      ## TODO: Namespace well-formedness warning?
                      last ADD;
                    }
                    $__attr = $document-><M::Document.createAttributeNS>
                                           (<Q::xmlns:>, 'xmlns');
                  } else {
                    if (defined $__attrs->{''}->{$name}) {
                      ## TODO: Namespace well-formedness warning?
                      last ADD;
                    }
                    $__attr = $document-><M::Document.createAttribute> ($name);
                  }
                }
                for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                  $__attr-><M::Node.appendChild>
                             ($__at_child-><M::Node.cloneNode> (true));
                }
                $__attr-><AS::Attr.manakaiAttributeType>
                           ($__at-><AG::ATDef.declaredType>);
                $element-><M::Element.setAttributeNodeNS> ($__attr);
                              ## This method change the |specified| flag
                $__attr-><AS::Attr.specified> (false);
              } # ADD
              $cfg-><M::c|DOMConfiguration.setParameter>
                     (<Q::cfg|clone-entity-reference-subtree> => $__copy_asis);
            }
            $document-><AS::Document.strictErrorChecking> ($__orig_strict);
          } # et
        } # doctype
      }__;
    @@enImplNote:
      {ISSUE::
        Given <XA::ns1:ln> attribute has a default value <CODE::value>
        and there is a <A::Attr.specified> attribute node <VAR::a1>
        whose <A::Node.prefix> is <XML::ns1> and <A::Node.localName>
        is <XML::ln>.  Then, <VAR::a1>'s <A::Node.prefix> is 
        so modified that its value is now <XML::ns2>.  At this
        time no default attribute is added <SRC::DOM Level 3 Core>.

        Now we remove the <VAR::a1> node from its owner element.
        Should the operation make a default attribute with
        its <A::Node.nodeName> <XA::ns1:ln> be created?
        
        To do it, because of DTD's namespace unawareness, 
        we must test any possible default attribute if
        its local name matches to the removed attribute's local name,
        i.e. <XML::ln>, and looking up its prefix by the
        former owner element of the removed attribute and
        it matches to the namespace URI of the removed attribute.
      }

  @L3Attr:
    @@Name: schemaTypeInfo
    @@enDesc:
      The type information associated with the element.
    @@enImplNote:
      Currently manakai does not support XML Schema, so it is 
      always a no-type <IF::c|TypeInfo>.  It is expected that
      a future version of the implementation will return an
      element type definition node that also implement the
      <IF::c|TypeInfo> interface when the schema language is XML DTD.
    @@Type: c|TypeInfo
    @@Get:
      @@@PerlDef:
        __CODE{c|createDTDTypeInfo::
          $result => $r,
          $type => {0},
        }__;
    @@L3Test:
      @@@QName: Element.schemaTypeInfo.no-schema.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => q[http://dummy.example/]);

        my $sti = $el-><AG::Element.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);
    @@L3Test:
      @@@QName: Element.schemaTypeInfo.dtd.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => <Q::xml-dtd:>);

        my $sti = $el-><AG::Element.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);

  @Method:
    @@Name: getElementsByTagName
    @@enDesc:
      Returns a <IF::NodeList> of all descendant <IF::Element>s
      with a given tag name, in the order in which they are
      encountered in a preorder traversal of the <IF::Element> tree.
    @@NSVersion: .getElementsByTagNameNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the tag to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all tags.
    @@Return:
      @@@Type: NodeList
      @@@enDesc:
        A live list of matching <IF::Element> nodes.
      @@@PerlDef:
        $name = "$name";
        my $chk;
        if ($name eq '*') {
          $chk = sub { true };
        } else {
          $chk = sub {
            my $node = shift;
            my $nodeName = $node-><AG::Node.nodeName>;
            ($nodeName eq $name);
          };
        }
        __CODE{tc|createGetElementsNodeList::
          $node => $self, $chk => $chk, $r => $r,
        }__;

    @@Test:
      @@@QName: Element.getElementsByTagName.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('nodelist');
        my $nl = $el-><M::Element.getElementsByTagName> ('target');
        $test->assert_isa ($nl, <IFName::NodeList>);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 0);

        $test->id ('item.0');
        $test->assert_null ($nl-><M::NodeList.item> (0));

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        my $t1 = $doc-><M::Document.createElement> ('target');
        my $t2 = $doc-><M::Document.createElement> ('target');
        my $t3 = $doc-><M::Document.createElementNS> (null, 'target');
        my $d1 = $doc-><M::Document.createElementNS> ('about:', 'a:target');
        my $d2 = $doc-><M::Document.createElement> ('not-target');
        $el-><M::Node.appendChild> ($t1);
        $el-><M::Node.appendChild> ($d1);
        $el-><M::Node.appendChild> ($d2);
        $d2-><M::Node.appendChild> ($t2);
        $el-><M::Node.appendChild> ($t3);

        $test->id ('length.3');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 3);

        $test->id ('t1');
        $test->assert_equals ($nl-><M::NodeList.item> (0), $t1);

        $test->id ('t2');
        $test->assert_equals ($nl-><M::NodeList.item> (1), $t2);

        $test->id ('t3');
        $test->assert_equals ($nl-><M::NodeList.item> (2), $t3);

        $test->id ('item.3');
        $test->assert_null ($nl-><M::NodeList.item> (3));

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));
    @@Test:
      @@@QName: Element.getElementsByTagName.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('nodelist');
        my $nl = $el-><M::Element.getElementsByTagName> ('a:target');
        $test->assert_isa ($nl, <IFName::NodeList>);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 0);

        $test->id ('item.0');
        $test->assert_null ($nl-><M::NodeList.item> (0));

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        my $t1 = $doc-><M::Document.createElement> ('a:target');
        my $t2 = $doc-><M::Document.createElementNS> ('mocha:', 'a:target');
        my $t3 = $doc-><M::Document.createElementNS> ('about:', 'a:target');
        my $d1 = $doc-><M::Document.createElementNS> ('about:', 'target');
        my $d2 = $doc-><M::Document.createElement> ('not-target');
        $el-><M::Node.appendChild> ($t1);
        $el-><M::Node.appendChild> ($d1);
        $el-><M::Node.appendChild> ($d2);
        $d2-><M::Node.appendChild> ($t2);
        $el-><M::Node.appendChild> ($t3);

        $test->id ('length.3');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 3);

        $test->id ('t1');
        $test->assert_equals ($nl-><M::NodeList.item> (0), $t1);

        $test->id ('t2');
        $test->assert_equals ($nl-><M::NodeList.item> (1), $t2);

        $test->id ('t3');
        $test->assert_equals ($nl-><M::NodeList.item> (2), $t3);

        $test->id ('item.3');
        $test->assert_null ($nl-><M::NodeList.item> (3));

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

  @L2Method:
    @@Name: getElementsByTagNameNS
    @@enDesc:
      Returns a <IF::NodeList> of all the descendant <IF::Element>s
      with a given namespace URI and local name in document order.
    @@NoNSVersion: .getElementsByTagName
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the elements to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all namespaces.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLLocalName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The local name of the elements to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all local names.
    @@Return:
      @@@Type: NodeList
      @@@enDesc:
        A new <IF::NodeList> object containing all the matched 
        <IF::Element>s.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature;;XML> and the language exposed through the 
          <IF::Document> does not support XML namespaces.
      @@@PerlDef:
        $namespaceURI = "$namespaceURI" if defined $namespaceURI;
        $localName = "$localName";
        my $chk;
        if (not defined $namespaceURI) {
          if ($localName eq '*') {
            $chk = sub {
              my $node = shift;
              (not defined $node-><AG::Node.namespaceURI>);
            };
          } else {
            $chk = sub {
              my $node = shift;
              (not defined $node-><AG::Node.namespaceURI> and
               $node-><AG::Node.localName> eq $localName);
            };
          }
        } elsif ($namespaceURI eq '*') {
          if ($localName eq '*') {
            $chk = sub { true };
          } else {
            $chk = sub {
              my $node = shift;
              ($node-><AG::Node.localName> eq $localName);
            };
          }
        } else {
          if ($localName eq '*') {
            $chk = sub {
              my $node = shift;
              my $nsuri = $node-><AG::Node.namespaceURI>;
              (defined $nsuri and $nsuri eq $namespaceURI);
            };
          } else {
            $chk = sub {
              my $node = shift;
              my $nsuri = $node-><AG::Node.namespaceURI>;
              (defined $nsuri and $nsuri eq $namespaceURI and
               $node-><AG::Node.localName> eq $localName);
            };
          }
        }
        __CODE{tc|createGetElementsNodeList::
          $node => $self, $chk => $chk, $r => $r,
        }__;

    @@Test:
      @@@QName: Element.getElementsByTagNameNS.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('nodelist');
        my $nl = $el-><M::Element.getElementsByTagNameNS>
                        (null, 'target');
        $test->assert_isa ($nl, <IFName::NodeList>);

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 0);

        $test->id ('item.-1.1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        $test->id ('item.0.1');
        $test->assert_null ($nl-><M::NodeList.item> (0));

        my $t1 = $doc-><M::Document.createElement> ('target');
        my $t2 = $doc-><M::Document.createElementNS> (null, 'target');
        my $t3 = $doc-><M::Document.createElementNS> (null, 'target');
        my $d1 = $doc-><M::Document.createElementNS> ('about:', 'target');
        my $d2 = $doc-><M::Document.createElementNS> ('about:', 'a:target');
        $el-><M::Node.appendChild> ($t1);
        $el-><M::Node.appendChild> ($d1);
        $d1-><M::Node.appendChild> ($t2);
        $el-><M::Node.appendChild> ($d2);
        $el-><M::Node.appendChild> ($t3);

        $test->id ('length.3');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 3);

        $test->id ('item.0');
        $test->assert_equals ($nl-><M::NodeList.item> (0), $t1);

        $test->id ('item.1');
        $test->assert_equals ($nl-><M::NodeList.item> (1), $t2);

        $test->id ('item.2');
        $test->assert_equals ($nl-><M::NodeList.item> (2), $t3);

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        $test->id ('item.3');
        $test->assert_null ($nl-><M::NodeList.item> (3));
    @@Test:
      @@@QName: Element.getElementsByTagNameNS.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('nodelist');
        my $nl = $el-><M::Element.getElementsByTagNameNS>
                        ('about:', 'target');
        $test->assert_isa ($nl, <IFName::NodeList>);

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 0);

        $test->id ('item.-1.1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        $test->id ('item.0.1');
        $test->assert_null ($nl-><M::NodeList.item> (0));

        my $t1 = $doc-><M::Document.createElementNS> ('about:', 'target');
        my $t2 = $doc-><M::Document.createElementNS> ('about:', 'target');
        my $t3 = $doc-><M::Document.createElementNS> ('about:', 'a:target');
        my $d1 = $doc-><M::Document.createElementNS> ('about:a', 'target');
        my $d2 = $doc-><M::Document.createElementNS> ('about:b', 'a:target');
        $el-><M::Node.appendChild> ($t1);
        $el-><M::Node.appendChild> ($d1);
        $d1-><M::Node.appendChild> ($t2);
        $el-><M::Node.appendChild> ($d2);
        $el-><M::Node.appendChild> ($t3);

        $test->id ('length.3');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 3);

        $test->id ('item.0');
        $test->assert_equals ($nl-><M::NodeList.item> (0), $t1);

        $test->id ('item.1');
        $test->assert_equals ($nl-><M::NodeList.item> (1), $t2);

        $test->id ('item.2');
        $test->assert_equals ($nl-><M::NodeList.item> (2), $t3);

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        $test->id ('item.3');
        $test->assert_null ($nl-><M::NodeList.item> (3));

  @LXAttr:
    @@Name: manakaiBaseURI
    @@enDesc:
      The base URI of the element.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        The base DOM URI of the element, if it is explicitly set
        to the element.

          {NOTE::
            This attribute is similar to the <InfoProp::base URI>
            property for element information items in the XML
            Information Set.
          }

          {NOTE::
            To obtain the computed base URI of the element,
            use the <A::Node.baseURI> attribute.
          }
      @@@nullCase:
        @@@@enDesc:
          If no explicit base DOM URI is available.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|baseURI>},
          $ref => $self,
        }__;
    @@Set:
      @@@enDesc:
        Sets the base DOM URI of the element.  It <kwd:MUST> be an
        absolute DOM URI; however, no lexical checking is performed
        on setting.  It is similar to the <InfoProp::base URI>
        property in the XML Information Set and setting the attribute
        value does not affect on the <XA::xml:base> attribute.
      @@@nullCase:
        @@@@enDesc:
          The base DOM URI explicitly set to the element node, if any,
          is removed.  Note that <XA::xml:base> attribute or any
          other base DOM URI sources attached to other nodes are
          not affected by setting the attribute value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|baseURI>},
          $ref => $self,
        }__;

  @L3Method:
    @@Name: setIdAttribute
    @@enDesc:
      Declares the specified attribute to be a user-determined
      ID attribute.

      This affect the value of the <A::Attr.isId> attribute of
      the specified attribute, but does not change any
      schema that may be in use, in particular this
      does not affect the <A::Attr.schemaTypeInfo> attribute
      of the specified attribute.
    @@NSVersion:.setIdAttributeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the attribute.
    @@Param:
      @@@Name: isId
      @@@Type: boolean
      @@@enDesc:
        Whether the attribute is of type ID.
      @@@TrueCase:
        @@@@enDesc:
          Declares the specified attribute to be a 
          user-determined ID attribute.
      @@@FalseCase:
        @@@@enDesc:
          Undeclares the specified attribute for being
          a user-determined ID attribute.
    @@Return:
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_ATTR
        @@@@enDesc:
          If the attribute node is read-only.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: c|NO_NAMED_NODE_NS_ERR
        @@@@enDesc:
          If there is no such attribute.
        @@@@enImplNote:
          {SpecIssue:: Spec is incorrect.
          }
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        my $attr = $self-><M::Element.getAttributeNode> ($name);
        if (not defined $attr) {
          __EXCEPTION{c|NO_NAMED_NODE_NS_ERR::
            MDOMX|param-name => 'name',
            infoset|namespaceName => {null},
            infoset|localName => {$name},
          }__;
        } elsif ($attr-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_ATTR::
            MDOMX|param-name => 'name',
            c|node => {$attr},
          }__;
        } else {
          $attr-><AS::Attr.isId> ($isId);
        }

    @@Test:
      @@@QName: Element.setIdAttribute.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttribute> ('a', 'id');

        my $attr = $el-><M::Element.getAttributeNode> ('a');

        $test->id ('default');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $test->id ('set.true');
        $el-><M::Element.setIdAttribute> ('a', true);
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.false');
        $el-><M::Element.setIdAttribute> ('a', false);
        $test->assert_false ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Element.setIdAttribute.element.read-only.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttribute> ('a', 'id');

        my $attr = $el-><M::Element.getAttributeNode> ('a');
        $el-><M::Node.manakaiSetReadOnly> (true, false);

        $test->id ('set.true.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttribute> ('a', true);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->id ('set.true.value');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $attr-><AS::Attr.isId> (true);

        $test->id ('set.false.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttribute> ('a', false);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->id ('set.false.value');
        $test->assert_true ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Element.setIdAttribute.attr.read-only.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttribute> ('a', 'id');

        my $attr = $el-><M::Element.getAttributeNode> ('a');
        $attr-><M::Node.manakaiSetReadOnly> (true, false);

        $test->id ('set.true.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttribute> ('a', true);
        }, exception_subtype => <Q::MDOMX|NOMOD_ATTR>);
        $test->id ('set.true.value');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $attr-><M::Node.manakaiSetReadOnly> (false, false);
        $attr-><AS::Attr.isId> (true);
        $attr-><M::Node.manakaiSetReadOnly> (true, false);

        $test->id ('set.false.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttribute> ('a', false);
        }, exception_subtype => <Q::MDOMX|NOMOD_ATTR>);
        $test->id ('set.false.value');
        $test->assert_true ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Element.setIdAttribute.not.found.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('true.not.found.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttribute> ('a', true);
        }, exception_subtype => <Q::c|NO_NAMED_NODE_NS_ERR>);

        $test->id ('false.not.found.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttribute> ('a', false);
        }, exception_subtype => <Q::c|NO_NAMED_NODE_NS_ERR>);

  @L3Method:
    @@Name: setIdAttributeNS
    @@enDesc:
      Declares the specified attribute to be a user-determined
      ID attribute.

      This affect the value of the <A::Attr.isId> attribute of
      the specified attribute, but does not change any
      schema that may be in use, in particular this
      does not affect the <A::Attr.schemaTypeInfo> attribute
      of the specified attribute.
    @@NoNSVersion: .setIdAttribute
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute.
      @@@nullCase:
        @@@@enDesc:
          If the attribute does not have namespace.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the attribute.
    @@Param:
      @@@Name: isId
      @@@Type: boolean
      @@@enDesc:
        Whether the attribute is of type ID.
      @@@TrueCase:
        @@@@enDesc:
          Declares the specified attribute to be a 
          user-determined ID attribute.
      @@@FalseCase:
        @@@@enDesc:
          Undeclares the specified attribute for being
          a user-determined ID attribute.
    @@Return:
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_ATTR
        @@@@enDesc:
          If the attribute node is read-only.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: c|NO_NAMED_NODE_NS_ERR
        @@@@enDesc:
          If there is no such attribute.
        @@@@enImplNote:
          {SpecIssue:: Spec is incorrect.
          }
      @@@enImplNote:
        {SpecIssue::
          No <C::c|DOMException.NOT_SUPPORTED_ERR> for non-XML implementations.
        }
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        my $attr = $self-><M::Element.getAttributeNodeNS>
                            ($namespaceURI, $localName);
        if (not defined $attr) {
          __EXCEPTION{c|NO_NAMED_NODE_NS_ERR::
            MDOMX|param-name => 'name',
            infoset|namespaceName => {$namespaceURI},
            infoset|localName => {$localName},
          }__;
        } elsif ($attr-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_ATTR::
            MDOMX|param-name => 'name',
            c|node => {$attr},
          }__;
        } else {
          $attr-><AS::Attr.isId> ($isId);
        }

    @@Test:
      @@@QName: Element.setIdAttributeNS.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttributeNS> ('about:', 'a:a', 'id');

        my $attr = $el-><M::Element.getAttributeNodeNS> ('about:', 'a');

        $test->id ('default');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $test->id ('set.true');
        $el-><M::Element.setIdAttributeNS> ('about:', 'a', true);
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.false');
        $el-><M::Element.setIdAttributeNS> ('about:', 'a', false);
        $test->assert_false ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Element.setIdAttributeNS.element.read-only.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttributeNS> ('about:', 'a:a', 'id');

        my $attr = $el-><M::Element.getAttributeNodeNS> ('about:', 'a');
        $el-><M::Node.manakaiSetReadOnly> (true, false);

        $test->id ('set.true.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNS> ('about:', 'a', true);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->id ('set.true.value');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $attr-><AS::Attr.isId> (true);

        $test->id ('set.false.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNS> ('about:', 'a', false);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->id ('set.false.value');
        $test->assert_true ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Element.setIdAttributeNS.attr.read-only.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttributeNS> ('about:', 'a:a', 'id');

        my $attr = $el-><M::Element.getAttributeNodeNS> ('about:', 'a');
        $attr-><M::Node.manakaiSetReadOnly> (true, false);

        $test->id ('set.true.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNS> ('about:', 'a', true);
        }, exception_subtype => <Q::MDOMX|NOMOD_ATTR>);
        $test->id ('set.true.value');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $attr-><M::Node.manakaiSetReadOnly> (false, false);
        $attr-><AS::Attr.isId> (true);
        $attr-><M::Node.manakaiSetReadOnly> (true, false);

        $test->id ('set.false.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNS> ('about:', 'a', false);
        }, exception_subtype => <Q::MDOMX|NOMOD_ATTR>);
        $test->id ('set.false.value');
        $test->assert_true ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Element.setIdAttributeNS.not.found.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('true.not.found.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNS> ('about:', 'a', true);
        }, exception_subtype => <Q::c|NO_NAMED_NODE_NS_ERR>);

        $test->id ('false.not.found.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNS> ('about:', 'a', false);
        }, exception_subtype => <Q::c|NO_NAMED_NODE_NS_ERR>);

  @L3Method:
    @@Name: setIdAttributeNode
    @@enDesc:
      Declares the specified attribute to be a user-determined
      ID attribute.

      This affect the value of the <A::Attr.isId> attribute of
      the specified attribute, but does not change any
      schema that may be in use, in particular this
      does not affect the <A::Attr.schemaTypeInfo> attribute
      of the specified attribute.
    @@Param:
      @@@Name: idAttr
      @@@Type: Attr
      @@@enDesc:
        The attribute node.
    @@Param:
      @@@Name: isId
      @@@Type: boolean
      @@@enDesc:
        Whether the attribute is of type ID.
      @@@TrueCase:
        @@@@enDesc:
          Declares the specified attribute to be a 
          user-determined ID attribute.
      @@@FalseCase:
        @@@@enDesc:
          Undeclares the specified attribute for being
          a user-determined ID attribute.
    @@Return:
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_ATTR
        @@@@enDesc:
          If the attribute node is read-only.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: c|NOT_ATTR_ERR
        @@@@enDesc:
          If the specified node is not an attribute of the element.
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;

        my $owner = $idAttr-><AG::Attr.ownerElement>;
        if (not defined $owner or not $owner eq $self) {
          __EXCEPTION{c|NOT_ATTR_ERR::
            MDOMX|param-name => 'idAttr',
            c|node => {$idAttr},
          }__;
        } elsif ($idAttr-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_ATTR::
            MDOMX|param-name => 'name',
            c|node => {$idAttr},
          }__;
        } else {
          $idAttr-><AS::Attr.isId> ($isId);
        }

    @@Test:
      @@@QName: Element.setIdAttributeNode.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $attr = $el-><AG::Node.ownerDocument>
                      -><M::Document.createAttribute> ('a');

        $el-><M::Element.setAttributeNode> ($attr);

        $test->id ('default');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $test->id ('set.true');
        $el-><M::Element.setIdAttributeNode> ($attr, true);
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.false');
        $el-><M::Element.setIdAttributeNode> ($attr, false);
        $test->assert_false ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Element.setIdAttributeNode.element.read-only.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $attr = $el-><AG::Node.ownerDocument>
                      -><M::Document.createAttribute> ('a');

        $el-><M::Element.setAttributeNode> ($attr);
        $el-><M::Node.manakaiSetReadOnly> (true, false);

        $test->id ('set.true.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNode> ($attr, true);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->id ('set.true.value');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $attr-><AS::Attr.isId> (true);

        $test->id ('set.false.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNode> ($attr, false);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->id ('set.false.value');
        $test->assert_true ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Element.setIdAttributeNode.attr.read-only.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $attr = $el-><AG::Node.ownerDocument>
                      -><M::Document.createAttribute> ('a');

        $el-><M::Element.setAttributeNode> ($attr);
        $attr-><M::Node.manakaiSetReadOnly> (true, false);

        $test->id ('set.true.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNode> ($attr, true);
        }, exception_subtype => <Q::MDOMX|NOMOD_ATTR>);
        $test->id ('set.true.value');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $attr-><M::Node.manakaiSetReadOnly> (false, false);
        $attr-><AS::Attr.isId> (true);
        $attr-><M::Node.manakaiSetReadOnly> (true, false);

        $test->id ('set.false.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNode> ($attr, false);
        }, exception_subtype => <Q::MDOMX|NOMOD_ATTR>);
        $test->id ('set.false.value');
        $test->assert_true ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Element.setIdAttributeNode.not.found.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $attr = $el-><AG::Node.ownerDocument>
                      -><M::Document.createAttribute> ('a');

        $test->id ('true.not.found.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNode> ($attr, true);
        }, exception_subtype => <Q::c|NOT_ATTR_ERR>);

        $test->id ('false.not.found.exception');
        $test->assert_exception (code => sub {
          $el-><M::Element.setIdAttributeNode> ($attr, false);
        }, exception_subtype => <Q::c|NOT_ATTR_ERR>);

  @IL1OnlyMethod:
    @@Name: normalize
    @@enDesc:
      Puts all <IF::Text> nodes in the full depth of the subtree
      underneath the <IF::Node>, including <IF::Attr> nodes
      <SRC::DOM1SE>, <IF::tx|Entity> nodes <SRC::manakai>,
      <IF::d|ElementTypeDefinition> nodes <SRC::manakai>, and
      <IF::d|AttributeDefinition> nodes <SRC::manakai>,
      into a <QUOTE::normal> form where only structure (e.g.
      elements, comments, processing instructions, <XML::CDATA>
      sections, and entity references> separates <IF::Text> nodes,
      i.e. there are never adjacent <IF::Text> nodes.

        {NOTE::
          Adjacent <IF::tx|CDATASection> nodes are not metged
          by this method.
        }

        {NOTE::
          In DOM Level 2 and later, this method is defined
          in the <IF::Node> interface.
        }
    @@Return:
##Element

ForDef:
  @QName: tc|ForSelect
  @enDesc:
    For selecting an attribute node for the purpose other than
    removing the node.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForRemove
  @enDesc:
    For selecting an attribute node for the purpose of removing.
  @ISA: ManakaiDOM|ForClass

NodeTypeDef:
  @IFQName: Attr
  @ClsQName: ManakaiDOMAttr

  @DISLang:role: tc|AttributeRole
  
  @enDesc:
    An <IF::Attr> object represents an attribute that can be attached
    on an <IF::Element> object.

      {NOTE::
         Typically the allowable values for the attribute are
         defined in a schema associated with the document.
      }

    Since <IF::Attr> nodes are not actually child nodes of the
    element they describes, the DOM does not consisder them part
    of the document tree.  Thus, DOM attributes <A::Node.parentNode>,
    <A::Node.previousSibling>, and <A::Node.nextSibling> have a 
    <DOM::null> value for <IF::Attr> nodes.  The DOM takes the view
    that attributes are properties of elements rather than having
    a separate identity from the elements they are associated with.
    Developers of applications and implementations need to be aware
    that <IF::Attr> nodes have some things in common with other objects
    inheriting the <IF::Node> interface, but they are quite distinct.
  @enImplNote:
    @@ddid: eff
    @@@:
      {NOTE::
        Then why the DOM allows <IF::Attr> nodes that are not
        attached to any <IF::Element> node?  Why it allows 
        <IF::Attr> nodes having child nodes rather than
        they themselves containing value as in <IF::tcd|CharacterData>,
        <IF::tx|ProcessingInstruction>, or WinIE6's 
        <IF::Attr> implementation?
      }
  @enDesc:
    @@ddid: effval
    @@@:
      {ps:: <doc:caption::Specified and Default Values>

        {P:: The attribute's <DFN::effective value> is determined as follows:

           = If the attribute has been explicitly assigned any value,
             that value is the attribute's effective value.

           = Otherwise, if there is a declaration for the attribute,
             and that declaration includes a default value, then
             that default value is the attribute's effective value.

           = Otherwise, the attribute does not exist on the element
             in the structure model until it has been explicitly added.
      
        }

        The <A::Node.nodeValue> attribute on the <IF::Attr> node
        can be used to retrieve the string version of the attribute's
        value.

        If the attribute was not explicitly given a value in the 
        instance document but has a default value provided by
        the schema associated with the document, an attribute node
        will be created with <A::Attr.specified> set to <DOM::false>.

        Removing attribute nodes for which a default value is defined
        in the schema generates a new attribute node with the
        default value and <A::Attr.specified> set to <DOM::false>.

        If validation occurred while invoking <M::Document.normalizeDocument>,
        attribute node with <A::Attr.specified> equals to <DOM::false>
        are recomputed according to the default attribute values 
        provided by the schema.

      }

      {ps:: <doc:caption::Attribute Type and Normalization>

        In XML, where the value of an attribute can contain entity
        references, the child nodes of the <IF::Attr> node may
        be either <IF::Text> or <IF::tx|EntityReference> nodes.

        The DOM Core represents all attribute values as simple
        strings, even if the DTD or schema associated with the
        document declares them of some specific type such as
        tokenized type.

        The way attribute value normalization is performed by the
        DOM implementation depends on how much the implementation
        knows about the schema in use.  <SRC::DOM3>

        Typically, the <A::Attr.value> and <A::Node.nodeValue> attributes of
        an <IF::Attr> node initially contains the normalized value given by
        the parser.  It is also the case after <M::Document.normalizeDocument>
        is called (assugming the right configuration parameters
        have been set).  <SRC::DOM3>

        However, this may not be the case after mutation,
        independently of whether the mutation is performed by
        setting the string value directly or by changing the
        <IF::Attr> child nodes.  In particular, this is true when
        character references, which are not represented in the DOM
        and impact attribute value normalization, are involved.  <SRC::DOM3>

        On the other hand, if the implementation knows about the schema
        in use when the attribute value is changed, and it is of a 
        different type than <XML::CDATA>, it may normalize it
        again at that time.  This is especially true of specialized
        DOM implementations, such as SVG DOM implementations, which
        store attribute values in an internal form different from
        a string.  <SRC::DOM3>

      }

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|children>} = [];
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|namespaceName>}},
          $given => {${$opt->{<H::infoset|namespaceName>}}},
        }__;
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|prefix>}},
          $given => {${$opt->{<H::infoset|prefix>}}},
        }__;
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|localName>}},
          $given => {${$opt->{<H::infoset|localName>}}},
        }__;
        $obj->{<H::infoset|specified>} = $opt->{<H::infoset|specified>};
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:subnode1a: infoset|children
  @mg:owner0: tc|ownerDocument
  @mg:origin0: infoset|ownerElement

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

         - <Q::tc|ownerDocument>.

         - <Q::infoset|children>.

         - <Q::infoset|localName>.

      }

      {P:: Optional internal properties:

         - <Q::infoset|prefix>, <Q::infoset|namespaceName>.

         - <Q::infoset|ownerElement>, <Q::infoset|specified>.

         - <Q::c|userDeterminedId>.

         - <Q::c|read-only>.

      }

  @IntMethod:
    @@Operator: mg|CreateNodeRefMethod
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        my $class;
        CLS: {
          if (defined $opt->{<H::mg|nodeRefClass>}) {
            $class = $opt->{<H::mg|nodeRefClass>};
            IFCHK: {
              for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                last IFCHK unless $$class->isa ($_);
              }
              last CLS;
            } # IFCHK
          }

          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $class,
            $prop => {<H::tc|defaultNodeRefClass>},
            $ref => $obj,
          }__;
          if (defined $class) {
            IFCHK: {
              for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                last IFCHK unless $$class->isa ($_);
              }
              last CLS;
            } # IFCHK
          }

          my $nsuri;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $nsuri,
            $prop => {<H::infoset|namespaceName>},
            $ref => $obj,
          }__;
          $nsuri = \'' unless defined $nsuri;
          my $ln;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $ln,
            $prop => {<H::infoset|localName>},
            $ref => $obj,
          }__;
          my $oeid;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $oeid,
            $prop => {<H::infoset|ownerElement>},
            $ref => $obj,
          }__;
          my $oens;
          my $oeln;
          if (defined $oeid) {
            my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $obj>;
            my $oeh = <Code::mg|createNodeRefHashFromID||ManakaiDOM|all::
                                   $stemid = $oeid, $bag = $bag>;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $oens,
              $prop => {<H::infoset|namespaceName>},
              $ref => $oeh,
            }__;
            $oens = \'' unless defined $oens;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $oeln,
              $prop => {<H::infoset|localName>},
              $ref => $oeh,
            }__;
          } else {
            $oens = \'*';
            $oeln = \'*';
          }

          A: {
            ## Use cases:
            ##   - Any element type, |xml:id| attribute
            ##   - Any element type, |xlink:href| attribute
            ##   - |xslt:*| element type, any attribute
            ##   - |xslt:*| element type, NULL namespace attribute
            ##   - |xhtml1:*| element type, NULL namespace attribute

            for my $nm (
              [$oens, $oeln, $nsuri, $ln],
              [$oens, \'*', $nsuri, $ln],
              [\'*', \'*', $nsuri, $ln],
              [$oens, $oeln, $nsuri, \'*'],
              [$oens, \'*', $nsuri, \'*'],
              [\'*', \'*', $nsuri, \'*'],
              [$oens, $oeln, \'*', \'*'],
              [$oens, \'*', \'*', \'*'],
            ) {
              for my $__class (sort {
                $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
              } grep {
                $Message::DOM::DOMFeature::ClassInfo
                    ->{<ClassName::ManakaiDOMAttr>}
                    ->{compat_class_by_type}
                    ->{${$nm->[0]}}->{${$nm->[1]}}
                    ->{${$nm->[2]}}->{${$nm->[3]}}->{$_}
              } keys %{$Message::DOM::DOMFeature::ClassInfo
                           ->{<ClassName::ManakaiDOMAttr>}
                           ->{compat_class_by_type}
                           ->{${$nm->[0]}}->{${$nm->[1]}}
                           ->{${$nm->[2]}}->{${$nm->[3]}} or {}}) {
                if ($Message::DOM::DOMFeature::ClassInfo->{$__class}
                        ->{has_feature}->{xml}->{'3.0'}) {
                  $class = \$__class;
                  IFCHK: {
                    for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                      last IFCHK unless $$class->isa ($_);
                    }
                    last A;
                  } # IFCHK
                }
              }
            }

            ## Generic
            CLASS: for my $__class (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::DOMFeature::ClassInfo
                  ->{<ClassName::ManakaiDOMAttr>}
                  ->{compat_class}->{$_}
            } keys %{$Message::DOM::DOMFeature::ClassInfo
                         ->{<ClassName::ManakaiDOMAttr>}
                         ->{compat_class} or {}}) {
              if ($Message::DOM::DOMFeature::ClassInfo->{$__class}
                      ->{has_feature}->{xml}->{'3.0'}) {
                $class = \$__class;
                IFCHK: {
                  for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                    last IFCHK unless $$class->isa ($_);
                  }
                  last A;
                } # IFCHK
              }
            }

            ## Default
            $class = \$self;
          } # A

          if (defined $oeid) {
            __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
              $given => $class,
              $prop => {<H::tc|defaultNodeRefClass>},
              $ref => $obj,
            }__;
          }
        } # CLS
        $r = bless $obj, $$class;

  @CODE:
    @@QName: tc|createAttrForTest
    @@PerlDef:
      my $__doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__doc}__;
      $attr = $__doc-><M::Document.createAttributeNS>
                      ('http://www.example.net/', 'ex:element');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.ATTRIBUTE_NODE

    @@Test:
      @@@QName: Attr.nodeType.test
      @@@PerlDef:
        my $attr;
        __CODE{tc|createAttrForTest:: $attr => $attr}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $attr-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);

  @CL2Attr:
    @@Name: prefix
    @@enDesc:
      The namespace prefix of the node.
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the namespace prefix is unspecified.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;
        $r = defined $v ? $$v : null;
    @@Set:
      @@@nullCase:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified value contains an illegal character according to
          the XML version in use specified in the <A::Document.xmlVersion>
          attribute.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_BAD_NCNAME
        @@@@enDesc:
          If the specified prefix is malformed per the XML Namespaces
          specification.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <A::Node.namespaceURI> of the node is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the specified prefix is <XML::xml> and
          the <A::Node.namespaceURI> of the node is different
          from <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the node is an attribute and the specified prefix
          is <XML::xmlns> and the <A::Node.namespaceURI> of the node
          is different from <URI::http://www.w3.org/2000/xmlns/>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_QNAME_IS_XMLNS
        @@@@enDesc:
          If the node is an attribute and the qualified name
          of the node is <XML::xmlns>.
      @@@PerlDef:
        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking>) {
          __CODE{tc|NodeReadOnlyError:: $node => $self}__;
          my $nsuri;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $nsuri,
            $prop => {<H::infoset|namespaceName>},
            $ref => $self,
          }__;
          if (not defined $nsuri) {
            __EXCEPTION{MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {null},
            }__;
          } elsif ($$nsuri ne <Q::xml:> and
                   defined $given and $given eq 'xml') {
            __EXCEPTION{MDOMX|MDOM_NS_XML_WITH_OTHER_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {$self-><AG::Node.namespaceURI>},
            }__;
          } elsif ($$nsuri ne <Q::xmlns:> and
                   defined $given and $given eq 'xmlns') {
            __EXCEPTION{MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {$self-><AG::Node.namespaceURI>},
            }__;
          } elsif ($self-><AG::Node.nodeName> eq 'xmlns') {
            __EXCEPTION{MDOMX|MDOM_NS_QNAME_IS_XMLNS::
              infoset|prefix => {$given},
              infoset|namespaceName => {$self-><AG::Node.namespaceURI>},
            }__;
          }
          my $version = $od-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureNamespacePrefix::
            $INPUT => $given, $INPUT_PARAM_NAME => '',
            $XMLVERSION => $version,
          }__;
        } # strict
        my $v = defined $given ? \$given : null;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $v,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;

    @@L2Test:
      @@@QName: Attr.localName.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         (null, 'el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, null);

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, null);

        $test->id ('prefix.set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Attr.localName.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.ns.example/', 'p:el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>,
                              'http://www.ns.example/');

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

        $test->id ('prefix.set');
        $el-><AS::Node.prefix> ('pre');
        $test->assert_equals ($el-><AG::Node.prefix>, 'pre');

    @@L2Test:
      @@@QName: Attr.prefix.1.test
      @@@enDesc:
        <M::Document.createAttributeNS> node with no namespace URI,
        no prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS> (null, 'el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('reset');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> (null);
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Attr.prefix.2.test
      @@@enDesc:
        <M::Document.createAttribute> node.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttribute> ('el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('reset');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> (null);
        }, exception_subtype => <Q::MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Attr.prefix.4.test
      @@@enDesc:
        <M::Document.createAttributeNS> node with namespace URI and prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.dom.test/', 'p:el');

        $test->id ('get');
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

        $test->id ('set');
        $el-><AS::Node.prefix> ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'prefix');

        $test->id ('reset');
        $el-><AS::Node.prefix> (null);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Attribute.prefix.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.dom.test/', 'p:el');

        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('new-prefix');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

    @@L2Test:
      @@@QName: Attr.prefix.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.dom.test/', 'p:el');

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('0120');
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

    @@L2Test:
      @@@QName: Attr.prefix.7.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.dom.test/', 'p:el');

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('a:b');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_BAD_NCNAME>);
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

    @@enImplNote:
      @@@ddid: moretest
      @@@@:
        {TODO::
          More tests for namespace errors and XML 1.1 error are necessary.
        }

  @Test:
    @@QName: Attr.parentNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');

      $test->assert_null ($el-><AG::Node.parentNode>);

  @Test:
    @@QName: Attr.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');

      my $el2 = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Attr.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');

      my $el2 = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: Attr.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createAttributeNS> (null, 'el');

      $test->id ('default');
      $test->assert_false ($el-><AG::Node.manakaiReadOnly>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: td|DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::td|DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: td|DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::td|DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: td|DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::td|DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
          }},
        }__;

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        Same as <A::Attr.name>.
      @@@disDef:
        @@@@DISPerl:cloneCode: .name.get

  @Attr:
    @@Name: name
    @@enDesc:
      The name of the attribute.
    @@enDesc:
      @@@ddid: ns
      @@@@:
        If the <A::Node.localName> of the node is different from
        <DOM::null>, then the attribute value is the qualified name
        of the attribute node.  <SRC::DOM3>
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        my $prefix;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $prefix,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;
        my $lname;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $lname,
          $prop => {<H::infoset|localName>},
          $ref => $self,
        }__;
        $r = defined $prefix ? $$prefix.':'.$$lname : $$lname;
    @@enImplNote:
      {ISSUE::
        In HTML?
      }

      {NOTE::
        DOM Level 1 nodes are no longer supported.
      }

    @@Test:
      @@@QName: Attr.nodeName.name.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttribute> ('element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('name');
        $test->assert_equals ($el-><AG::Attr.name>, 'element1');

    @@Test:
      @@@QName: Attr.nodeName.name.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS> (null, 'element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('name');
        $test->assert_equals ($el-><AG::Attr.name>, 'element1');

    @@Test:
      @@@QName: Attr.nodeName.name.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://el1.test/', 'element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('name');
        $test->assert_equals ($el-><AG::Attr.name>, 'element1');

    @@Test:
      @@@QName: Attr.nodeName.name.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://el1.test/', 'pfx:element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'pfx:element1');

        $test->id ('name');
        $test->assert_equals ($el-><AG::Attr.name>, 'pfx:element1');

  @CAttr:
    @@Name: nodeValue
    @@enDesc:
      The value of the node.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Attr.value>;
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          $self-><AS::Attr.value> ($given);
        }__;

    @@Test:
      @@@QName: Attr.appendChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.insertBefore.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Attr.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Attr.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: Attr.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Attr.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Attr.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Attr.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc-><M::Document.createAttribute> ('data');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createProcessingInstruction> ('ent'),
          $doc-><M::Document.createElement> ('e'),
          $doc-><M::Document.createAttribute> ('a'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: Attr.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createAttribute> ('data');

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: Attr.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createAttribute> ('data');
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: Attr.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('d');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: Attr.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('d');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: Attr.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Attr.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Attr.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Attr.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Attr.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@PerlDef:
        __DEEP{
          my $lc = $self-><AG::Node.lastChild>;
          if (defined $lc and
              $lc-><AG::Node.nodeType> == <C::Node.TEXT_NODE>) {
            $lc-><M::Node.manakaiAppendText>
                   (ref $string eq 'SCALAR' ? $string : \$string);
          } else {
            my $text = $self-><AG::Node.ownerDocument>
                            -><M::Document.createTextNode> 
                                (ref $string eq 'SCALAR' ? $$string : $string);
            $self-><M::Node.appendChild> ($text);
          }
          $r = $self;
        }__;

    @@Test:
      @@@QName: Attr..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $node = $doc-><M::Document.createAttribute> ('node');

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::Attr>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.textContent>, 'string');
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRINGtext');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMAttr>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Attr.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createAttrForTest:: $attr => $node}__;

        for (
          [Core => '1.0', <IFName::Attr||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Attr||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Attr||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Attr||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Attr||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Attr||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is not available.
      @@@PerlDef:
        __DEEP{
          my $oe = $self-><AG::Attr.ownerElement>;
          if ($oe) {
            $r = $oe-><AG::Node.baseURI>;
          } else {
            my $od = $self-><AG::Node.ownerDocument>;
            $r = $od-><AG::Node.baseURI>;
          }
        }__;

    @@L3Test:
      @@@QName: Attr.baseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> (null, 'attr');
        
        $test->id ('initial');
        $test->assert_null ($attr-><AG::Node.baseURI>);

        $doc-><AS::Document.documentURI> (q<http://www.example.com/>);
        
        $test->id ('doc');
        $test->assert_equals
                 ($attr-><AG::Node.baseURI>,
                  q<http://www.example.com/>);

        my $el = $doc-><M::Document.createElementNS> (null, 'element');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://www.example.org/>);
        $el-><M::Element.setAttributeNodeNS> ($attr);

        $test->id ('element');
        $test->assert_equals
                 ($attr-><AG::Node.baseURI>,
                  q<http://www.example.org/>);

  @L2Attr:
    @@Name: ownerElement
    @@enDesc:
      The <IF::Element> node to which the attribute is attached.
    @@Type: Element
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the attribute is not in use.
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|ownerElement>},
          $ref => $self,
          $opt => {{
          }},
        }__;

    @@L2Test:
      @@@QName: Attr.ownerElement.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
 
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'attr');

        $test->id ('default');
        $test->assert_null ($attr-><AG::Attr.ownerElement>);

        $test->id ('set');
        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        $test->assert_equals ($attr-><AG::Attr.ownerElement>, $el);

        $test->id ('remove');
        $el-><M::Element.removeAttributeNode> ($attr);
        $test->assert_null ($attr-><AG::Attr.ownerElement>);

  @Attr:
    @@Name: specified
    @@enDesc:
      Whether the attribute was explicitly given a value in
      the instance document.

      If the application changed the value of the attribute node
      (even if it ends up having the same value as the default value),
      then it is set to <DOM::true>.

      The implementation may handle attributes with default values
      from other schemas than DTD similarly but applications
      should use <M::Document.normalizeDocument> to guarantee this
      information is up-to-date.

      If the <A::Attr.ownerElement> attribute is <DOM::null>,
      <A::Attr.specified> is <DOM::true>.  <SRC::DOM1SE, DOM2>
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        The attribute is explicitly given a value in the instance document.
    @@FalseCase:
      @@@enDesc:
        Otherwise.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|specified>},
          $ref => $self,
        }__;
        unless ($r) {
          my $oe;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $oe,
            $prop => {<H::infoset|ownerElement>},
            $ref => $self,
          }__;
          unless (defined $oe) {
            $r = true;
          }
        }
    @@LXSet:
      @@@TrueCase:
        @@@@enDesc:
          Sets the <A::Attr.specified> flag <DOM::true>.  <SRC::manakai>
      @@@FalseCase:
        @@@@enDesc:
          Sets the <A::Attr.specified> flag <DOM::false>.
          This might result in inconsistency between
          the document tree and a serialized representation of it.
          <SRC::manakai>

          If the <A::Attr.ownerElement> is <DOM::null>, 
          the <A::Attr.specified> value <kwd:MUST> be 
          left unchanged as <DOM::true>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        unless ($given) {
          my $oe;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $oe,
            $prop => {<H::infoset|ownerElement>},
            $ref => $self,
          }__;
          $given = true unless defined $oe;
        }
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|specified>},
          $ref => $self,
        }__;

    @@enImplNote:
      @@@ddid: mutation 
      @@@@:
        {TODO::
          If a node in subtree is modified, the <A::Attr.specified>
          flag must be turned <DOM::true>.  Manakai implements this
          behavior in some case, but not all, in particular
          node operation methods such as <M::Node.appendChild> does not.

          $another_node->append_child ($text_that_is_a_child_of_attr)
          must change $text_that_is_a_child_of_attr->parent_node->specified.

          Setting of any <QUOTE::reflected> attribute must change
          the specified value.
        }

    @@LXTest:
      @@@QName: Document.specified.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
 
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'at1');

        $test->id ('default');
        $test->assert_true ($attr-><AG::Attr.specified>);

        $test->id ('set.false');
        $attr-><AS::Attr.specified> (false);
        $test->assert_true ($attr-><AG::Attr.specified>);

        $test->id ('set.true');
        $attr-><AS::Attr.specified> (true);
        $test->assert_true ($attr-><AG::Attr.specified>);
    @@Test:
      @@@QName: Attr.specified.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> (null, 'at1');

        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        $el-><M::Element.setAttributeNodeNS> ($attr);

        $test->id ('default');
        $test->assert_true ($attr-><AG::Attr.specified>);

        $test->id ('set.false');
        $attr-><AS::Attr.specified> (false);
        $test->assert_false ($attr-><AG::Attr.specified>);

        $test->id ('set.true');
        $attr-><AS::Attr.specified> (true);
        $test->assert_true ($attr-><AG::Attr.specified>);

        $attr-><AS::Attr.specified> (false);

        $test->id ('removed');
        $el-><M::Element.removeAttributeNode> ($attr);
        $test->assert_true ($attr-><AG::Attr.specified>);
    @@Test:
      @@@QName: Attr.specified.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> (null, 'at1');

        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        $el-><M::Element.setAttributeNodeNS> ($attr);

        $attr-><AS::Attr.specified> (false);

        my $attr2 = $doc-><M::Document.createAttributeNS> (null, 'at1');

        $test->id ('removed');
        $el-><M::Element.setAttributeNodeNS> ($attr2);
        $test->assert_true ($attr-><AG::Attr.specified>);

  @Attr:
    @@Name: value
    @@enDesc:
      The value of the attribute as a string.  Character and general
      entity references, if any, are replaced with their values.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        @@@@ForCheck: ManakaiDOM|ManakaiDOM
        @@@@@:
          In the manakai implementation, it is the concatenation of
          the <DFN::text content> of every child node.  For <IF::Text>
          children, the text content of a node is the <A::Node.textContent>
          attribute value.  For <IF::tx|EntityReference>
          children, the text content of a node is the
          <A::Node.textContent> attribute value with
          any <CODE::U+0009>, <CODE::U+000A>, and
          <CODE::U+000D> replaced by <CODE::U+0020>.

          If the <InfoProp::attribute type> of the node
          (which might be accessible via <A::Attr.schemaTypeInfo>
           if the schema language of the document is XML DTD) has
          a valid value different from <CODE::no value>, <CODE::unknown>,
          and <CODE::CDATA>, then the value
          is further modified by discarding any leading
          and trailing <CODE::U+0020> characters and
          by replacing sequences of <CODE::U+0020> characters
          by a single <CODE::U+0020> character.
      @@@PerlDef:
         __DEEP{
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.nodeType> ==
                  <C::Node.ENTITY_REFERENCE_NODE>) {
                my $v = $child-><AG::Node.textContent>;
                $v =~ s/[\x09\x0A\x0D]/ /;
                $r .= $v;
              } else {
                $r .= $child-><AG::Node.textContent>;
              }
            } # childNodes
            my $vt;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $vt,
              $prop => {<H::infoset|attributeType>},
              $ref => $self,
            }__;
            unless (not defined $vt or
                    $vt == <C::ATDef.NO_TYPE_ATTR> or
                    $vt == <C::ATDef.UNKNOWN_ATTR> or
                    $vt == <C::ATDef.CDATA_ATTR>) {
              $r =~ s/\A\x20+//;
              $r =~ s/\x20+\z//;
              $r =~ s/\x20+/ /g;
            }
        }__;
    @@Set:
      @@@enDesc:
        Removes any child nodes <SRC::manakai>, and
        creates a <IF::Text> node with the unparsed content
        of the string <SRC::DOM1, DOM2, DOM3>, unless the specified value
        is the empty string <SRC::manakai>.

          {NOTE::
            Some specialized implementations, such as some SVG 1.1
            implementations, may do normalization automatically,
            even after mutation; in such case, the value on retrieval
            may differ from the value on setting.  <SRC::DOM3>
          }
      @@@enImplNote:
        Currenly type information does not affect on setting.
        Should it do?
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only. <SRC::DOM1FE Errata, DOM1SE, DOM2, DOM3>
      @@@PerlDef:
        __CODE{tc|setNodeTextContent::
          $node => $self,
          $given => $given,
          $ownerDocument => {$self-><AG::Node.ownerDocument>},
        }__;
    @@enImplNote:
      @@@ddid: value-attrs
      @@@@:
        <IF::Node.nodeValue> for <IF::Attr> and <IF::Attr.value> shares their
        definition.  <IF::Node.textContent> does <EM::not>.

        Manakai's <IF::Node.nodeValue> for <IF::ATDef> is also shares
        the definition with <IF::Attr.value>.

    @@Test:
      @@@QName: Attr.nodeValue.value.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
  
        for my $node (
          $doc-><M::Document.createAttribute> ('attr'),
          $doc-><M::Document.createAttributeNS> (null, 'attr'),
        ) {
          $test->id ('nodeValue.get');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('value.get');
          $test->assert_equals ($node-><AG::Attr.value>, '');

          $node-><M::Node.manakaiSetReadOnly> (false);

          $node-><AS::Node.nodeValue> ('value1');

          $test->id ('nodeValue.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value1');

          $test->id ('nodeValue.set.value');
          $test->assert_equals ($node-><AG::Attr.value>, 'value1');

          $node-><AS::Node.nodeValue> ('');

          $test->id ('nodeValue.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('nodeValue.empty.value');
          $test->assert_equals ($node-><AG::Attr.value>, '');

          $node-><AS::Attr.value> ('value2');

          $test->id ('value.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value2');

          $test->id ('value.set.value');
          $test->assert_equals ($node-><AG::Attr.value>, 'value2');
     
          $node-><AS::Attr.value> ('');

          $test->id ('value.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('value.empty.value');
          $test->assert_equals ($node-><AG::Attr.value>, '');

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ('nodeValue.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.nodeValue> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('value.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Attr.value> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');
        }

  @L3Attr:
    @@Name: schemaTypeInfo
    @@enDesc:
      The type information associated with the attribute.

      While the type information contained in the attribute is guarantee
      to be correct after loading the document or validation,
      it may not be reliable if the node was moved.
    @@Type: c|TypeInfo
    @@Get:
      @@@PerlDef:
        my $type;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $type,
          $prop => {<H::infoset|attributeType>},
          $ref => $self,
        }__;
        __CODE{c|createDTDTypeInfo::
          $result => $r,
          $type => $type,
        }__;

    @@L3Test:
      @@@QName: Attr.schemaTypeInfo.no-schema.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => q[http://dummy.example/]);
        $el-><M::Element.setAttributeNS> (null, 'a', 'b');
        my $attr = $el-><M::Element.getAttributeNodeNS> (null, 'a');

        my $sti = $attr-><AG::Attr.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);
    @@L3Test:
      @@@QName: Attr.schemaTypeInfo.dtd.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => <Q::xml-dtd:>);
        $el-><M::Element.setAttributeNS> (null, 'a', 'b');
        my $attr = $el-><M::Element.getAttributeNodeNS> (null, 'a');

        my $sti = $attr-><AG::Attr.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);
    @@L3Test:
      @@@QName: Attr.schemaTypeInfo.dtd.cdata.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => <Q::xml-dtd:>);
        $el-><M::Element.setAttributeNS> (null, 'a', 'b');
        my $attr = $el-><M::Element.getAttributeNodeNS> (null, 'a');
        $attr-><AS::Attr.manakaiAttributeType> (<C::ATDef.CDATA_ATTR>);

        my $sti = $attr-><AG::Attr.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_equals ($sti-><AG::c|TypeInfo.typeName>, 'CDATA');
        $test->assert_equals
                 ($sti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);

  @L3Attr:
    @@Name: isId
    @@enDesc:
      Whether the attribute is known to be of type ID,
      i.e. to contain an identifier for its owner element, or not.

      When it is and its value is unique, the <A::Attr.ownerElement>
      of the attribute can be retrieved using the
      <M::Document.getElementById> method with the <A::Attr.value>
      of the attribute.

      {P:: The implementation could use several ways to determine
           whether an attribute is known to contain an identifier or not:

         - If validation occurred using an XML Schema 1.0 schema while
           loading the document or while invoking the
           <M::Document.normalizeDocument> method, the PSVI
           contributions values are used to determine whether
           the attribute is a schema-determined ID attribute
           using the schema-determined ID definition in the
           XPointer Framework specification.

         {LI:: If validation occurred using a DTD while loading the
               document or while invoking the 
               <M::Document.normalizeDocument> method, the
               infoset <InfoProp::attribute type> value is
               used to determine whether the attribute is
               a DTD-determined ID attribute using the
               DTD-determined ID definition in the
               XPointer Framework specification.

               {SpecIssue:: DOM3 & XPointer specs are incorrect.
               }

         }

         - From the use of the methods <M::Element.setIdAttribute>,
           <M::Element.setIdAttributeNS>, or <M::Element.setIdAttributeNode>
           method, i.e. it is an user-determined ID attribute.  Note
           that it is considered as being part of the XPointer
           externally-determined ID definition.

         - Using mechanisms that are outside the scope of
           the DOM specification, it is then an externally-determined
           ID attribute.  This includes using schema languages
           different from XML Schema and DTD.
      }

      {NOTE::
        If validation occurred while invoking the <M::Document.normalizeDocument>
        method, all user-determined ID attributes are reset.
      }
    @@Type: boolean
    @@Get:
      @@@PerlDef:
        @@@@@:
          T: {
            ## DTD Attribute Type
            my $type;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $type,
              $prop => {<H::infoset|attributeType>},
              $ref => $self,
            }__;
            if (defined $type and $type == <C::ATDef.ID_ATTR>) {
              $r = true;
              last T;
            }

            ## User-determined ID
            my $udid;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $udid,
              $prop => {<H::c|userDeterminedId>},
              $ref => $self,
            }__;
            if ($udid) {
              $r = true;
              last T;
            }

            ## Application-determined ID
            my $nsuri = $self-><AG::Node.namespaceURI>;
            my $ln = $self-><AG::Node.localName>;
            if (defined $nsuri and $nsuri eq <Q::xml:> and
                $ln eq 'id') {
              $r = true;
              last T;
            } elsif (not defined $nsuri and $ln eq 'xml:id') {
              $r = true;
              last T;
            }
          } # T

          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Support non-user-determined ID attributes.
              Especially, application-determined ID such as html5:*/@id
              and xml:id should be supported.
    @@LXSet:
      @@@TrueCase:
        @@@@enDesc:
          Declares the attribute to be a user-determined ID attribute.
      @@@FalseCase:
        @@@@enDesc:
          Undeclares the attribute for being a user-determined
          ID attribute.

            {NOTE::
              Setting <DOM::false> does not remove other sources
              that makes the attribute being of type ID.
            }
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::c|userDeterminedId>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Attr.isId.dtdid.test
      @@@enDesc:
        DTD-determined ID attribute.
      @@@PerlDef:
        my $attr;
        __CODE{tc|createAttrForTest:: $attr => $attr}__;

        $attr-><AS::Attr.manakaiAttributeType> (<C::ATDef.ID_ATTR>);

        $test->id ('default');
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.true');
        $attr-><AS::Attr.isId> (true);
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.false');
        $attr-><AS::Attr.isId> (false);
        $test->assert_true ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Attr.isId.udid.test
      @@@enDesc:
        User-determined ID attribute.
      @@@PerlDef:
        my $attr;
        __CODE{tc|createAttrForTest:: $attr => $attr}__;

        $test->id ('default');
        $test->assert_false ($attr-><AG::Attr.isId>);

        $test->id ('set.true');
        $attr-><AS::Attr.isId> (true);
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.false');
        $attr-><AS::Attr.isId> (false);
        $test->assert_false ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Attr.isId.xmlid.test
      @@@enDesc:
        Namespace unaware <XA::xml:id> attribute.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttribute> ('xml:id');

        $test->id ('default');
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.false');
        $attr-><AS::Attr.isId> (false);
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.true');
        $attr-><AS::Attr.isId> (true);
        $test->assert_true ($attr-><AG::Attr.isId>);
    @@Test:
      @@@QName: Attr.isId.xmlidns.test
      @@@enDesc:
        Namespace aware <XA::xml:id> attribute.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> (<Q::xml:>, 'xml:id');

        $test->id ('default');
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.false');
        $attr-><AS::Attr.isId> (false);
        $test->assert_true ($attr-><AG::Attr.isId>);

        $test->id ('set.true');
        $attr-><AS::Attr.isId> (true);
        $test->assert_true ($attr-><AG::Attr.isId>);

  @LXAttr:
    @@Name: manakaiAttributeType
    @@enDesc:
      Sets the declared type of the attribute.

        {NOTE::
          This DOM attribute is equivalent to the <InfoProp::attribute type>
          property for the attribute information items in XML
          Information Set.
        }
    @@Type: unsignedShort
    @@dis:actualType: d|DeclaredValueType
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|attributeType>},
          $ref => $self,
        }__;
        $r = <C::ATDef.NO_TYPE_ATTR> unless defined $r;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|attributeType>},
          $ref => $self,
        }__;
##Attr

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        The node is read-only.

ElementTypeBinding:
  @Name: intValue
  @ElementType:
    dis:Value
  @ShadowContent:
    @@ContentType: DISCore|Integer

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

IntPropDef:
  @QName: c|userDeterminedId
  @enDesc:
    Whether it is a user-determined ID attribute or not.
  @Type: DISPerl|Boolean||ManakaiDOM|all
  @rdfs:range: Attr
  @tc:nodeStemKey: isudid
