Module:
  @QName: 
    MDOM:DOMLS
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#

  @AppName:
     @@@:  ls
     @@ContentType:
        lang:IDL-DOM
     @@prefix:  dom.w3c.org
    @@ForCheck: ManakaiDOM|IDL

  @FullName:
    @@@: DOM Load and Save Module
    @@@@lang:en

  @Description:
    @@lang:en
    @@@:
      A set of interfaces for loading and saving document objects. 
      The functionality defined in this module (the <DFN::Load and Save>
      functionality) is sufficient to allow DOM applications to 
      load and save XML content.  The API also allows filtering 
      of XML content using only DOM API calls.

  @Author:
     @@FullName: Wakaba
     @@Mail: w@suika.fam.cx
  @License:
     license:Perl+MPL
  @Date:
    @@@:
      $Date: 2005/09/17 15:03:02 $
    @@ContentType:
      dis:Date.RCS

  @DefaultFor:
    ManakaiDOM:ManakaiDOMLatest

  @Require:
     @@Module:
        @@@Name:  DOMCore
#     @@Module:
#        @@@Name:  DOMEvents
## TODO: Implement these modules
#     @@Module:
#        @@@Name:  DOMTraversal
    @@Module:
      @@@Name: DOMLS
      @@@WithFor:
        ManakaiDOM:ManakaiDOM
    @@Module:
      @@@Name: DOMLS
      @@@WithFor:
        ManakaiDOM:ManakaiDOM3
    @@Module:
      @@@Name: DOMLS
      @@@WithFor:
        ManakaiDOM:ManakaiDOMLatest

Namespace:
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @DOMMetaImpl:
    http://suika.fam.cx/~wakaba/archive/2004/dom/meta#
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @LSEV:
    http://www.w3.org/2002/DOMLS
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @ManakaiDOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-ls#
  @ManakaiDOMLS2003:
    http://suika.fam.cx/~wakaba/archive/2004/9/27/mdom-old-ls#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @TreeCore: \
  @undef:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/undef
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all
ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:String

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @featureName: LS
  @QName: LSFeature
  @FeatureVerDef:
    @@Version:3.0
    @@QName: LSFeature30
    @@DOMMetaImpl:instanceFeatureOf: LSFeature
    @@DOMMain:requireFeature: 
      DOMCore:CoreFeature20
    @@FullName:
      @@@lang:en
      @@@@:
        DOM Load and Save Module Fundamental Interfaces, Level 3

FeatureDef:
  @featureName: LS-Async
  @QName: LSAsyncFeature
  @FeatureVerDef:
    @@Version:3.0
    @@QName: LSAsyncFeature30
    @@DOMMetaImpl:instanceFeatureOf: LSAsyncFeature
    @@DOMMain:requireFeature: LSFeature30
    @@FullName:
      @@@lang:en
      @@@@:
        DOM Load and Save Module Fundamental Interfaces, Level 3 
        (asynchronous mode)

## -- Basic Types

ImplNote:
  @lang:en
  @@:
    Basic types are specified to ensure interoperability.  Bindings 
    may use different types.

ElementTypeBinding:
  @Name: DataTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType

DataTypeDef:
  @Name:  LSInputStream
  @Description:
    @@lang:en
    @@@:
      A reference to a byte stream source of an XML input.

  @Def:
    @@For:
      ManakaiDOM:IDL
    @@ContentType:
      lang:dis
    @@DISLang:dataTypeAliasFor:
      @@@@:
        DOMMain:Object
      @@@ContentType:
        dis:TypeQName
  @Def:
    @@For:
      ManakaiDOM:Java
    @@DISLang:dataTypeAliasFor:
      @@@@: java.io.InputStream
      @@@ContentType:
        lang:Java
  @Def:
    @@For:
      ManakaiDOM:ECMAScript
    @@DISLang:dataTypeAliasFor:
      @@@@: Object
      @@@ContentType:
        lang:ECMAScript

DataTypeDef:
  @Name:  LSOutputStream
  @Description:
    @@lang:en
    @@@:
      A byte stream destination for the XML output.

  @Def:
    @@For:
      ManakaiDOM:IDL
    @@DISLang:dataTypeAliasFor:
      @@@@:
        DOMMain:Object
      @@@ContentType:
        dis:TypeQName
  @Def:
    @@For:
      ManakaiDOM:Java
    @@DISLang:dataTypeAliasFor:
      @@@@: java.io.OutputStream
      @@@ContentType:
        lang:Java
  @Def:
    @@For:
      ManakaiDOM:ECMAScript
    @@DISLang:dataTypeAliasFor:
      @@@@: Object
      @@@ContentType:
        lang:ECMAScript

DataTypeDef:
  @Name:  LSReader
  @Description:
    @@lang:en
    @@@:
      A character stream, i.e. a sequence of input characters 
      in 16-bit units, for the XML input.

  @Def:
    @@For:
      ManakaiDOM:IDL
    @@DISLang:dataTypeAliasFor:
      @@@@:
        DOMMain:Object
      @@@ContentType:
        dis:TypeQName
  @Def:
    @@For:
      ManakaiDOM:Java
    @@DISLang:dataTypeAliasFor:
      @@@@: java.io.Reader
      @@@ContentType:
        lang:Java
  @Description:
    @@lang:en
    @@@:
      The <TYPE::LSReader> has no recommended meaning in ECMAScript binding.
    @@For:
      ManakaiDOM:ECMAScript

DataTypeDef:
  @Name:  LSWriter
  @Description:
    @@lang:en
    @@@:
      A character stream, i.e. a sequence of characters in 16-bit units, 
      for the XML output.

  @Def:
    @@For:
      ManakaiDOM:IDL
    @@DISLang:dataTypeAliasFor:
      @@@@:
        DOMMain:Object
      @@@ContentType:
        dis:TypeQName
  @Def:
    @@For:
      ManakaiDOM:Java
    @@DISLang:dataTypeAliasFor:
      @@@@: java.io.Writer
      @@@ContentType:
        lang:Java
  @Description:
    @@For:
      ManakaiDOM:ECMAScript
    @@lang:en
    @@@:
      The <TYPE::LSWriter> has no recommended meaning in ECMAScript binding.

DataTypeDef:
  @Name: DOMString
  @AliasFor:
    @@@:
      DOMMain:DOMString
    @@For:
      !ManakaiDOM:IDL
  @Def:
    @@For:
      ManakaiDOM:IDL
    @@DISLang:dataTypeAliasFor:
      @@@@:
        DOMMain:DOMString
      @@@ContentType:
        dis:TypeQName
  @For:
    ManakaiDOM:DOM
DataTypeDef:
  @Name:  DOMConfiguration
  @AliasFor:
    @@@:
      DOMCore:DOMConfiguration
    @@For:
      !ManakaiDOM:IDL
  @Def:
    @@DISLang:dataTypeAliasFor:
      @@@@:
        DOMCore:DOMConfiguration
      @@@ContentType:
        dis:TypeQName
    @@For:
      ManakaiDOM:IDL
  @For:
    ManakaiDOM:DOM
DataTypeDef:
  @Name:  Node
  @AliasFor:
    @@@:
      DOMCore:Node
    @@For:
      !ManakaiDOM:IDL
  @Def:
    @@For:
      ManakaiDOM:IDL
    @@DISLang:dataTypeAliasFor:
      @@@@:
        DOMCore:Node
      @@@ContentType:
        dis:TypeQName
  @For:
    ManakaiDOM:DOM
DataTypeDef:
  @Name:  Document
  @AliasFor:
    @@@:
      DOMCore:Document
    @@For:
      !ManakaiDOM:IDL
  @Def:
    @@For:
      ManakaiDOM:IDL
    @@DISLang:dataTypeAliasFor:
      @@@@:
        DOMCore:Document
      @@@ContentType:
        dis:TypeQName
  @For:
    ManakaiDOM:DOM
DataTypeDef:
  @Name:  Element
  @AliasFor:
    @@@:
      DOMCore:Element
    @@For:
      !ManakaiDOM:IDL
  @Def:
    @@For:
      ManakaiDOM:IDL
    @@DISLang:dataTypeAliasFor:
      @@@@:
        DOMCore:Element
      @@@ContentType:
        dis:TypeQName
  @For:
    ManakaiDOM:DOM

## Fundamental Interfaces

ImplNote:
  @lang:en
  @@:
    The fundamental interfaces must be fully implemented by all 
    conforming implementations.

ElementTypeBinding:
  @Name: L3
  @ElementType:
    DOMMain:implementFeature
  @ShadowContent:
    @@@: LSFeature30
    @@For:
      ManakaiDOM:DOM3

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @resourceFor: ManakaiDOM|ForIF
  @resourceFor:
    @@@: ManakaiDOM|ForClass
    @@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
  @For: ManakaiDOM|DOM3
  @For: =ManakaiDOM|ManakaiDOM

  @rdf:type:
    @@@: ManakaiDOM|ExceptionIF
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: ManakaiDOM|ExceptionClass
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @DOMMain:implementFeature:
    @@@: LSFeature30
    @@For: ManakaiDOM|DOM3
  @DOMMain:implementFeature:
    @@@: LSAsyncFeature30
    @@For: ManakaiDOM|DOM3

  @Implement:
    @@@: DOMMain|ManakaiDOMExceptionIF||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @ISA:
    @@@: ManakaiDOM|ManakaiDOMException||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass
  @ISA:
    @@@: ManakaiDOM|ManakaiDOMObject
    @@ForCheck: ManakaiDOM|ForClass

  @IFQName: LSException
  @ClsQName: ManakaiDOMLSException

  @enDesc:
    Parser or serializer may throw a <IF::LSException> if the processing
    is stopped.  The processing can be stopped due to a <IF::DOMCore|DOMError>
    with a <A::DOMCore|DOMError.severity> of 
    <C::DOMCore|DOMError.SEVERITY_FATAL_ERROR> or a non-recovered
    <C::DOMCore|DOMError.SEVERITY_ERROR>, or if 
    <M::DOMCore|DOMErrorHandler.handleError> method returned <DOM::false>.

    {NOTE:: A DOM implementation may choose to continue processing
            after a fatal error, but the result is then 
            implementation dependent.
    }

  @Attr:
     @@Name:  code
     @@Get:
        @@@Type:
           DOMMain:unsigned-short||ManakaiDOM|all
        @@@actualType: ManakaiDOMLSExceptionCode
     @@ForCheck: ManakaiDOM|ForIF

  @ResourceDef:
    @@rdf:type: ManakaiDOM|ConstGroup
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

    @@IFQName: LSExceptionCode
    @@ClsQName: ManakaiDOMLSExceptionCode
    @@PerlName: LSExceptionCode

     @@rdfs:subClassOf:
       @@@@: DOMMain|unsigned-short||ManakaiDOM|all
       @@@ForCheck: ManakaiDOM|ForClass
     @@Type: DOMMain|unsigned-short||ManakaiDOM|all

   @@enDesc:
     An integer indicating the type of error generated.

     @@Const:
        @@@Name:  PARSE_ERR
        @@@Value:  81
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt was made to load a document or an XML fragment 
            using <IF::LSParser> and the processing has been stopped.
     @@Const:
        @@@Name:  SERIALIZE_ERR
        @@@Value:  82
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt was made to serialize a <IF::DOMCore:Node> using 
            <IF::LSSerializer> and the processing has been stop.
##LSException


ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass


ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass


ElementTypeBinding:
  @Name: IFCls3Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@DOMMain:implementFeature:
      @@@@: LSFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: LSAsyncFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: IFClsXDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|ManakaiDOMLatest
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@DOMMain:implementFeature:
      @@@@: LSExtendedFeature30
      @@@For: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:IF
    @@ISA:
      @@@@:
        ::ManakaiDOM:ManakaiDOM
      @@@For:
        ManakaiDOM:ManakaiDOM3
    @@For:
      ManakaiDOM:DOM3
    @@For:
      =ManakaiDOM:ManakaiDOM

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMMethod
    @@ForCheck:
      ManakaiDOM:DOM !=ManakaiDOM:ManakaiDOM

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMMethod
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMMethodParameter

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMMethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMAttribute
    @@ForCheck:
      ManakaiDOM:DOM !=ManakaiDOM:ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMAttrGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMAttrSet

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: ConstGroup
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ConstGroup
    @@ForCheck:
      ManakaiDOM:DOM !=ManakaiDOM:ManakaiDOM

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: 
      ManakaiDOM:Const
    @@ForCheck:
      ManakaiDOM:DOM !=ManakaiDOM:ManakaiDOM

ElementTypeBinding:
  @Name: XParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter
  @ShadowContent:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM
ElementTypeBinding:
  @Name: SubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionOrWarningSubType
    @@ForCheck:
      ManakaiDOM:ManakaiDOM
    @@ForCheck:
      ManakaiDOM:ForClass
    @@aliasChild:1
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:ManakaiDOMLatest
      @@@For:
        !ManakaiDOM:ManakaiDOM1

IFCls3Def:
  @IFQName: DOMImplementationLS
  @ClsQName: ManakaiDOMImplementationLS

  @ClsISA: DOMCore|ManakaiDOMImplementation

  @DOMMetaImpl:provideFeature: LSFeature30

  @DOMMain:implementFeature:
    @@@@: LSAsyncFeature30
    @@@For: ManakaiDOM|DOM3

  @enDesc:
    The <IF::DOMImplementationLS> interface contains factory methods
    for creating objects for load and save.

  @enDesc:
    @@ForCheck: ManakaiDOM|ForIF
    @@@:
      It is expected that an instance of the <IF::DOMImplementationLS> 
      interface can be obtained by using binding-specific casting 
      methods on an instance of the <IF::DOMCore|DOMImplementation>
      interface or by using the <M::DOMCore|DOMImplementation.getFeature>
      method with parameter values <Feature::LS> or <Feature::LS-Async>
      and <FeatureVer::3.0> respectively.
   
  @ConstGroup:
    @@IFQName: DOMImplementationLSMode
    @@ClsQName: ManakaiDOMImplementationLSMode
    @@PerlName: DOMImplementationLSMode

     @@rdfs:subClassOf:
       @@@@: DOMMain|unsigned-short||ManakaiDOM|all
       @@@ForCheck: ManakaiDOM|ForClass
     @@Type: DOMMain|unsigned-short||ManakaiDOM|all

     @@Description:
       @@@lang:en
       @@@@:The mode of the parser.
     @@Const:
        @@@Name:  MODE_SYNCHRONOUS
        @@@Value:  1
        @@@Description:
          @@@@lang:en
          @@@@@: 
            Create an synchronous <IF::LSParser>.
     @@Const:
        @@@Name:  MODE_ASYNCHRONOUS
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@: 
            Create an asynchronous <IF::LSParser>.
  @Method:
     @@Name:  createLSParser
     @@Description:
       @@@lang:en
       @@@@:
         Create a new parser object.
     @@Param:
        @@@Name:  mode
        @@@Type: 
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@actualType: DOMImplementationLSMode
        @@@InCase:
          @@@@Label:
            <XC::MODE_SYNCHRONOUS>
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF::LSParser> created will operate in synchronous mode.
        @@@InCase:
          @@@@Label:
            <XC::MODE_ASYNCHRONOUS>
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF::LSParser> created will operate in asynchronous mode.
     @@Param:
        @@@Name:  schemaType
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          DOMMain:ManakaiDOMSchemaType
        @@@Description:
          @@@@lang:en
          @@@@@:
            An absolute URI representing the type of the schema language 
            used during the load of a <IF::DOMCore:Document> using the newly 
            created <IF::LSParser>.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF::LSParser> will be free to use any schema found.
     @@Return:
        @@@Type:  LSParser
        @@@Description:
          @@@@lang:en
          @@@@@:
            The newly created parser object.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            By default, the parameter <DOM::error-handler> of the 
            <A::LSParser.domConfig> is <DOM::null>.  However, 
            the DOM implementation may provide a default error handler instead.
        @@@ManakaiDOM:raises:
          @@@@@: ManakaiDOMLS|MDOMLS_IMPL_NOSUPPORT_MODE
          @@@@enDesc: The requested mode is not supported.
        @@@ManakaiDOM:raises:
          @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_SCHEMA
          @@@@enDesc: The requested schema language is not supported.

  @Method:
     @@Name:  createLSSerializer
     @@Description:
       @@@lang:en
       @@@@:
         Create a new serializer object.
     @@Return:
        @@@Type:  LSSerializer
        @@@Description:
          @@@@lang:en
          @@@@@:
            The newly created serializer object.
  @Method:
     @@Name:  createLSInput
     @@Description:
       @@@lang:en
       @@@@:
         Create a new empty input source object.
     @@Return:
        @@@Type:  LSInput
        @@@actualType: ManakaiDOMLSInput
        @@@Description:
          @@@@lang:en
          @@@@@: The newly created input object.
        @@@PerlDef:
          $r = <ClassM::ManakaiDOMLSInput.new>;
  @Method:
     @@Name:  createLSOutput
     @@Description:
       @@@lang:en
       @@@@: Create a new empty output destination object.
     @@Return:
        @@@Type:  LSOutput
        @@@actualType: ManakaiDOMLSOutput
        @@@Description:
          @@@@lang:en
          @@@@@: The newly created output object.
       @@@PerlDef:
         $r = <ClassM::ManakaiDOMLSOutput.new>;
##DOMImplementationLS

ElementTypeBinding:
  @Name: PerlName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType: lang|Perl
    @@For: ManakaiDOM|Perl

FeatureDef:
  @QName: LSExtendedFeature
  @FeatureVerDef:
    @@QName: LSExtendedFeature30
    @@DOMMetaImpl:instanceFeatureOf: LSExtendedFeature
    @@featureQName: DOMLS|LS
    @@Version: 3.0
    @@enDesc:
      The <IF::DOMImplementationLSExtended
             ::ManakaiDOM:ManakaiDOMLatest> interface.

IFClsXDef:
  @IFQName: DOMImplementationLSExtended
  @ClsQName: ManakaiDOMImplementationLSExtended

  @IFISA: DOMImplementationLS
  @ClsISA: ManakaiDOMImplementationLS

  @DOMMetaImpl:provideFeature: LSExtendedFeature30

  @enDesc:
    The <IF::DOMImplementationLSExtended> interface provides
    factory methods taking <TYPE::DOMFeatures|FeaturesString>
    as a parameter to specify desired features that should be
    implemented by parser or serializer.

  @enDesc:
    @@ForCheck: ManakaiDOM|ForIF
    @@@:
      It is expected that an instance of the <IF::DOMImplementationLSExtended>
      interface can be obtained by using binding-specific casting
      methods on an instance of the <IF::DOMCore|DOMImplementation>
      interface or by using the <M::DOMCore|DOMImplementation.getFeature>
      method with parameter values <Feature::DOMLS|LS> and
      <FeatureVer::3.0> respectively.

  @Method:
    @@Name: createMLSParser
    @@enDesc:
      Creates a parser.  It may or may not implement 
      the <IF::LSParser> interface, may or may not support parsing
      of XML entities and may or may not 
      support generation of <IF::DOMCore:Node> objects.  In other word,
      this method may create any object whose class 
      has the semantics of some kind of <QUOTE::parsing>.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@actualType: ManakaiDOM|ManakaiDOMFeatures
      @@@enDesc:
        A list of features that must be supported by 
        the object returned.
        \
        {NOTE:: The <CHAR::PLUS SIGN> prefix is reserved for possible
                future use and must not be used
                in this parameter value. 
        \
        }
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        The newly created parser object, which supports
        the features requested by the <P::features> parameter.
      @@@RaiseException:
        @@@@@: DOMCore|FEATURE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          No parser implementation found that supports 
          all of the requested features.
      @@@PerlDef:
            CLS: for my $class (grep {
              $Message::DOM::DOMLS::ParserClass{$_}
            } keys %Message::DOM::DOMLS::ParserClass) {
              for my $fname (keys %$features) {
                my $fkey = $fname;
                #my $plus = $fname =~ s/^\+// ? t rue : f alse;
                FVER: for my $fver (grep {$features->{$fkey}->{$_}}
                                       keys %{$features->{$fkey}}) {
                  if ($Message::DOM::ClassFeature{$class}->{$fname}->{$fver}) {
                    next FVER; # Feature/version found
                  }
                  next CLS; # Not found
                } # FVER
              } # FNAME

              ## Class found
              $r = $class->new ($self, $features);
              last CLS;    ## NOTE: Method name directly written
            } # CLS


  @Method:
    @@Name: createMLSSerializer
    @@enDesc:
      Creates a serializer.  It may or may not implement 
      the <IF::LSSerializer> interface, may or may not support serialization
      of <IF::DOMCore:Node> objects and may or may not 
      support serialization as XML entities.  In other word, 
      this method may create any object whose class 
      has the semantics of some kind of <QUOTE::serialization>.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@actualType: ManakaiDOM|ManakaiDOMFeatures
      @@@enDesc:
        A list of features that must be supported by 
        the object returned.
        \
        {NOTE:: The <CHAR::PLUS SIGN> prefix is reserved for possible
                future use and must not be used
                in this parameter value. 
        \
        }
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        The newly created serializer object, which supports
        the features requested by the <P::features> parameter.
      @@@RaiseException:
        @@@@@: DOMCore|FEATURE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          No serializer implementation found that supports 
          all of the requested features.
      @@@PerlDef:
            CLS: for my $class (grep {
              $Message::DOM::DOMLS::SerializerClass{$_}
            } keys %Message::DOM::DOMLS::SerializerClass) {
              for my $fname (keys %$features) {
                my $fkey = $fname;
                #my $plus = $fname =~ s/^\+// ? t rue : f alse;
                FVER: for my $fver (grep {$features->{$fkey}->{$_}}
                                       keys %{$features->{$fkey}}) {
                  if ($Message::DOM::ClassFeature{$class}->{$fname}->{$fver}) {
                    next FVER; # Feature/version found
                  }
                  next CLS; # Not found
                } # FVER
              } # FNAME

              ## Class found
              $r = $class->new ($self, $features);
              last CLS;    ## NOTE: Method name directly written
            } # CLS
##DOMImplementationLSExtended

ResourceDef:
  @QName: ParserRole
  @rdf:type: DISLang|Role
  @ForCheck: ManakaiDOM|all
  @enDesc:
    Classes playing this role are parsers and 
    may be instantiated via the <M::ManakaiDOMImplementationLSExtended
    .createMLSParser> method.

ResourceDef:
  @QName: SerializerRole
  @rdf:type: DISLang|Role
  @ForCheck: ManakaiDOM|all
  @enDesc:
    Classes playing this role are serializers and 
    may be instantiated via the <M::ManakaiDOMImplementationLSExtended
    .createMLSSerializer> method.

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

IFDef:
  @Name:
    @@@: LSParser

  @For:
    ManakaiDOM:DOM3

  @DISLang:role: ParserRole

  @Description:
    @@lang:en
    @@@:
      An interface to an object that is able to build or augment 
      a DOM tree from various input sources.
  @ImplNote:
    @@lang:en
    @@@:
      {P:: When a document is first made available via the <IF::LSParser>, 
      \
      - there will never be two adjacent <IF::Text> nodes.
      \
      - there will never be empty text nodes.
      \
      {LI:: it is expected that <A::DOMCore:Attr.value> initially return XML 1.0 
            normalized value.
      \
        - If the parameter <CP::validate-if-schema> and 
          <CP::datatype-normalization> are set to <DOM::true>, 
          depending on the attribute normalization used, the 
          attribute values may differ from the ones by XML 1.0.
      \
        - If the parameter <CP::datatype-normalization> is set to <DOM::false>, 
          the XML 1.0 attribute normalization is guaranteed to occur.
      \
      }
      \
      }
  @ImplNote:
    @@lang:en
    @@@:
      Asynchronous <IF::LSParser> are expected to also implement 
      <IF::EventTarget> so that event listeners can be registered.
      \
      {FIG:: Events supported by asyncronous <IF::LSParser> objects
      \
        - <EV::LSEV:load>:: The <IF::LSParser> finishes to load the document.
                      (<IF::LSLoadEvent>)
      \
        - <EV::LSEV:progress>:: The <IF::LSParser> signals progress as 
                          data is parsed.  When <EV::LSEV:progress> should be 
                          dispatched is implementation dependent. 
                          The DOM implementation can choose not to 
                          dispatch at all. (<IF::LSProgressEvent>)
      }
  @Attr:
     @@Name:  domConfig
     @@Description:
       @@@lang:en
       @@@@:
         The configuration object used when parsing an input source. 
       \
         Note that this configuration is specific to the parse 
         operation.  No parameter values from this 
         configuration object are passed automatically to the 
         configuration object on the <IF::DOMCore:Document> that is created, or 
         used, by the parse operation.
     @@Get:
        @@@Type:  DOMConfiguration
  @Attr:
     @@Name:  filter
     @@Get:
        @@@Type:  LSParserFilter
     @@Set:
        @@@Type:  LSParserFilter
  @Attr:
     @@Name:  async
     @@Get:
        @@@Type:
           DOMMain:boolean||ManakaiDOM|all
        @@@InCase:
           @@@@Value:  true
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               This <IF::LSParser> is in asynchronous mode.
        @@@InCase:
           @@@@Value:  false
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               This <IF::LSParser> is in synchronous mode.
  @Attr:
     @@Name:  busy
     @@Get:
        @@@Type:
           DOMMain:boolean||ManakaiDOM|all
        @@@InCase:
           @@@@Value:  true
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               This <IF::LSParser> is currently busy loading a document.
        @@@InCase:
           @@@@Value:  false
           @@@@Description:
             @@@@@lang:en
             @@@@@@: Otherwise.
  @Method:
     @@Name:  parse
     @@Description:
       @@@lang:en
       @@@@:
         Parse an XML document from a resource identified by a 
         <IF::LSInput>.
     @@Param:
        @@@Name:  input
        @@@Type:  LSInput
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::LSInput> object from which the source of 
            the document is to be read.
     @@Return:
        @@@Type:  Document
        @@@Description:
          @@@@lang:en
          @@@@@:
            The newly created and populated <IF::DOMCore:Document>.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF::LSParser> is asynchronous.
        @@@ManakaiDOM:raises:
          @@@@@: ManakaiDOMLS|MDOMLS_BUSY
          @@@@enDesc:
            <A::LSParser.busy> is <DOM::true>.
        @@@ManakaiDOM:raises:
          @@@@@: LSException.PARSE_ERR
          @@@@enDesc:
            The <IF::LSParser> was unable to load the XML document. 
           @@@@ImplNote:
             @@@@@lang:en
             @@@@@@:
               DOM applications should use an error handler to get 
               details on the error.
  @Method:
     @@Name:  parseURI
     @@Description:
       @@@lang:en
       @@@@:
         Parse an XML document from a location identified by a 
         URI reference <SRC::<CITE::RFC 2396>>.
     @@Param:
        @@@Name:  uri
        @@@Type:  DOMString
        @@@actualType:
          DOMMain:RFC2396URIReference
        @@@Description:
          @@@@lang:en
          @@@@@:
            The location of the XML document to be read, 
            as a URI reference <SRC::<CITE::RFC 2396>>.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: URI reference with a fragemnt identifier
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The behavior is undefined; it may be defined in future 
              version of the DOM specification.
     @@Return:
        @@@Type:  Document
        @@@Description:
          @@@@lang:en
          @@@@@:
            The newly created and populated <IF::DOMCore:Document>.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF::LSParser> is asynchronous.
        @@@ManakaiDOM:raises:
          @@@@@:
            ManakaiDOMLS:MDOMLS_BUSY
          @@@@enDesc:
            <A::LSParser.busy> is <DOM::true>.
        @@@ManakaiDOM:raises:
          @@@@@: LSException.PARSE_ERR
          @@@@enDesc:
            The <IF::LSParser> was unable to load the XML document. 
           @@@@ImplNote:
             @@@@@lang:en
             @@@@@@:
               DOM applications should use an error handler to get 
               details on the error.
  @ConstGroup:
     @@QName:  
       @@@@: ACTION_TYPES

     @@rdfs:subClassOf:
       @@@@:
         DOMMain:unsigned-short||ManakaiDOM|all
       @@@ForCheck:
         ManakaiDOM:ForClass
     @@Type: DOMMain|unsigned-short||ManakaiDOM|all

     @@Description:
       @@@lang:en
       @@@@:
         A set of possible actions for the <M::LSParser.parseWithContext>.

     @@Const:
        @@@Name:  ACTION_APPEND_AS_CHILDREN
        @@@Value:  1
     @@Const:
        @@@Name:  ACTION_REPLACE_CHILDREN
        @@@Value:  2
     @@Const:
        @@@Name:  ACTION_INSERT_BEFORE
        @@@Value:  3
     @@Const:
        @@@Name:  ACTION_INSERT_AFTER
        @@@Value:  4
     @@Const:
        @@@Name:  ACTION_REPLACE
        @@@Value:  5

  @Method:
     @@Name:  parseWithContext
     @@Param:
        @@@Name:  input
        @@@Type:  LSInput
     @@Param:
        @@@Name:  contextArg
        @@@Type:  Node
     @@Param:
        @@@Name:  action
        @@@Type:
           DOMMain:unsigned-short||ManakaiDOM|all
     @@Return:
        @@@Type:  Node
        @@@ImplNote:
           DOMCore:DOMException.***_ERR
        @@@ImplNote:
           LSException.***_ERR
  @Method:
     @@Name:  abort
     @@Description:
       @@@lang:en
       @@@@:
         Abort the loading of the document that is currently being 
         loaded by this <IF::LSParser>.
       \
         If the <IF::LSParser> is currently not busy, this method does nothing.
     @@Return: 
##LSParser

IFCls3Def:
  @IFQName: LSInput
  @ClsQName: ManakaiDOMLSInput

  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @DOMMain:implementFeature: LSAsyncFeature30

  @Description:
    @@lang:en
    @@@:
      An input source for data.
      \
    \  <IF::LSInput> objects belong to DOM applications and the 
      DOM implementation will never modify them.
    \
      With this interface, a DOM application is able to encapsulate 
      information about an input source in a single document, which 
      may include a public identifier, a system identifier, 
      a byte stream, a base URI and/or a character stream.
    \
      The DOM application can either provide its own objects that 
      implement this interface or it can use the generic factor 
      method <M::DOMImplementationLS.createLSInput> to create 
      objects that implement this interface.
    \
      {P:: The <IF::LSParser> will use the <IF::LSInput> object to 
      determine how to read data.  The first one, in the following 
      order, that is not <DOM::null> and not an empty string will be used:
      \
      = <A::LSInput.characterStream>
      \
      = <A::LSInput.byteStream>
      \
      = <A::LSInput.stringData>
      \
      = <A::LSInput.systemId>
      \
      = <A::LSInput.publicId>
      \
      }
      \
      If all inputs are <DOM::null>, the <IF::LSParser> will report a 
      <IF::DOMError> (<ERR::no-input-specified>).
  @ImplNote:
    @@lang:en
    @@@: The DOM implementation may make copies and modify it if necessary.
  @ImplNote:
    @@lang:en
    @@@:
      The exact definitions of a byte stream and a character stream
      are binding dependent.
  @ImplNote:
    @@lang:en
    @@@:
      Properties available:
      <Q::infoset:publicIdentifier>, <Q::infoset:systemIdentifier>, 
      <Q::infoset:baseURI>, <Q::infoset:characterEncodingScheme>, 
      <Q::DOMLS:certifiedText>, <Q::DOMLS:stringData>.
      
  @Attr:
     @@Name:  characterStream
     @@Description:
       @@@lang:en
       @@@@:
         A sream of 16-bit units.
       \
         The document in the stream need not have an XML declaration. 
         If an XML declaration is present, the <XA::encoding> 
         declaration will be ignored.
       \
         Depending on the binding in use, this attribute may not be
         available.
     @@Get:
        @@@Type:  LSReader
        @@@PerlDef:
          $r = $self->{character_stream};
     @@Set:
        @@@Type:  LSReader
        @@@PerlDef:
          $self->{character_stream} = $given;
  @Attr:
     @@Name:  byteStream
     @@Description:
       @@@lang:en
       @@@@:
         A stream of bytes.
     @@Get:
        @@@Type:  LSInputStream
        @@@PerlDef:
          $r = $self->{byte_stream};
     @@Set:
        @@@Type:  LSInputStream
        @@@PerlDef:
          $self->{byte_stream} = $given;
  @Attr:
     @@Name:  stringData
     @@Description:
       @@@lang:en
       @@@@:
         String data to parse.
       \
         The document in the data need not have an XML declaration. 
         If an XML declaration is present, the <XA::encoding> 
         declaration will be ignored.
     @@Type:  
       DOMMain:DOMString
     @@actualType:
       DOMMain:ManakaiDOMString
     @@Get:
       @@@PerlDef:
         $r = ref $self->{string_data} eq 'SCALAR'
                ? ${$self->{string_data}} : $self->{string_data};
     @@Set:
       @@@InCase:
         @@@@Type:
           Perl:SCALAR::ManakaiDOM:all
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             The value referred from the given value is set to the new 
             attribute value.
         @@@@For:
           ManakaiDOM:ManakaiDOM
       @@@PerlDef:
         $self->{string_data} = ref $given eq 'SCALAR' ? $given : \$given;
  @Attr:
     @@Name:  systemId
     @@Description:
       @@@lang:en
       @@@@:
         The system identifier or a URI reference <SRC::<CITE::RFC 2396>> 
         for this input source.
       \
         Even if other input source is specified, this is still 
         useful to resolve any relative URIs or to include it 
         in error messages and warnings.
       \
         If the specified system identifier is a relative URI reference, 
         the DOM implementation will attempt to resolve the relative URI 
         with the <A::.baseURI>.  If that fails, the behavior is 
         implementation dependent.
     @@Type:
       DOMMain:DOMString
     @@actualType:
       DOMMain:SystemID||ManakaiDOM|all
     @@Get:
        @@@PerlDef:
          $r = $self->{system_id};
     @@Set:
        @@@PerlDef:
          $self->{system_id} = $given;
  @Attr:
     @@Name:  publicId
     @@Description:
        @@@lang:en
        @@@@:
          The public identifier for this input source.
         \
          This may be mapped to an input source using a DOM implementation 
          dependent mechanism.
     @@Type:
       DOMMain:DOMString
     @@actualType:
       DOMMain:PublicID::ManakaiDOM:all
     @@Get:
        @@@PerlDef:
          $r = $self->{public_id};
     @@Set:
        @@@PerlDef:
          $self->{public_id} = $self;
  @Attr:
     @@Name:  baseURI
     @@Description:
       @@@lang:en
       @@@@:
         The base URI to be used for resolving a relative 
         <P::systemId> to an absolute URI.
        \
         If, when used, the base URI is a relative URI, including 
         empty string, or <DOM::null>, the behavior is implementation 
         dependent.
     @@Type:
       DOMMain:DOMString
     @@actualType:
       ManakaiDOM:ManakaiDOMURI
     @@Get:
       @@@PerlDef:
         $r = $self->{base_uri};
     @@Set:
       @@@PerlDef:
         if (not defined $given) {
           __WARNING{
             MDOMX:NULL_BASE_URI::
           }__;
         } elsif (<Code::DOMMain:isRelativeDOMURI:: $INPUT = $given>) {
           __WARNING{
             MDOMX:RELATIVE_BASE_URI::
               infoset:baseURI => {$given},
           }__;
         }
         $self->{base_uri} = $given;
  @Attr:
     @@Name:  encoding
     @@Description:
       @@@lang:en
       @@@@:
         The character encoding, if known.
        \
         This attribute has no effect when the DOM application provides 
         a character stream or string data.  For other sources, 
         the <A::.encoding> will override any encoding specified in the 
         XML or text declaration or higher level protocol.
     @@Type:
       DOMMain:DOMString
     @@Get:
        @@@PerlDef:
          $r = $self->{encoding};
     @@Set:
        @@@Description:
          @@@@lang:en
          @@@@@:
            The encoding name acceptable for an XML 1.0 <XA::encoding> 
            declaration <SRC::<CITE::XML 1.0> 4.3.3 Character Encoding in 
            Entities>.
        @@@PerlDef:
          $self->{encoding} = $given;
  @Attr:
     @@Name:  certifiedText
     @@Get:
        @@@Type:
           DOMMain:boolean||ManakaiDOM|all
        @@@InCase:
           @@@@Value:  true
        @@@InCase:
           @@@@Value:  false
        @@@PerlDef:
          $r = $self->{certified_text};
     @@Set:
        @@@Type:
           DOMMain:boolean||ManakaiDOM|all
        @@@InCase:
           @@@@Value:  true
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               Assume that the input is certified 
               <SRC::<CITE::XML 1.1> 2.13 Normalization Checking> when 
               parsing an XML 1.1 document.
        @@@InCase:
           @@@@Value:  false
        @@@PerlDef:
          $self->{certified_text} = $given;

  @IntMethod:
    @@Name:new
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Construct a new instance of the <IF::LSInput>.
    @@Return:
      @@@Type:ManakaiDOMLSInput
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created <IF::LSInput> object.
      @@@PerlDef:
        $r = bless {}, $self;

  @Description:
    @@lang:en
    @@@:
      In the manakai DOM implementation, an unblessed hash reference 
      is also able to be passed as a <IF::LSInput> method parameter. 
      The reference can have eight keys: <A::characterStream>, 
      <A::byteStream>, <A::stringData>, <A::encoding>, <A::certifiedText>, 
      <A::baseURI>, <A::publicId>, <A::systemId>. They can have the 
      same type of data as the methods in the <IF::LSInput> interface, 
      with an exception of <A::stringData>, whose value should be 
      a reference to a scalar string value (it is not just a string
      value for efficient). 
    @@ForCheck:
      ManakaiDOM:ManakaiDOM

  @ResourceDef:
    @@rdf:type: DISLang|InputProcessor
    @@ForCheck: ManakaiDOM|ManakaiDOM3
    @@PerlDef:
      if (ref $INPUT eq 'HASH') {
        $INPUT = bless $INPUT, <ClassName::DOMLS:ManakaiDOMLSInput>;
      }
  @ResourceDef:
    @@rdf:type: DISLang|InputProcessor
    @@ForCheck: ManakaiDOM|ManakaiDOM !ManakaiDOM|ManakaiDOM3
    @@PerlDef:
      if (ref $INPUT eq 'HASH') {
        $INPUT = bless $INPUT, 
              <ClassName::DOMLS:ManakaiDOMLSInput::ManakaiDOM:ManakaiDOMLatest>;
      }
##LSInput

IFDef:
  @Name:  LSResourceResolver
  @Description:
    @@lang:en
    @@@:
      Resolve references to external resources when parsing.
  @Method:
     @@Name:  resolveResource
     @@Param:
        @@@Name:  type
        @@@Type:  DOMString
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  publicId
        @@@Type:  DOMString
     @@Param:
        @@@Name:  systemId
        @@@Type:  DOMString
     @@Param:
        @@@Name:  baseURI
        @@@Type:  DOMString
     @@Return:
        @@@Type:  LSInput

IFDef:
  @Name:  LSParserFilter
  @Description:
    @@lang:en
    @@@:
      Examine and remove nodes as they are being processed while parsing.
  @ConstGroup:
     @@FullName:
        @@@@:
        Constants returned by startElement and acceptNode
        @@@lang:  en
     @@Type:
        DOMMain:short||ManakaiDOM|all
     @@rdfs:subClassOf:
       @@@@: DOMMain|short||ManakaiDOM|all
       @@@ForCheck: ManakaiDOM|ForClass
     @@Const:
        @@@Name:  FILTER_ACCEPT
        @@@Type:
           DOMMain:short
        @@@Value:  1
     @@Const:
        @@@Name:  FILTER_REJECT
        @@@Type:
           DOMMain:short
        @@@Value:  2
     @@Const:
        @@@Name:  FILTER_SKIP
        @@@Type:
           DOMMain:short
        @@@Value:  3
     @@Const:
        @@@Name:  FILTER_INTERRUPT
        @@@Type:
           DOMMain:short
        @@@Value:  4
  @Method:
     @@Name:  startElement
     @@Param:
        @@@Name:  elementArg
        @@@Type:  Element
     @@Return:
        @@@Type:
           DOMMain:unsigned-short||ManakaiDOM|all
  @Method:
     @@Name:  acceptNode
     @@Param:
        @@@Name:  nodeArg
        @@@Type:  Node
     @@Return:
        @@@Type:
           DOMMain:unsigned-short||ManakaiDOM|all
  @Attr:
     @@Name:  whatToShow
     @@Get:
        @@@Type:
           DOMMain:unsigned-long||ManakaiDOM|all

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property

IFClsXDef:
  @IFQName: SimpleXMLSerializer
  @ClsQName: ManakaiDOMSimpleXMLSerializer

  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @enDesc:
    A simple XML serializer that only (or at least) supports
    document instance constructions such as elements and attributes.

  @DISLang:role: SerializerRole

  @DOMMain:implementFeature: SerializeDocumentInstance10

  @Method:
    @@Operator:
      @@@@:DISPerl|NewMethod
      @@@ContentType: dis|TypeQName
    @@Return:
      @@@Type: ManakaiDOMSimpleXMLSerializer
      @@@enDesc: Newly created serializer.
      @@@PerlDef:
        $r = <ClassName::ManakaiDOMSimpleXMLSerializer>;

  @Method:
    @@Name: writeToString
    @@enDesc:
      Serializes a document as an XML document entity.
    @@Param:
      @@@Name: nodeArg
      @@@Type: Node
      @@@actualType: 
        DOMCore:ManakaiDOMDocument::ManakaiDOM:ManakaiDOMLatest
      @@@enDesc:
        The document node to serialize.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        An XML document entity string created from <P::nodeArg>.
        \
        {NOTE:: This string might not namespace well-formed
                (or even well-formed) if the original <P::nodeArg>
                contains ill-formed information property,
                e.g. illegal element type name.
        \
        }
      @@@PerlDef:
        my @src = ($nodeArg->{<Q::TreeCore:node>});
        my $nsbind = [{'' => '', xml => <Q::xml:>, xmlns => <Q::undef:>}];
        my $xescape = sub ($) {
          my $s = shift;
          $s =~ s/&/&amp;/g;
          $s =~ s/</&lt;/g;
          $s =~ s/>/&gt;/g;
          $s =~ s/"/&quot;/g;
          return $s;
        };
        while (my $src = shift @src) {
          if (ref $src eq 'ARRAY') {
            pop @$nsbind;  ## End tag
          } elsif (ref $src) {
            if ($src->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
              my @csrc;
              my $etag;
              push @$nsbind, my $ns = {%{$nsbind->[-1]}};
              my %attrr;

              ## Non-namespace attributes
              for my $ao (values %{$src->{<Q::infoset:attributes>}
                                       ->{<Q::ManakaiDOM:noNS>}||{}}) {
                $attrr{$ao->{<Q::DOMCore:name>}}
                      = [@{$ao->{<Q::infoset:children>}}];
              }

              ## Namespace attributes
              for my $xmlnso (values %{$src->{<Q::infoset:attributes>}
                                           ->{<Q::xmlns:>}||{}}) {
                my $xmlns;
                __CODE{ManakaiNode:getWeakReference||ManakaiDOM:Perl::
                  $object => $xmlnso, $ref => $xmlns,
                  $class => {<ClassName::DOMCore:ManakaiDOMAttr>},
                }__;
                my $nsuri = $xmlns-><AG::DOMCore:Attr.value>;
                if ($xmlnso->{<Q::infoset:localName>} eq 'xmlns') {
                  $ns->{''} = $nsuri;
                  $attrr{'xmlns'} = [@{$xmlnso->{<Q::infoset:children>}}];
                } else {
                  if (length $nsuri) {
                    $ns->{$xmlnso->{<Q::infoset:localName>}} = $nsuri;
                  } else {
                    $ns->{$xmlnso->{<Q::infoset:localName>}} = <Q::undef:>;
                  }
                  $attrr{'xmlns:'.$xmlnso->{<Q::infoset:localName>}}
                                  = [@{$xmlnso->{<Q::infoset:children>}}];
                }
              }

              ## Per-element partition attributes
              for my $ano (values %{$src->{<Q::infoset:attributes>}
                                        ->{<Q::null:>}||{}}) {
                $attrr{$ano->{<Q::infoset:localName>}}
                                  = [@{$ano->{<Q::infoset:children>}}];
              }

              ## Global partition attributes
              for my $ans (keys %{$src->{<Q::infoset:attributes>}}) {
                next if $ans eq <Q::xmlns:>;
                next if $ans eq <Q::null:>;
                next if $ans eq <Q::ManakaiDOM:noNS>;
                my $defpfx;
                my $ansao = [];
                for my $ao (values %{$src->{<Q::infoset:attributes>}
                                         ->{$ans}||{}}) {
                  my $pfx;
                  PFX: {
                    if (defined $ao->{<Q::infoset:prefix>}) {
                      if (defined $ns->{$ao->{<Q::infoset:prefix>}}) {
                        if ($ns->{$ao->{<Q::infoset:prefix>}} eq $ans) {
                          ## Namespace already defined
                          $defpfx ||= $pfx = $ao->{<Q::infoset:prefix>};
                          last PFX;
                        }
                      } else {
                        ## Namespace prefix not defined yet
                        $defpfx ||= $pfx = $ao->{<Q::infoset:prefix>};
                        $ns->{$pfx} = $ans;
                        $attrr{'xmlns:'.$pfx} = [$xescape->($ans)];
                        last PFX;
                      }
                    }
                    if (defined $defpfx) {
                      $pfx = $defpfx;
                      last PFX;
                    }
                  } # PFX
                  push @$ansao, [$pfx, $ao];
                }
                next unless @$ansao;  ## No attribute in this namespace.

                PFX: {
                  last PFX if defined $defpfx;

                  ## No prefix available from attribute nodes

                  ## Available from already defined namespaces?
                  for my $pfx (keys %$ns) {
                    next unless $ns->{$pfx} eq $ans;
                    if (length $pfx) {
                      $defpfx = $pfx;
                      last;
                    }
                  }
                  last PFX if defined $defpfx;

                  ## Available from element itself?
                  if (defined $src->{<Q::infoset:namespaceName>} and
                      $src->{<Q::infoset:namespaceName>} eq $ans and
                      defined $src->{<Q::infoset:prefix>}) {
                    if (defined $ns->{$src->{<Q::infoset:prefix>}}) {
                      if ($ns->{$src->{<Q::infoset:prefix>}} eq $ans) {
                        ## Namespace already defined
                        $defpfx = $src->{<Q::infoset:prefix>};
                        last PFX;
                      }
                    } else {
                      ## Namespace not defined yet
                      $defpfx = $src->{<Q::infoset:prefix>};
                      $ns->{$defpfx} = $ans;
                      $attrr{'xmlns:'.$defpfx} = [$xescape->($ans)];
                      last PFX;
                    }
                  }

                  ## Prefix is not defined anywhere
                  my $i = 1;
                  $i++ while (exists $ns->{'ns'.$i});
                  $ns->{$defpfx = 'ns'.$i} = $ans;
                  $attrr{'xmlns:ns'.$i} = [$xescape->($ans)];
                } # PFX

                for my $ansno (@$ansao) {
                  $attrr{($ansno->[0] || $defpfx) . ':' .
                         $ansno->[1]->{<Q::infoset:localName>}}
                     = [@{$ansno->[1]->{<Q::infoset:children>}}];
                }
              }

              ## Element type name
              if (defined $src->{<Q::infoset:localName>}) {
                if (defined $src->{<Q::infoset:namespaceName>}) {
                  if (defined $src->{<Q::infoset:prefix>} and
                      defined $ns->{$src->{<Q::infoset:prefix>}} and
                      $ns->{$src->{<Q::infoset:prefix>}}
                         eq $src->{<Q::infoset:namespaceName>}) {
                    ## Non-NULL namespace and prefix is defined
                    $r .= '<' . $src->{<Q::infoset:prefix>} . ':'
                       .  $src->{<Q::infoset:localName>};
                    $etag = '</' . $src->{<Q::infoset:prefix>} . ':'
                       .  $src->{<Q::infoset:localName>} . '>';
                  } elsif (defined $src->{<Q::infoset:prefix>} and
                           not defined $ns->{$src->{<Q::infoset:prefix>}}) {
                    $attrr{'xmlns:'.$src->{<Q::infoset:prefix>}}
                      = [$xescape->($src->{<Q::infoset:namespaceName>})];
                    $ns->{$src->{<Q::infoset:prefix>}}
                      = $src->{<Q::infoset:namespaceName>};
                    $r .= '<' . $src->{<Q::infoset:prefix>} . ':'
                       .  $src->{<Q::infoset:localName>};
                    $etag = '</' . $src->{<Q::infoset:prefix>} . ':'
                       .  $src->{<Q::infoset:localName>} . '>';
                  } else {
                    PFX: {
                      ## Non-NULL namespace and prefix is not defined
                      ## but already declared as namespace attribute
                      for my $pfx (keys %$ns) {
                        next unless $ns->{$pfx}
                                      eq $src->{<Q::infoset:namespaceName>};
                        if (length $pfx) {
                          $r .= '<' . $pfx . ':'
                             .  $src->{<Q::infoset:localName>};
                          $etag = '</' . $pfx . ':'
                                .  $src->{<Q::infoset:localName>} . '>';
                        } else {
                          $r .= '<' . $src->{<Q::infoset:localName>};
                          $etag = '</' . $src->{<Q::infoset:localName>} . '>';
                        }
                        last PFX;
                      }

                      ## Non-NULL namespace and prefix is not defined anywhere
                      my $i = 1;
                      $i++ while (exists $ns->{'ns'.$i});
                      $ns->{'ns'.$i} = $src->{<Q::infoset:namespaceName>};
                      $attrr{'xmlns:ns'.$i} = [$xescape->($ns->{'ns'.$i})];
                      $r .= '<'.'ns' . $i . ':' . $src->{<Q::infoset:localName>};
                      $etag = '</ns'.$i.':'.$src->{<Q::infoset:localName>} . '>';
                    }
                  }
                } else {
                  ## Null-namespace
                  unless ($ns->{''} eq '') {
                    ## Default namespace is not the NULL-namespace
                    $ns->{''} = '';
                    $attrr{'xmlns'} = [''];
                  }
                  $r .= '<' . $src->{<Q::infoset:localName>};
                  $etag = '</' . $src->{<Q::infoset:localName>} . '>';
                }
              } else {
                ## Non-namespace node
                $r .= '<' . $src->{<Q::DOMCore:name>};
                $etag = '</' . $src->{<Q::DOMCore:name>} . '>';
              }
              
              ## Attribute specifications
              for my $an (sort keys %attrr) {
                push @csrc, ' ' . $an . '="', @{$attrr{$an}}, '"';
              }

              ## Children
              if (@{$src->{<Q::infoset:children>}}) {
                push @csrc, '>', @{$src->{<Q::infoset:children>}}, $etag, [];
              } elsif ($src->{<Q::ManakaiDOMLS2003:use_EmptyElemTag>}) {
                push @csrc, ' />';
                shift @$nsbind;
              } else {
                push @csrc, '>' . $etag, [];
              }
              unshift @src, @csrc;
            } elsif ($src->{<Q::DOMCore:nodeType>} eq <Q::DOMCore:Text>) {
              $r .= $xescape->($src->{<Q::infoset:content>});
            } elsif ($src->{<Q::DOMCore:nodeType>} eq <Q::DOMXML:CDATASection>) {
              my $text = $src->{<Q::infoset:content>};
              $text =~ s/]]>/]]]]>&gt;<![CDATA[/g;
              $r .= '<![CDATA[' . $text . ']]>';
            } elsif ($src->{<Q::DOMCore:nodeType>}
                        eq <Q::DOMXML:EntityReference>) {
              if ($src->{<Q::ManakaiDOM:isExpanded>}) {
                push @src, @{$src->{<Q::infoset:children>}};
              } else {
                $r .= '&' . $src->{<Q::DOMCore:name>} . ';';
              }
            } elsif ($src->{<Q::DOMCore:nodeType>}
                        eq <Q::infoset:ProcessingInstruction>) {
              $r .= '<?' . $src->{<Q::infoset:target>};
              if (defined $src->{<Q::infoset:content>} and
                  length $src->{<Q::infoset:content>}) {
                my $data = $src->{<Q::infoset:content>};
                $data =~ s/\?>/?&gt;/g;
                $r .= ' ' . $data;
              }
              $r .= '?>';
            } elsif ($src->{<Q::DOMCore:nodeType>} eq <Q::infoset:Comment>) {
              my $data = $src->{<Q::infoset:content>};
              $data =~ s/--/- - /g;
              $r .= '<!--' . $data . '-->';
            } elsif ($src->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
              unshift @src, map {$_, "\x0A"} @{$src->{<Q::infoset:children>}};
            }
          } else {
            $r .= $src;
          }
        }
##SimpleXMLSerializer

PropDef:
  @QName:
    ManakaiDOMLS2003:use_EmptyElemTag
  @enDesc:
    Whether the <CODE::EmptyElemTag> syntax should be used
    if the content of an element is empty or not.
  @Type:
    DOMMain:boolean::ManakaiDOM:all

FeatureDef:
  @QName: SerializeDocumentInstance
  @FeatureVerDef:
    @@QName: SerializeDocumentInstance10
    @@Version: 1.0
    @@DOMMetaImpl:instanceFeatureOf: SerializeDocumentInstance
    @@DOMMain:requireFeature: DOMXML|XMLVersionFeature10
    @@enDesc:
      {P:: To support this feature:
         \
         - the serializer class <RFC2119::MUST> implement the
           <IF::ManakaiDOMSimpleXMLSerializerIF>
           interface, i.e. it <RFC2119::MUST> have a 
           <M::ManakaiDOMSimpleXMLSerializerIF.writeToString> method.
         \
         - the <M::ManakaiDOMSimpleXMLSerializerIF.writeToString>
           method <RFC2119::MUST> accept a <IF::DOMCore:Document>
           node as its <P::nodeArg> parameter.  It <RFC2119::MAY>
           also accept other type of nodes as the parameter.
         \
         - the serialization <RFC2119::MUST> support the result
           being exact one parsed entity, i.e. a document entity without
           any external parsed entity reference. 
         \
         - the serializer <RFC2119::MUST> support the serialization
           of <IF::DOMCore:Element> nodes, <IF::DOMCore:Attr>
           nodes which support XML Namespaces and which are not
           namespace declaration attributes, and <IF::DOMCore:Text> nodes.
         \
         - the serializer <RFC2119::MUST> support the serialization
           of <IF::DOMXML:CDATASection> nodes, but it does not have
           to result in XML CDATA sections.  In other word, 
           the serializer <RFC2119::MAY> serialize a <IF::DOMXML:CDATASection>
           as a sequence of characters and/or character references.
         \
         - the serializer <RFC2119::MAY> ignore <IF::DOMXML:EntityReference>
           nodes and serialize their children if the <IF::DOMXML:EntityReference>
           nodes are expanded.  Otherwise, it <RFC2119::MUST> 
           serialize them as (unexpanded) general entity references. 
           If the serializer supports the serialization of 
           document type declarations, it <RFC2119::MAY> generate
           general entity declarations.
         \
         - the serialization <RFC2119::MAY> serialize 
           or ignore <IF::DOMCore:Comment>, <IF::DOMXML:ProcessingInstruction>,
           <IF::DOMXML:DocumentType>, <IF::DOMXML:Entity> and
           <IF::DOMXML:Notation> nodes.
         \
         - if the <A::DOMCore:Document.xmlVersion> has a non-<DOM::null>
           value and it is different from <XML::1.0>, then
           the serializer <RFC2119::MUST> output an XML declaration.
         \
         - if the serializer does not support the XML version
           as specified by the <A::DOMCore:Document.xmlVersion>,
           then the serializer <RFC2119::MAY> report an exception
           or error.
         \
         - the serializer <RFC2119::SHOULD> try to ensure
           the result is namespace well-formed.  It <RFC2119::MAY>
           omit strict error checking.  For example, the serializer
           don't have to test whether an element type name
           is a legal XML <CODE::Name>.
         \
       }


IFDef:
  @Name:  LSSerializer
  @Description:
    @@lang:en
    @@@:
      Serializing (writing) a DOM document or <IF::Node> out into XML. 
      \
      <IF::LSSerializer> accepts any type of node for serialization. 
      If the node is a <IF::DOMCore:Document> or <IF::DOMXML:Entity>,
      a well-formed XML document or external (respectively) entity will
      be created when possible.  For all other types, the serialized form 
      is implementation dependent.

  @DISLang:role: SerializerRole

  @ImplNote:
    @@lang:en
    @@@:
      The result XML data is written to a string or an output stream.
      Any changes and/or fixup's made during the serialization
      affect only the serialized data, not affecting the original data.
    \
      If a <A::DOMCore:Node.namespaceURI> is empty string, then 
      it will be treated as <DOM::null> and <A::DOMCore:Node.prefix>
      value is ignored.
    \
      The XML well-formedness of the result data is guaranted
      if the document or entity comes from a parse operation
      and has remained unchanged.

  @ImplNote:
    @@lang:en
    @@@:
      {P:: Within a <IF::DOMCore:Document>, <IF::DOMCore:DocumentFragment> or 
      <IF::DOMXML:Entity>:
      \
      - <IF::DOMCore:Document>:: The entire document is written, including the
        XML declaration (unless <CP::xml-declaration> is set to <DOM::false>) 
        and the document type declaration internal subset, if exists. 
      \
      - <IF::DOMXML:Entity>:: When written directly by <M::LSSerializer.write>, 
        the entity expansion is outputed without namespace fixup.
      \
      - <IF::DOMXML:EntityReference>:: If <CP::entities> is set to <DOM::true>
        or the node is not expanded, the node is serialized as an entity 
        reference.  Child nodes (the expansion) are ignored.  Otherwise, 
        child nodes are serialized.
      \
      - <IF::DOMXML:CDATASection>:: If the node contains characters 
        that cannot be represented in the specified output encoding 
        or contains <CODE::MDE> and <CP::split-cdata-sections> 
        is set to <DOM::true>, <IF::DOMXML:CDATASection> is split and 
        the unrepresentable characters are serialized as numeric 
        character references in ordinary <CODE::content>.  The exact 
        position and number of splits is not specified.  If 
        <DOM::false> and <CP::well-formed> is set to <DOM::true>, 
        unrepresented characters are reported as <ERR::wf-invalid-character> 
        (This error is unrecoverable).
        (What is happen if <CP::well-formed> is set to <DOM::false>?)
      \
      - <IF::DOMCore:DocumentFragment>:: Child nodes are serialized.
      \
      - Other types:: The node is serialized to their corresponding XML 
        form.
      \
      }
      \
      Within character data, any character that cannot be represented 
      directly are replaced with a reference.  Characters 
      <CHAR::LESS-THAN SIGN> and <CHAR::AMPASAND> are replaced by 
      the predefined entities <XML::&lt;> and <XML::&amp;> reprectively. 
      The other predefind entities might not be used except where 
      needed (e.g. <CODE::MSE>).  Any character that cannot be represented 
      directly in the output character encoding are serialized as 
      a numeric character reference (hexadecimal representation is 
      encouraged).
      \
      Within an attribute value, characters <CHAR::APOSTROPHE> and 
      <CHAR::QUOTATION MARK> may be represented by predefined entities 
      <XML::&apos;> and <XML::&quot> respectively.  New line characters 
      and other characters that cannot be represented directly in 
      the output character encoding are serialized as a numeric 
      character reference.
      \
      Within a markup but outside of attributes, any occurence of 
      a character that cannot be represented in the output character 
      encoding is reported as a fatal error (e.g. 
      <ERR::wf-invalid-character-in-node-name>).
      \
      When <CP::normalize-characters> on <IF::LSSerializer> is set to 
      <DOM::true>, character normalization is performed accopding 
      the XML 1.1 on all data to be serialized, both markups and 
      character data.
      \
      {P:: DOM implementations are required to support::
      \
      - <CODE::UTF-8>:: Whether <CHAR::BOM> is generated or not is 
                       implementation dependent.
      \
      - <CODE::UTF-16>:: Whether the output is big endian or little endian 
                        is implementation dependent.  <CHAR::BOM> is required.
      \
      - <CODE::UTF-16BE>:: <CHAR::BOM> is not generated.
      \
      - <CODE::UTF-16LE>:: <CHAR::BOM> is not generated.
      }
      \
      If <CHAR::BOM> is not generated, <ERR::byte-order-mark-needed> warning 
      is reported.
      \
      If the <XA::encoding> declaration is generated, it will be the 
      encoding name used during the serialization.
  
      
  @Attr:
     @@Name:  domConfig
     @@Description:
       @@@lang:en
       @@@@:
         The configuration object used when serializing a DOM node. 
     @@Get:
        @@@Type:  DOMConfiguration
  @Attr:
     @@Name:  newLine
     @@Description:
       @@@lang:en
       @@@@:
         The end-of-line character sequence to be used in the XML entity 
         being written out.  Although any string can be set, 
         other sequences than the ones specified by the XML specifications 
         can result in a document that is either not serializable 
         or not well-formed.
       \
         The default value of this attribute is implementation specific.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM implementation should choose the default to match 
         the usual convention for text files in the environment being used. 
         The DOM implementation must choose a default sequence 
         that is admited for XML 1.0 or XML 1.1, depending on the 
          serialized content.
     @@Get:
        @@@Type:  DOMString
     @@Set:
        @@@Type:  DOMString
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Reset to the default value.
  @Attr:
     @@Name:  filter
     @@Description:
       @@@lang:en
       @@@@:
         A filter that will be called out before serializing 
         each <IF::Node>.  The filter can choose to remove 
         the node from the stream or to terminate the serialization early.
      \
         Note that the filter is invoked after the operations 
         requested by configuration parameters have been applied.
     @@Get:
        @@@Type:  LSSerializerFilter
     @@Set:
        @@@Type:  LSSerializerFilter
  @Method:
     @@Name:  write
     @@Description:
       @@@lang:en
       @@@@:
         Serialize the specified node and write it out.
     @@ImplNote:
       @@@lang:en
       @@@@:
         {P:: The encoding is:
         \
           = <A::LSOutput.encoding>
         \
           = <A::DOMCore:Document.inputEncoding>
         \
           = <A::DOMCore:Document.xmlEncoding>
         \
           = <CODE::UTF-8>
         }
         If the specified encoding is not supported, the fatal error 
         <ERR::unsupported-encoding> is raised.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM implementation is responsible of associating the 
         appropriate media type with the serialized data.
       \
         When writing to an HTTP URI, the <CODE::PUT> method is performed. 
         For other URI schemes, the mechanism for writing the data is 
         implementation dependent.
     @@Param:
        @@@Name:  nodeArg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to serialize.
     @@Param:
        @@@Name:  destination
        @@@Type:  LSOutput
        @@@Description:
          @@@@lang:en
          @@@@@:
            The destination.
     @@Return:
        @@@Type:
           DOMMain:boolean||ManakaiDOM|all
        @@@InCase:
           @@@@Value:  true
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P::nodeArg> was successfully serialized.
        @@@InCase:
           @@@@Value:  false
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The normal processing was stopped but the DOM 
               implementation kept serializing the document; 
               the result of the serialization being 
               implementation dependent then.
        @@@ManakaiDOM:raises:
          @@@@@: LSException.SERIALIZE_ERR
          @@@@enDesc:
            The serializer was unable to serialize the node. 
           @@@@ImplNote:
             @@@@@lang:en
             @@@@@@:
               DOM applications should use error handler to get 
               details on the error.
## TODO:
#        @@@Error:
#          @@@@Name:unsupported-encoding
#          @@@@Severity:Fatal
#          @@@@Description:
#            @@@@@lang:en
#            @@@@@@:
#              The encoding specified explicitly or implicitly is 
#              not supported by the serializer.
#        @@@Error:
#          @@@@Name:no-output-specified
#          @@@@Severity:Fatal
#          @@@@Description:
#            @@@@@lang:en
#            @@@@@@:
#              No output is specified in the <P::destination>.
  @Method:
     @@Name:  writeToURI
     @@Description:
       @@@lang:en
       @@@@:
         Serialize the specified node and write it as the resource 
         specified by the URI.
     @@ImplNote:
       @@@lang:en
       @@@@:
         This is a convinience method; it acts as if <M::LSSerializer.write> 
         was called with a <IF::LSOutput> with no encoding specified 
         and <A::LSOutput.systemId> set to <P::uri>.
     @@Param:
        @@@Name:  nodeArg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:The node to serialize.
     @@Param:
        @@@Name:  uri
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@:The URI to write to.
     @@Return:
        @@@Type:
           DOMMain:boolean||ManakaiDOM|all
        @@@InCase:
           @@@@Value:  true
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P::nodeArg> was successfully serialized.
        @@@InCase:
           @@@@Value:  false
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The normal processing was stopped but the implementation 
               kept serializing the document; the result of the serialization 
               is implementation dependent then.
        @@@ManakaiDOM:raises:
          @@@@@: LSException.SERIALIZE_ERR
          @@@@enDesc:
            The serializer was unable to serialize the node.
  @Method:
     @@Name:  writeToString
     @@Description:
        @@@lang:en
        @@@@:
          Serialize the specified node and write it to a 
          <TYPE::DOMMain:DOMString>.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The encoding used is the encoding of the <TYPE::DOMMain:DOMString>, 
         i.e. <CODE::UTF-16>.  No <CHAR::BOM> is generated.
     @@Param:
        @@@Name:  nodeArg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to serialize.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The serialized data.
        @@@ManakaiDOM:raises:
          @@@@@: DOMCore|DOMException.DOMSTRING_SIZE_ERR
          @@@@enDesc:
            The resulting string is too long to fit in a
            <TYPE::DOMMain:DOMString>.
        @@@ManakaiDOM:raises:
          @@@@@: LSException.SERIALIZE_ERR
          @@@@enDesc:
            The serializer was unable to serialize the node.

IFCls3Def:
  @IFQName: LSOutput
  @ClsQName: ManakaiDOMLSOutput
  
  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @Description:
    @@lang:en
    @@@:
      An output destination for data.
     \
      With this interface, DOM applications are able to 
      encapsulate information about an output destination 
      in a single object.
     \
      The DOM application is expected to provide objects 
      that implement this interface whenever such object 
      are needed.  The DOM application can either provide 
      its own objects that implements this interface, 
      or it can use the generic factory method 
      <M::DOMImplementationLS.createLSOutput> to create 
      objects that implement this interface.
      \
      <IF::LSOutput> objects belong to the DOM application and 
      the DOM implementation will never modify them.
  @ImplNote:
    @@lang:en
    @@@:
      {P:: The <IF::LSSerializer> will use the <IF::LSOutput> object 
      in the following order:
      \
      = <A::LSOutput.characterStream>
      \
      = <A::LSOutput.byteStream>
      \
      = <A::LSOutput.systemId>
      \
      The first one that is not <DOM::null> and not an empty string 
      will be used.
      \
      }
  @ImplNote:
    @@lang:en
    @@@:
      The DOM implementation may make copies of the <IF::LSOutput> 
      objects and modify them, if necessary.
  @Attr:
     @@Name:  characterStream
     @@Description:
       @@@lang:en
       @@@@:
         A writable stream to which 16-bit units can be output.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The exact definition of a character stream is language 
         and binding dependent.  Depending on the binding in use, 
         this attribute may not be available.
     @@Get:
        @@@Type:  LSWriter
        @@@PerlDef:
          $r = $self->{characterStream};
     @@Set:
        @@@Type:  LSWriter
        @@@PerlDef:
          $self->{characterStream} = $given;
  @Attr:
     @@Name:  byteStream
     @@Description:
       @@@lang:en
       @@@@:
         A writable stream of bytes.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The exact definition of a byte stream is language and 
         binding dependent.
     @@Get:
        @@@Type:  LSOutputStream
        @@@PerlDef:
          $r = $self->{byteStream};
     @@Set:
        @@@Type:  LSOutputStream
        @@@PerlDef:
          $self->{byteStream} = $given;
  @Attr:
     @@Name:  systemId
     @@Description:
       @@@lang:en
       @@@@:
         The system identifier or an RFC 2396 URI reference 
         for this output destination.
     @@Type:
       DOMMain:DOMString
     @@actualType:
       DOMMain:SystemID||ManakaiDOM|all
     @@Get:
        @@@PerlDef:
          $r = $self->{systemId};
     @@Set:
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@:
              RFC 2396 Relative URI reference
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The behavior is implementation dependent.
        @@@PerlDef:
          if (<Code::DOMMain:isRelativeDOMURI:: $INPUT = $given>) {
            __WARNING{
              MDOMX:RELATIVE_URI::
                MDOMX:uri => {$given},
            }__;
          }
          $self->{systemId} = $given;
  @Attr:
     @@Name:  encoding
     @@Description:
       @@@lang:en
       @@@@:
         The character encoding to use for the output. 
         The encoding name must be a string acceptable for 
         an XML 1.0 <XA::encoding> declaration and it is 
         recommended that character encodings registered 
         in IANAREG be referred to using their registered names.
     @@Type:
       DOMMain:DOMString
     @@Get:
       @@@PerlDef:
         $r = $self->{encoding};
     @@Set:
       @@@PerlDef:
         $self->{encoding} = $given;

  @IntMethod:
    @@Name:new
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Construct a new instance of the <IF::OutInput>.
    @@Return:
      @@@Type: ManakaiDOMLSOutput
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created <IF::LSOutput> object.
      @@@PerlDef:
        $r = bless {}, $self;
##LSOutput

IFDef:
  @Name:  LSProgressEvent
#  @ISA:
#     DOMEvents:Event
  @Attr:
     @@Name:  input
     @@Get:
        @@@Type:  LSInput
  @Attr:
     @@Name:  position
     @@Get:
        @@@Type:
           DOMMain:unsigned-long||ManakaiDOM|all
  @Attr:
     @@Name:  totalSize
     @@Get:
        @@@Type:
           DOMMain:unsigned-long||ManakaiDOM|all
IFDef:
  @Name:  LSLoadEvent
#  @ISA:
#     DOMEvents:Event
  @Attr:
     @@Name:  newDocument
     @@Get:
        @@@Type:  Document
  @Attr:
     @@Name:  input
     @@Get:
        @@@Type:  LSInput

IFDef:
  @Name:  LSSerializerFilter
  @Description:
    @@lang:en
    @@@:
      Examine and filter DOM nodes as they are being processed for 
      the serialization.
#  @ISA:
#     DOMTraversal:NodeFilter
  @Attr:
     @@Name:  whatToShow
     @@Get:
        @@@Type:
           DOMMain:unsigned-long||ManakaiDOM|all

ImplNote:
#ErrorSet:
  @Description:
    @@lang:en
    @@@:
      Errors reported while parsing an input source.
  @ImplNote:
    @@lang:en
    @@@:
      The DOM 3 LS Specification does not define all possible errors; 
      only some common error cases are defined.  Implementations 
      are expected to raise implementation specific errors and 
      warnings for any other cases such as I/O errors, 
      XML well-formedness errors, etc.

  @SpecLevel:3

  @ImplNote:
    @@lang:en
    @@@:
      The error <ERR::check-character-normalization-failure> is 
      also defined for <M::DOMCore:Document.normalizeDocument>; see 
      the <Module::MDOM:DOMCore> module.
  
  @Error:
    @@Name:doctype-not-allowed
    @@Severity:Fatal
    @@Description:
      @@@lang:en
      @@@@:
        The parameter <CP::disallow-doctype> is set to <DOM::true> 
        and a <IF::DOMXML:DocumentType> is encountered.

  @Error:
    @@Name: no-input-specified
    @@Description:
      @@@lang:en
      @@@@:
        No input is specified in the <IF::LSInput> object, 
        i.e. all inputs are <DOM::null>.
    @@ImplNote:
      @@@lang:en
      @@@@:
        {P:: This error might be reported by:
        \
        - <M::LSParser.parse>
        \
        - <M::ManakaiXMLParser2003.parser>
        \
        }
    @@Severity:Fatal

  @Error:
    @@Name:pi-base-uri-not-preserved
    @@Severity:Warning
    @@Description:
      @@@lang:en
      @@@@:
        A processing instruction is encountered in a location 
        where the base URI cannot be preserved.

  @Error:
    @@Name:unbound-prefix-in-entity
    @@Severity:Warning
    @@Description:
      @@@lang:en
      @@@@:
        The parameter <CP::namespaces> is set to <DOM::true> and 
        an unbound namespace prefix is encountered in the replacement 
        text of an entity.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This warning is implementation dependent; some 
        existing parsers may not recognize unbound namespace 
        prefixes in the replacement text.

  @Error:
    @@Name:unknown-character-denormalization
    @@Severity:Fatal
    @@Description:
      @@@lang:en
      @@@@:
        The parameter <CP::ignore-unknown-character-denormalizations> 
        is set to <DOM::false> and a character is encountered for 
        which the processor cannot determine the normalization 
        properties.

  @Error:
    @@Name:unsupported-encoding
    @@Severity:Fatal
    @@Description:
      @@@lang:en
      @@@@:
        An unsupported encoding is encountered.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This error might also be reported when serialization.
  
  @Error:
    @@Name:unsupported-media-type
    @@Severity:Fatal
    @@Description:
      @@@lang:en
      @@@@:
        The parameter <CP::supported-media-types-only> is set to 
        <DOM::true> and an unsupported media type is encountered.

##Error:LSParser


ImplNote:
#ErrorSet:
  @Description:
    @@lang:en
    @@@:
      Errors reported while serializing a DOM node.
  @ImplNote:
    @@lang:en
    @@@:
      The DOM 3 LS Specification does not define all possible errors; 
      only some common error cases are defined.  Implementations 
      are expected to raise implementation specific errors and 
      warnings for any other cases such as I/O errors.

  @SpecLevel:3

  @Error:
    @@Name:byte-order-mark-needed
    @@Severity:Warning
    @@Description:
      @@@lang:en
      @@@@:
        The <CHAR::BOM> is not generated; it might be prepended 
        by the DOM application before the serialized data is 
        written out to some media.

  @Error:
    @@Name:no-output-specified
    @@Severity:Fatal
    @@Description:
      @@@lang:en
      @@@@:
        No output is specified in the <IF::LSOutput> object.
  
  @Error:
    @@Name:unbound-prefix-in-entity-reference
    @@Severity:Fatal
    @@Description:
      @@@lang:en
      @@@@:
        The parameter <CP::namespaces> is set to <DOM::true> 
        and an entity whose replacement text contains 
        unbound namespace prefixes is referred in a location 
        where there are no bindings for the namespace prefixes.

  @ImplNote:
    @@lang:en
    @@@:
      The error <ERR::unsupported-encoding> is defined also for 
      parsing error.
    \
      See <Module::MDOM:DOMCore> for the definition of the error 
      <ERR::wf-invalid-character-in-node-name>.

  @Error:
    @@Name:xml-declaration-needed
    @@Severity:Warning
    @@Description:
      @@@lang:en
      @@@@:
        The XML declaration or the text declaration is not outputed 
        but it was required.
##Error:LSSerializer

ImplNote:
#ConfigParam:
  @Description:
    @@lang:en
    @@@:
      Additional configuration parameters for <IF::DOMCore:DOMConfiguration> 
      objects used with <IF::LSSerializer> objects.

  @ImplNote:
    @@lang:en
    @@@:
      Parameters defined in the DOM Level 3 Core specification 
      is also available.
  
  @ImplNote:
    @@lang:en
    @@@:
      <CP::canonical-form>: See <Module::MDOM:DOMCore>.

  @Param:
    @@Name:discard-default-content
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Use the <A::DOMCore:Attr.specified> attribute to decide 
          what XML attributes should be discarded.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          DOM implementation might use whatever information 
          available to the implementation (including XML Schema document 
          or DTD) to determine what attributes and content to discard.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep all attributes and all content.

  @Param:
    @@Name:format-pretty-print
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Formatting the output by adding white spaces to 
          produce a pretty-printed, intended, human-readable form. 
          (The exact form is not specified.)
          \
          Pretty-printing changes the content of the document and 
          may affect the validity of the document.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          Validating implementations should preserve validity.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@: Don't pretty-print the output.

  @Param:
    @@Name:ignore-unknown-character-denormalizations
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Report a <ERR::unknown-character-denormalization> <EM::warning> 
          (not an error) when fully-normalizedness per XML 1.1 is 
          being verified and a cgaracter is encountered for which 
          the normalization properties cannot be determined and 
          ignore any possible denormalizations caused by that character.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Report a <ERR::unknown-character-denormalization> fatal error 
          if the normalization properties cannot be determined.

  @ImplNote:
    @@lang:en
    @@@:
      <CP::normalize-characters>: See <Module::MDOM:DOMCore>.

  @Param:
    @@Name:xml-declaration
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          When <IF::DOMCore:Document>, <IF::DOMXML:Entity> or 
          <IF::DOMCore:DocumentFragment> is 
          serialized, the XML declaration or the text declaration 
          should be included.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          - <XA::version>:: <A::DOMCore:Document.xmlVersion> or <XML::1.0>.
          \
          - <XA::encoding>:: the output encoding.
          \
          - <XA::standalone>:: <A::DOMCore:Document.xmlStandalone>.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Do not include the XML declaration or text declaration. 
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          If <XA::version> would be other than <XML::1.0> or 
          <XA::encoding> would be required, the <ERR::xml-declaration-needed> 
          warning is reported. 

  @Level:3
  @SpecLevel:3
##ConfigParam:LSSerializer

