use strict;
use Message::Util::QName::Filter {
  dis => q<http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis-->,
  fe => q<http://suika.fam.cx/www/2006/feature/>,
  iat => q<http://www.w3.org/2001/04/infoset#AttributeType.>,
  ManakaiDOM => q<http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#>,
  mv => q<http://suika.fam.cx/www/2006/05/mv/>,
  Util => q<http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/>,
  xdp => q<http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XDP/>,
};

use Message::DOM::XDP;
use Message::DOM::GenericLS;

our $impl; # Assigned in the main script
our $db;
our %Opt;

sub daf_dtd_modules ($$$) {
  my ($mg_uri, $out_dir_path, $mg_for) = @_;

  unless (defined $mg_for) {
    $mg_for = $db->get_module ($mg_uri)
                 ->get_property_text (ExpandedURI q<dis:DefaultFor>,
                                      ExpandedURI q<ManakaiDOM:all>);
  }
  my $mg = $db->get_resource ($mg_uri, for_arg => $mg_for);

  status_msg qq<DTD module group <$mg_uri> for <$mg_for>...>;

  my $mg_name = daf_dm_get_name ($mg);
  my $mg_ver = daf_dm_get_ver ($mg);
  my $mg_namever = $mg_name;
  $mg_namever .= ' ' . $mg_ver if defined $mg_ver;
  my $mg_id = daf_dm_get_id ($mg);
  my $mg_vid = daf_dm_get_vid ($mg);
  my $mg_idvid = $mg_id;
  $mg_idvid .= '-' . $mg_vid if defined $mg_vid;

  my $xdp_impl = $impl->get_feature (ExpandedURI q<fe:XDP> => '3.0');

  for my $mgc (@{daf_dm_get_components ($mg)}) {
    if ($mgc->is_type_uri (ExpandedURI q<mv:XMLDTDModule>)) {
      my $mgc_name = daf_dm_get_name ($mgc);
      my $mgc_ver = daf_dm_get_ver ($mgc);
      my $mgc_namever = $mgc_name . ' Module';
      $mgc_namever .= ' ' . $mgc_ver if defined $mgc_ver;
      my $mgc_id = daf_dm_get_id ($mgc);
      my $mgc_vid = daf_dm_get_vid ($mgc);
      my $mgc_idvid = $mgc_id;
      $mgc_idvid .= '-' . $mgc_vid if defined $mgc_vid;

      my $mgc_file_name = qq<$mg_idvid-$mgc_idvid$Opt{mod_suffix}>;
      my $mgc_file_path = qq<$out_dir_path/$mgc_file_name>;
      status_msg_ qq<Generating DTD module "$mgc_file_path"...>;

      my $xdp_doc = $xdp_impl->create_document (ExpandedURI q<xdp:>, 'pe');
      my $xdp_entity = $xdp_doc->document_element;

      ## -- Header
      $xdp_entity->append_child
                     ($xdp_doc->create_xdp_comment (' '.('.' x 71).' '));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
      $xdp_entity->append_child
                     ($xdp_doc->create_xdp_comment
                                  (' '.$mg_namever.' '.$mgc_namever.' '.
                                   ('.' x (69 - length ($mg_namever)
                                              - length ($mgc_namever))).' '));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
      my $data = ' file: ' . $mgc_file_name . "\n\n";

      ## TODO: License term

      our $VERSION;
      $data .= '     Revision: '
             . sprintf ('%04d-%02d-%02dT%02d:%02d:%02d+00:00',
                        [gmtime]->[5] + 1900, [gmtime]->[4] + 1,
                        [gmtime]->[3], [gmtime]->[2],
                        [gmtime]->[1], [gmtime]->[0])
             . ' (Generated by daf/'.$VERSION.")\n\n";

      ## TODO: Public and system identifiers

      $data .= "     " . ('.' x 71) . ' ';
      $xdp_entity->append_child
                     ($xdp_doc->create_xdp_comment ($data));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));

      ## -- Module Header
      my $mod_header = $xdp_entity->append_child
                                      ($xdp_doc->create_xdp_comment
                                                   (' '.$mgc_name."\n\n"));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));

      my @mod_header_list;

      for my $mgcd (@{daf_dm_get_components ($mgc)}) {
        if ($mgcd->is_type_uri (ExpandedURI q<mv:ElementType>)) {
          my $mgcd_local_name = daf_dm_get_et_local_name ($mgcd);
          my $mgcd_prefix = $mg_idvid . '.' . $mgcd_local_name . '.';

          push @mod_header_list, $mgcd_local_name;

          my $mgcd_short_desc = daf_dm_get_short_desc ($mgcd);
          if (defined $mgcd_short_desc) {
            $mgcd_short_desc = $mgcd_local_name . ': ' . $mgcd_short_desc;
          } else {
            $mgcd_short_desc = $mgcd_local_name;
          }
          $xdp_entity->append_child
                         ($xdp_doc->create_xdp_comment
                                      (' '.$mgcd_short_desc.' '.
                                       ('.' x (51 - length $mgcd_short_desc)).
                                       ' '));
          $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));

          $xdp_entity->append_child
                         ($xdp_doc->create_xdp_entity
                                      (1, $mgcd_prefix.'element', 'INCLUDE'));
          $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
          my $xdp_el = $xdp_doc->create_xdp_if ($mgcd_prefix.'element');
          my $xdp_el_true = $xdp_el->first_child;
          $xdp_entity->append_child ($xdp_el);

          ## TODO: content model
          $xdp_el_true->append_child
                          ($xdp_doc->create_xdp_entity
                                       (1, $mgcd_prefix.'content', 'EMPTY'));
          $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));

          $xdp_el_true->append_child
                          ($xdp_doc->create_xdp_entity
                                       (1, $mgcd_prefix.'qname',
                                        $mgcd_local_name));
          $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));
          $xdp_el_true->append_child
                          ($xdp_doc->create_xdp_entity
                                       (1, $mgcd_prefix.'tagmin.start', '-'));
          $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));
          $xdp_el_true->append_child
                          ($xdp_doc->create_xdp_entity
                                       (1, $mgcd_prefix.'tagmin.end', '-'));
          $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));

          my $xdp_el_tagmin = $xdp_doc->create_xdp_if ('sgml.tag.minimizable');
          $xdp_el_true->append_child ($xdp_el_tagmin);

          for ($xdp_el_tagmin->first_child
                             ->append_child
                                 ($xdp_doc->create_xdp_entity
                                              (1, $mgcd_prefix.'tagmin', ''))
                             ->last_child) {
            $_->append_child
                  ($xdp_doc->create_xdp_peref ($mgcd_prefix.'tagmin.start'));
            $_->append_child ($xdp_doc->create_xdp_s);
            $_->append_child
                  ($xdp_doc->create_xdp_peref ($mgcd_prefix.'tagmin.end'));
            $_->previous_sibling->text_content ("\n\t");
            $_->parent_node->parent_node
              ->append_child ($xdp_doc->create_xdp_s ("\n"));
          }
          $xdp_el_tagmin->last_child
                        ->append_child
                            ($xdp_doc->create_xdp_entity
                                         (1, $mgcd_prefix.'tagmin', ''));

          $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));

          for ($xdp_el_true->append_child
                               ($xdp_doc->create_xdp_element)) {
            $_->append_child ($xdp_doc->create_xdp_s);
            $_->append_child
                  ($xdp_doc->create_xdp_peref ($mgcd_prefix.'qname'));
            $_->append_child ($xdp_doc->create_xdp_s ("\n\t"));
            $_->append_child
                  ($xdp_doc->create_xdp_peref ($mgcd_prefix.'tagmin'));
            $_->append_child ($xdp_doc->create_xdp_s ("\n\t"));
            $_->append_child
                  ($xdp_doc->create_xdp_peref ($mgcd_prefix.'content'));
          }
          $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));

          $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));

          $xdp_entity->append_child
                         ($xdp_doc->create_xdp_entity
                                      (1, $mgcd_prefix.'attlist', 'INCLUDE'));
          $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
          my $xdp_al = $xdp_doc->create_xdp_if ($mgcd_prefix.'attlist');
          my $xdp_al_true = $xdp_al->first_child;
          $xdp_entity->append_child ($xdp_al);

          my $xdp_al_decl = $xdp_doc->create_xdp_attlist;
          $xdp_al_true->append_child ($xdp_al_decl);

          $xdp_al_decl->append_child ($xdp_doc->create_xdp_s);
          $xdp_al_decl->append_child
                          ($xdp_doc->create_xdp_peref ($mgcd_prefix.'qname'));

          daf_dm_add_attrdefs ($mgcd => $xdp_al_decl, $xdp_doc);

          ## TODO: attributes

          $xdp_al_true->append_child ($xdp_doc->create_xdp_s ("\n"));

          $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));
        } elsif ($mgcd->is_type_uri (ExpandedURI q<mv:ElementContentModel>)) {
          my $mgcd_local_name = daf_dm_get_cm_name ($mgcd);
          my $mgcd_prefix = $mg_idvid . '.' . $mgcd_local_name . '.';          
          my $mgcd_short_desc = daf_dm_get_short_desc ($mgcd);
          $mgcd_short_desc = $mgcd_local_name unless defined $mgcd_short_desc;
          my $mgcd_full_name = $mgcd_prefix . 'content';

          $xdp_entity->append_child
                         ($xdp_doc->create_xdp_comment
                                      (' '.$mgcd_short_desc.' '));
          $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
          $xdp_entity->append_child
                         ($xdp_doc->create_xdp_entity
                                      (1, $mgcd_full_name, ''));
          $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));

          ## TODO: content model
        } elsif ($mgcd->is_type_uri (ExpandedURI q<mv:AttributeTypeGroup>)) {
          my $mgcd_local_name = daf_dm_get_ag_name ($mgcd);
          my $mgcd_prefix = $mg_idvid . '.' . $mgcd_local_name . '.';          
          my $mgcd_short_desc = daf_dm_get_short_desc ($mgcd);
          $mgcd_short_desc = $mgcd_local_name unless defined $mgcd_short_desc;
          my $mgcd_full_name = $mgcd_prefix . 'attrib';

          $xdp_entity->append_child
                         ($xdp_doc->create_xdp_comment
                                      (' '.$mgcd_short_desc.' '));
          $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
          my $at_decl = $xdp_entity->append_child
                                       ($xdp_doc->create_xdp_entity
                                                    (1, $mgcd_full_name, ''));
          daf_dm_add_attrdefs ($mgcd, $at_decl->last_child, $xdp_doc);

          $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));
        } else {
          daf_dm_unsupported_type_error ($mgcd, 'module');
        }
      }

      if (@mod_header_list) {
        $mod_header->manakai_append_text ('        ');
        $mod_header->manakai_append_text (join ', ', @mod_header_list);
        $mod_header->manakai_append_text ("\n");
      }

      ## -- Footer
      $xdp_entity->append_child
                     ($xdp_doc->create_xdp_comment
                                  (' end of '.$mgc_file_name.' '));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));

      status_msg_ q<...>;
      open my $mgc_file, '>:encoding(utf-8)', $mgc_file_path
          or die "$0: $mgc_file_path: $!";
      print $mgc_file $xdp_entity->dtd_text;
      close $mgc_file;
      status_msg q<done>;
    } else {
      daf_dm_unsupported_type_error ($mgc, 'module group');
    }
  }

} # daf_dtd_modules

sub daf_dm_get_name ($) {
  my ($res) = @_;
  my $r = $res->get_property_text (ExpandedURI q<mv:longName>);
  $r = $res->get_property_text (ExpandedURI q<dis:FullName>) unless defined $r;
  $r = $res->local_name unless defined $r;
  ## TODO: m12n support
  $r;
} # daf_dm_get_name

sub daf_dm_get_ver ($) {
  my ($res) = @_;
  my $r = $res->get_property_text (ExpandedURI q<mv:version>);
  ## TODO: m12n support
  $r;
} # daf_dm_get_ver

sub daf_dm_get_short_desc ($) {
  my ($res) = @_;
  my $r = $res->get_property_text (ExpandedURI q<mv:shortDescription>);
  $r = $res->get_property_text (ExpandedURI q<dis:FullName>) unless defined $r;
  $r = $res->get_property_text (ExpandedURI q<dis:Description>)
      unless defined $r;
  ## TODO: m12n support
  $r;
} # daf_dm_get_ver

sub daf_dm_get_id ($) {
  my ($res) = @_;
  my $r = $res->get_property_text (ExpandedURI q<mv:id>);
  $r = $res->local_name unless defined $r;
  $r;
} # daf_dm_get_id

sub daf_dm_get_vid ($) {
  my ($res) = @_;
  my $r = $res->get_property_text (ExpandedURI q<mv:vid>);
  $r;
} # daf_dm_get_vid

sub daf_dm_get_components ($) {
  my ($res) = @_;
  my $r = $res->get_property_resource_list (ExpandedURI q<mv:contains>);
  $r;
} # daf_dm_get_components

sub daf_dm_get_et_local_name ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:elementTypeName>);
  if (defined $v) {
    return $v->can ('local_name') ? $v->local_name : $v->string_value;
  } else {
    return $res->local_name;
  }
} # daf_dm_get_et_local_name

sub daf_dm_get_et_nsuri ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:elementTypeName>);
  if (defined $v) {
    return $v->can ('namespace_uri') ? $v->namespace_uri : $v->string_value;
  } else {
    return $res->namespace_uri;
  }
} # daf_dm_get_et_nsuri

sub daf_dm_get_at_local_name ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:attributeTypeName>);
  if (defined $v) {
    return $v->can ('local_name') ? $v->local_name : $v->string_value;
  } else {
    return $res->local_name;
  }
} # daf_dm_get_at_local_name

sub daf_dm_get_at_nsuri ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:attributeTypeName>);
  if (defined $v) {
    return $v->can ('namespace_uri') ? $v->namespace_uri : $v->string_value;
  } else {
    return $res->namespace_uri;
  }
} # daf_dm_get_at_nsuri

sub daf_dm_get_cm_name ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:elementContentModelName>);
  if (defined $v) {
    return $v->can ('local_name') ? $v->local_name : $v->string_value;
  } else {
    return $res->local_name;
  }
} # daf_dm_get_cm_name

sub daf_dm_get_ag_name ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:attributeTypeGroupName>);
  if (defined $v) {
    return $v->can ('local_name') ? $v->local_name : $v->string_value;
  } else {
    return $res->local_name;
  }
} # daf_dm_get_ag_name

sub daf_dm_get_xml_attr_type ($) {
  my ($res) = @_;
  if ($res->is_subset_of_uri (ExpandedURI q<iat:ID>)) {
    return 'ID';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:IDREF>)) {
    return 'IDREF';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:IDREFS>)) {
    return 'IDREFS';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:ENTITY>)) {
    return 'ENTITY';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:ENTITIES>)) {
    return 'ENTITIES';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:NMTOKEN>)) {
    return 'NMTOKEN';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:NMTOKENS>)) {
    return 'NMTOKENS';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:NOTATION>)) {
    return 'NOTATION';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:ENUMERATION>)) {
    return undef;
  } else {
    return 'CDATA';
  }
} # daf_dm_get_xml_attr_type

sub daf_dm_add_attrdefs ($$$) {
  my ($mgcd, $xdp_al_decl, $xdp_doc) = @_;

  for my $mgcde (@{$mgcd->get_child_resource_list_by_type
                            (ExpandedURI q<mv:Attribute>)}) {
    my $mgcde_local_name = daf_dm_get_at_local_name ($mgcde);
    my $mgcde_nsuri = daf_dm_get_at_nsuri ($mgcde);
    unless (defined $mgcde_nsuri) {
      if (not $xdp_al_decl->has_child_nodes and
          $xdp_al_decl->manakai_expanded_uri
              eq ExpandedURI q<xdp:entity-value>) {
        $xdp_al_decl->previous_sibling->text_content ("\n\t");
      } else {
        $xdp_al_decl->append_child ($xdp_doc->create_xdp_s ("\n\t"));
      }
      my $ad = $xdp_doc->create_xdp_attr_definition;
      $xdp_al_decl->append_child ($ad);

      $ad->append_child ($xdp_doc->create_xdp_name ($mgcde_local_name));
      $ad->append_child ($xdp_doc->create_xdp_s ("\t"));

      ## TODO:
      $ad->append_child ($xdp_doc->create_xdp_keyword ('CDATA'));
      $ad->append_child ($xdp_doc->create_xdp_s ("\t"));
      $ad->append_child ($xdp_doc->create_xdp_rni_keyword ('IMPLIED'));
    } else {
      ## TODO:
    }
  }
} # adaf_dm_add_attrdefs

sub daf_dm_unsupported_type_error ($$) {
  my ($res, $context) = @_;
  my $v = 'Resource <'.$res->uri.'> is ignored since its type is not '.
          'supported in '.$context."; Type:\n";
  $v .= "\t<".$_.">\n" for @{$res->get_type_uri_list};
} # daf_dm_unsupported_type_error

1;

__END__

=head1 NAME

daf-dtd-modules.pl - A daf module to generate DTD modukes

=head1 DESCRIPTION

This script, C<daf-dtd-modules.pl>, is dynamically loaded by
C<daf.pl> to create DTD modules.

=head1 SEE ALSO

L<bin/daf.pl> - daf main script

=head1 LICENSE

Copyright 2006 Wakaba <w@suika.fam.cx>.  All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
