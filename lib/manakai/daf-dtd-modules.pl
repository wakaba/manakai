use strict;
use Message::Util::QName::Filter {
  dis => q<http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis-->,
  dxm => q<http://suika.fam.cx/~wakaba/archive/2004/dis/XML#>,
  fe => q<http://suika.fam.cx/www/2006/feature/>,
  iat => q<http://www.w3.org/2001/04/infoset#AttributeType.>,
  infoset => q<http://www.w3.org/2001/04/infoset#>,
  lang => q<http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#>,
  ManakaiDOM => q<http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#>,
  mv => q<http://suika.fam.cx/www/2006/05/mv/>,
  Util => q<http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/>,
  xdp => q<http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XDP/>,
  xml => q<http://www.w3.org/XML/1998/namespace>,
};

use Message::DOM::XDP;
use Message::DOM::GenericLS;

our $impl; # Assigned in the main script
our $db;
our %Opt;

sub daf_dtd_modules ($$$) {
  my ($mg_uri, $out_dir_path, $mg_for) = @_;

  unless (defined $mg_for) {
    $mg_for = $db->get_module ($mg_uri)
                 ->get_property_text (ExpandedURI q<dis:DefaultFor>,
                                      ExpandedURI q<ManakaiDOM:all>);
  }
  my $mg = $db->get_resource ($mg_uri, for_arg => $mg_for);

  status_msg qq<DTD module group <$mg_uri> for <$mg_for>...>;

  my $mg_name = daf_dm_get_name ($mg);
  my $mg_ver = daf_dm_get_ver ($mg);
  my $mg_namever = $mg_name;
  $mg_namever .= ' ' . $mg_ver if defined $mg_ver;

  for my $mgc (@{daf_dm_get_components ($mg)}) {
    daf_dm_register_component ($mgc => $mg);

    if ($mgc->is_type_uri (ExpandedURI q<mv:XMLDTDAnyModule>)) {
      daf_dm_create_module_file ($mg, $mgc, $out_dir_path, $mg_namever);
    } else {
      daf_dm_unsupported_type_error ($mgc, 'module group');
    }
  }

} # daf_dtd_modules

sub daf_dtd_driver ($$$) {
  my ($mg_uri, $out_dir_path, $mg_for) = @_;

  unless (defined $mg_for) {
    $mg_for = $db->get_module ($mg_uri)
                 ->get_property_text (ExpandedURI q<dis:DefaultFor>,
                                      ExpandedURI q<ManakaiDOM:all>);
  }
  my $mg = $db->get_resource ($mg_uri, for_arg => $mg_for);

  daf_dm_create_module_file (undef, $mg, $out_dir_path);
} # daf_dtd_driver

sub daf_dm_create_module_file ($$$) {
  my ($mg, $mgc, $out_dir_path, $mg_namever) = @_;
  my $is_driver = $mgc->is_type_uri (ExpandedURI q<mv:XMLDTDDriver>);
  my $mgc_name = daf_dm_get_name ($mgc);
  my $mgc_ver = daf_dm_get_ver ($mgc);
  my $mgc_namever = $mgc_name;
  $mgc_namever .= ' Module' unless $is_driver;
  $mgc_namever .= ' ' . $mgc_ver if defined $mgc_ver;

      my $mgc_file_name = daf_dm_get_file_entity_name
                            ($mgc,
                             $is_driver ? $Opt{dtd_suffix} : $Opt{mod_suffix});
      my $mgc_file_path = qq<$out_dir_path/$mgc_file_name>;
      status_msg_ qq<Generating DTD @{[$is_driver ? 'driver' : 'module'
                     ]} "$mgc_file_path"...>;

  my $xdp_impl = $impl->get_feature (ExpandedURI q<fe:XDP> => '3.0');
  my $xdp_doc = $xdp_impl->create_document (ExpandedURI q<xdp:>, 'pe');
  my $xdp_entity = $xdp_doc->document_element;

  ## -- Header
  $xdp_entity->append_child
                 ($xdp_doc->create_xdp_comment (' '.('.' x 71).' '));
  $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
  my $title = $mgc_namever;
  $title = $mg_namever . ' ' . $mgc_namever if defined $mg_namever;
  $xdp_entity->append_child
                 ($xdp_doc->create_xdp_comment
                              (' '.$title.' '.
                                   ('.' x (69 - length ($title))) . ' '));
  $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
  my $data = ' file: ' . $mgc_file_name . "\n\n";

      ## TODO: License term

      our $VERSION;
      $data .= '     Revision: '
             . sprintf ('%04d-%02d-%02dT%02d:%02d:%02d+00:00',
                        [gmtime]->[5] + 1900, [gmtime]->[4] + 1,
                        [gmtime]->[3], [gmtime]->[2],
                        [gmtime]->[1], [gmtime]->[0])
             . ' (Generated by daf/'.$VERSION.")\n\n";

      ## TODO: Public and system identifiers

      $data .= "     " . ('.' x 71) . ' ';
      $xdp_entity->append_child
                     ($xdp_doc->create_xdp_comment ($data));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));

      ## -- Module Header
      my $mod_header = $xdp_entity->append_child
                                      ($xdp_doc->create_xdp_comment
                                                   (' '.$mgc_name."\n\n"));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));

  if ($is_driver) {
    daf_dm_dtd_driver_content ($mgc, $xdp_doc, $xdp_entity);
  } else {
      if ($mgc->is_type_uri (ExpandedURI q<mv:XMLDTDQNameModule>)) {
        daf_dm_qname_module_content ($mg, $mgc => $xdp_doc, $xdp_entity);
      } else {
        my @mod_header_list;
        daf_dm_module_content
          ($db, $mg, $mgc => $xdp_doc, $xdp_entity, \@mod_header_list);
        if (@mod_header_list) {
          $mod_header->manakai_append_text ('        ');
          $mod_header->manakai_append_text (join ', ', @mod_header_list);
          $mod_header->manakai_append_text ("\n");
        }
      }
  }

      ## -- Footer
      $xdp_entity->append_child
                     ($xdp_doc->create_xdp_comment
                                  (' end of '.$mgc_file_name.' '));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));

      status_msg_ q<...>;
      open my $mgc_file, '>:encoding(utf-8)', $mgc_file_path
          or die "$0: $mgc_file_path: $!";
      print $mgc_file $xdp_entity->dtd_text;
      close $mgc_file;
      status_msg q<done>;
} # daf_dm_create_module_file

sub daf_dm_module_content ($$$$$$) {
  my ($db, $mg, $mgc => $xdp_doc, $xdp_entity, $mod_header_list) = @_;

  for my $mgcd (@{daf_dm_get_components ($mgc)}) {
    daf_dm_register_component ($mgcd => $mg);

    if ($mgcd->is_type_uri (ExpandedURI q<mv:ElementType>)) {
      my $mgcd_local_name = daf_dm_get_et_local_name ($mgcd);
      my $mgcd_prefix = daf_dm_get_entity_name ($mgcd, '');
      
      push @$mod_header_list, $mgcd_local_name;

      my $mgcd_short_desc = daf_dm_get_short_desc ($mgcd);
      if (defined $mgcd_short_desc) {
        $mgcd_short_desc = $mgcd_local_name . ': ' . $mgcd_short_desc;
      } else {
        $mgcd_short_desc = $mgcd_local_name;
      }
      $xdp_entity->append_child
                       ($xdp_doc->create_xdp_comment
                                    (' '.$mgcd_short_desc.' '.
                                     ('.' x (51 - length $mgcd_short_desc)).
                                     ' '));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));

      $xdp_entity->append_child
                     ($xdp_doc->create_xdp_entity
                                  (1, $mgcd_prefix.'element', 'INCLUDE'));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
      my $xdp_el = $xdp_doc->create_xdp_if ($mgcd_prefix.'element');
      my $xdp_el_true = $xdp_el->first_child;
      $xdp_entity->append_child ($xdp_el);

      ## Content model entity
      my $xdp_content_entity = $xdp_doc->create_xdp_entity
                                           (1, $mgcd_prefix.'content', '');
      $xdp_el_true->append_child ($xdp_content_entity);
      $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));
      daf_dtd_cm ($xdp_doc, $mgcd_prefix.'content', $db,
                  $mgcd => $xdp_content_entity->last_child);

      ## QName entity and tagmin entities
      $xdp_el_true->append_child
                      ($xdp_doc->create_xdp_entity
                                   (1, $mgcd_prefix.'qname',
                                    $mgcd_local_name));
      $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));
      $xdp_el_true->append_child
                      ($xdp_doc->create_xdp_entity
                                   (1, $mgcd_prefix.'tagmin.start', '-'));
      $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));
      $xdp_el_true->append_child
                      ($xdp_doc->create_xdp_entity
                                   (1, $mgcd_prefix.'tagmin.end', '-'));
      $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));

      my $xdp_el_tagmin = $xdp_doc->create_xdp_if ('SGML.tag.minimizable');
      $xdp_el_true->append_child ($xdp_el_tagmin);

      for ($xdp_el_tagmin->first_child
                         ->append_child
                             ($xdp_doc->create_xdp_entity
                                          (1, $mgcd_prefix.'tagmin', ''))
                         ->last_child) {
        $_->append_child
              ($xdp_doc->create_xdp_peref ($mgcd_prefix.'tagmin.start'));
        $_->append_child ($xdp_doc->create_xdp_s);
        $_->append_child
              ($xdp_doc->create_xdp_peref ($mgcd_prefix.'tagmin.end'));
        $_->previous_sibling->text_content ("\n\t");
        $_->parent_node->parent_node
          ->append_child ($xdp_doc->create_xdp_s ("\n"));
      }
      $xdp_el_tagmin->last_child
                    ->append_child
                        ($xdp_doc->create_xdp_entity
                                     (1, $mgcd_prefix.'tagmin', ''));

      $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));

      for ($xdp_el_true->append_child
                           ($xdp_doc->create_xdp_element)) {
        $_->append_child ($xdp_doc->create_xdp_s);
        $_->append_child
              ($xdp_doc->create_xdp_peref ($mgcd_prefix.'qname'));
        $_->append_child ($xdp_doc->create_xdp_s ("\n\t"));
        $_->append_child
              ($xdp_doc->create_xdp_peref ($mgcd_prefix.'tagmin'));
        $_->append_child ($xdp_doc->create_xdp_s ("\n\t"));
        $_->append_child
              ($xdp_doc->create_xdp_peref ($mgcd_prefix.'content'));
      }
      $xdp_el_true->append_child ($xdp_doc->create_xdp_s ("\n"));

      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));

      ## Attribute definition list declaration
      $xdp_entity->append_child
                     ($xdp_doc->create_xdp_entity
                                  (1, $mgcd_prefix.'attlist', 'INCLUDE'));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
      my $xdp_al = $xdp_doc->create_xdp_if ($mgcd_prefix.'attlist');
      my $xdp_al_true = $xdp_al->first_child;
      $xdp_entity->append_child ($xdp_al);

      my $xdp_al_decl = $xdp_doc->create_xdp_attlist;
      $xdp_al_true->append_child ($xdp_al_decl);

      $xdp_al_decl->append_child ($xdp_doc->create_xdp_s);
      $xdp_al_decl->append_child
                      ($xdp_doc->create_xdp_peref ($mgcd_prefix.'qname'));

      ## Attribute definitions
      daf_dm_add_attrdefs ($mgcd => $xdp_al_decl, $xdp_doc, $mg);

      $xdp_al_true->append_child ($xdp_doc->create_xdp_s ("\n"));

      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));
    } elsif ($mgcd->is_type_uri (ExpandedURI q<mv:ElementContentModel>)) {
      my $mgcd_full_name = daf_dm_get_entity_name ($mgcd);

      my $mgcd_short_desc = daf_dm_get_short_desc ($mgcd);
      $mgcd_short_desc = $mgcd_full_name unless defined $mgcd_short_desc;
      $xdp_entity->append_child
                     ($xdp_doc->create_xdp_comment
                                  (' '.$mgcd_short_desc.' '));
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));

      ## Content model entity
      my $xdp_content_entity = $xdp_doc->create_xdp_entity
                                           (1, $mgcd_full_name, '');
      $xdp_entity->append_child ($xdp_content_entity);
      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));
      daf_dtd_cm ($xdp_doc, $mgcd_full_name, $db,
                  $mgcd => $xdp_content_entity->last_child);
    } elsif ($mgcd->is_type_uri (ExpandedURI q<mv:AttributeTypeGroup>)) {
      my $mgcd_short_desc = daf_dm_get_short_desc ($mgcd);
      if (defined $mgcd_short_desc) {
        $xdp_entity->append_child
                       ($xdp_doc->create_xdp_comment
                                    (' '.$mgcd_short_desc.' '));
        $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
      }

      my $mgcd_long_name = daf_dm_get_entity_name ($mgcd);
      my $at_decl = $xdp_entity->append_child
                                   ($xdp_doc->create_xdp_entity
                                                (1, $mgcd_long_name, ''));
      daf_dm_add_attrdefs ($mgcd, $at_decl->last_child, $xdp_doc, $mg);

      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));
    } elsif ($mgcd->is_type_uri (ExpandedURI q<mv:ElementTypeClass>)) {
      my $mgcd_short_desc = daf_dm_get_short_desc ($mgcd);
      if (defined $mgcd_short_desc) {
        $xdp_entity->append_child
                       ($xdp_doc->create_xdp_comment
                                    (' '.$mgcd_short_desc.' '));
        $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
      }

      my $mgcd_long_name = daf_dm_get_entity_name ($mgcd);
      my $ec_decl = $xdp_entity->append_child
                                   ($xdp_doc->create_xdp_entity
                                                (1, $mgcd_long_name, ''))
                               ->last_child;
      my $need_connector = ($mgcd->is_type_uri
                                 (ExpandedURI q<mv:ElementTypeAdditionalClass>));
      for my $mgcde (@{$mgcd->get_property_resource_list
                                (ExpandedURI q<mv:refers>)}) {
        if ($mgcde->is_type_uri (ExpandedURI q<mv:ElementType>) or
            $mgcde->is_type_uri (ExpandedURI q<mv:ElementTypeClass>)) {
          if ($need_connector and
              not $mgcde->is_type_uri
                            (ExpandedURI q<mv:ElementTypeAdditionalClass>)) {
            $ec_decl->append_child ($xdp_doc->create_xdp_s);
            $ec_decl->append_child ($xdp_doc->create_xdp_delimiter ('|'));
            $ec_decl->append_child ($xdp_doc->create_xdp_s);
          }
          $ec_decl->append_child
                      ($xdp_doc->create_xdp_peref
                                   (daf_dm_get_entity_name ($mgcde, 'qname')));
          $need_connector = 1;
        } else {
          daf_dm_unsupported_type_error ($mgcde, 'element type class');
        }
      }

      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));
    } elsif ($mgcd->is_type_uri (ExpandedURI q<mv:XMLDTDDatatypeEntity>)) {
      my $mgcd_short_desc = daf_dm_get_short_desc ($mgcd);
      if (defined $mgcd_short_desc) {
        $xdp_entity->append_child
                       ($xdp_doc->create_xdp_comment
                                    (' '.$mgcd_short_desc.' '));
        $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n"));
      }

      my $mgcd_long_name = daf_dm_get_entity_name ($mgcd);
      my $mgcd_xml_type = $mgcd->get_property_resource
                                (ExpandedURI q<mv:datatypeXMLAttributeType>);
      $mgcd_xml_type = $db->get_resource (ExpandedURI q<iat:CDATA>);
      ## TODO: enumeration

      my $at_decl = $xdp_entity->append_child
                                   ($xdp_doc->create_xdp_entity
                                                (1, $mgcd_long_name, ''));
      $at_decl->last_child
              ->append_child
                  ($xdp_doc->create_xdp_keyword
                               ($mgcd_xml_type->get_property_text
                                  (ExpandedURI q<dxm:keyword>)));

      $xdp_entity->append_child ($xdp_doc->create_xdp_s ("\n\n"));
    } else {
      daf_dm_unsupported_type_error ($mgcd, 'module');
    }
  }
} # daf_dm_module_content

sub daf_dm_dtd_driver_content ($$$) {
  my ($res => $doc, $entity) = @_;

  my @ns;
  my @mod;
  for my $mgcd (@{$res->get_property_resource_list
                          (ExpandedURI q<mv:refers>)}) {
      if ($mgcd->is_type_uri (ExpandedURI q<mv:XMLDTDModuleSet>)) {
        my $prefix = daf_dm_get_entity_name ($mgcd, '');
        push @ns, {
          prefix => $prefix,
          nsprefixed => $mgcd->get_property_text
                                (ExpandedURI q<mv:namespacePrefixed>, '0'),
          nsuri => $mgcd->get_property_text
                            (ExpandedURI q<mv:targetNamespace>,
                             $mgcd->namespace_uri),
          nsprefix => $mgcd->get_property_text
                               (ExpandedURI q<mv:defaultNamespacePrefix>,
                                $prefix),
          sysid_base => $mgcd->get_property_text
                               (ExpandedURI q<mv:systemIdentifierBaseURI>,
                                ''),
        };
        daf_dm_register_all_components ($mgcd => $mgcd);
      } elsif ($mgcd->is_type_uri (ExpandedURI q<mv:XMLDTDModule>)) {
        push @mod, $mgcd;
      } else {
        daf_dm_unsupported_type_error ($mgcd, 'DTD driver');
      }
    }

  ## MODULE.module
  for my $ns (@ns) {
    $entity->append_child
               ($doc->create_xdp_entity (1, $ns->{prefix}.'.module', 'INCLUDE'));
    $entity->append_child ($doc->create_xdp_s ("\n"));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## MODULE.xmlns
  for my $ns (@ns) {
    $entity->append_child
               ($doc->create_xdp_entity (1, $ns->{prefix}.'.xmlns',
                                         $ns->{nsuri}));
    $entity->append_child ($doc->create_xdp_s ("\n"));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## MODULE.sysid.base
  for my $ns (@ns) {
    $entity->append_child
               ($doc->create_xdp_entity (1, $ns->{prefix}.'.sysid.base',
                                         $ns->{sysid_base}));
    $entity->append_child ($doc->create_xdp_s ("\n"));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## NS.prefixed
  my $ns_prefixed = $res->get_property_text
                            (ExpandedURI q<mv:namespacePrefixed>, '0');
  if ($ns_prefixed > 0) { # positive
    $entity->append_child
               ($doc->create_xdp_entity (1, 'NS.prefixed', 'INCLUDE'));
  } else { # zero or negative
    $entity->append_child
               ($doc->create_xdp_entity (1, 'NS.prefixed', 'IGNORE'));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  for my $ns (@ns) {
    ## MODULE.prefixed
    if ($ns->{nsprefixed} ne '0') {
      $entity->append_child
                 ($doc->create_xdp_entity (1, $ns->{prefix}.'.prefixed',
                                           $ns->{nsprefixed} > 0
                                             ? 'INCLUDE' : 'IGNORE'));
    } else {
      $entity->append_child ($doc->create_xdp_entity
                                     (1, $ns->{prefix}.'.prefixed'))
             ->last_child
             ->append_child ($doc->create_xdp_peref ('NS.prefixed'));
    }
    $entity->append_child ($doc->create_xdp_s ("\n"));

    ## MODULE.prefix
    $entity->append_child
               ($doc->create_xdp_entity
                        (1, $ns->{prefix}.'.prefix', $ns->{nsprefix}));
    $entity->append_child ($doc->create_xdp_s ("\n"));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## URI.datatype
  $entity->append_child ($doc->create_xdp_entity (1, 'URI.datatype', 'CDATA'));
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## MODULE.xmlns.extra.attrib
  for my $ns (@ns) {
    $entity->append_child
               ($doc->create_xdp_entity
                        (1, $ns->{prefix}.'.xmlns.extra.attrib'));
    $entity->append_child ($doc->create_xdp_s ("\n"));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## MODULE.xmlns.attrib.prefixed
  for my $ns (@ns) {
    for ($entity->append_child
                    ($doc->create_xdp_entity
                             (1, $ns->{prefix}.'.xmlns.attrib.prefixed'))) {
      $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
      for ($_->last_child->append_child ($doc->create_xdp_attr_definition)) {
        for ($_->append_child ($doc->create_xdp_name ('xmlns:'))) {
          $_->append_child ($doc->create_xdp_peref ($ns->{prefix}.'.prefix'));
        }
        $_->append_child ($doc->create_xdp_s ("\t"));
        $_->append_child ($doc->create_xdp_peref ('URI.datatype'));
        $_->append_child ($doc->create_xdp_s ("\t"));
        $_->append_child ($doc->create_xdp_rni_keyword ('FIXED'));
        $_->append_child ($doc->create_xdp_s (' '));
        $_->append_child ($doc->create_xdp_attr_literal)
          ->append_child ($doc->create_xdp_peref ($ns->{prefix}.'.xmlns'));
      }
    }
    $entity->append_child ($doc->create_xdp_s ("\n"));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## MODULE.xmlns.attrib.default
  for my $ns (@ns) {
    for ($entity->append_child
                    ($doc->create_xdp_entity
                             (1, $ns->{prefix}.'.xmlns.attrib.default'))) {
      $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
      for ($_->last_child->append_child ($doc->create_xdp_attr_definition)) {
        $_->append_child ($doc->create_xdp_name ('xmlns'));
        $_->append_child ($doc->create_xdp_s ("\t"));
        $_->append_child ($doc->create_xdp_peref ('URI.datatype'));
        $_->append_child ($doc->create_xdp_s ("\t"));
        $_->append_child ($doc->create_xdp_rni_keyword ('FIXED'));
        $_->append_child ($doc->create_xdp_s (' '));
        $_->append_child ($doc->create_xdp_attr_literal)
          ->append_child ($doc->create_xdp_peref ($ns->{prefix}.'.xmlns'));
      }
    }
    $entity->append_child ($doc->create_xdp_s ("\n"));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## MODULE.xmlns.decl.attrib
  for my $ns (@ns) {
    my $if0 = $entity->append_child
                         ($doc->create_xdp_if ($ns->{prefix}.'.module'));
    for ($if0->first_child) { # true
      my $if = $_->append_child
                     ($doc->create_xdp_if ($ns->{prefix}.'.prefixed'));
      for ($if->first_child) { # true
        for ($_->append_child ($doc->create_xdp_entity
                                       (1,
                                        $ns->{prefix}.'.xmlns.decl.attrib'))) {
          $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
          for ($_->last_child) {
            $_->append_child ($doc->create_xdp_peref
                                      ($ns->{prefix}.'.xmlns.attrib.prefixed'));
          }
        }
        $_->append_child ($doc->create_xdp_s ("\n"));
      }
      for ($if->last_child) { # false
        for ($_->append_child ($doc->create_xdp_entity
                                       (1,
                                        $ns->{prefix}.'.xmlns.decl.attrib'))) {
          $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
          for ($_->last_child) {
            $_->append_child ($doc->create_xdp_peref
                                      ($ns->{prefix}.'.xmlns.attrib.default'));
          }
        }
      }
      $_->append_child ($doc->create_xdp_s ("\n"));
    }
    for ($if0->last_child) { # false
      $_->append_child ($doc->create_xdp_entity
                                (1, $ns->{prefix}.'.xmlns.decl.attrib', ''));
    }
    $entity->append_child ($doc->create_xdp_s ("\n"));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## MODULE.xmlns.prefixed.attrib
  for my $ns (@ns) {
    my $if0 = $entity->append_child
                         ($doc->create_xdp_if ($ns->{prefix}.'.module'));
    for ($if0->first_child) { # true
      my $if = $_->append_child
                     ($doc->create_xdp_if ($ns->{prefix}.'.prefixed'));
      for ($if->first_child) { # true
        for ($_->append_child
                   ($doc->create_xdp_entity
                            (1, $ns->{prefix}.'.xmlns.prefixed.attrib'))) {
          $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
          for ($_->last_child) {
            $_->append_child ($doc->create_xdp_peref
                                      ($ns->{prefix}.'.xmlns.attrib.prefixed'));
          }
        }
        $_->append_child ($doc->create_xdp_s ("\n"));
      }
      $_->append_child ($doc->create_xdp_s ("\n"));
    }
    for ($if0->last_child) { # false
      $_->append_child ($doc->create_xdp_entity
                                (1, $ns->{prefix}.'.xmlns.prefixed.attrib'));
    }
    $entity->append_child ($doc->create_xdp_s ("\n"));
  }
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## NS.decl.attrib
  for ($entity->append_child ($doc->create_xdp_entity (1, 'NS.decl.attrib'))) {
    $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
    for my $ent ($_->last_child) {
      for my $ns (@ns) {
        $ent->append_child ($doc->create_xdp_peref
                                    ($ns->{prefix}.'.xmlns.prefixed.attrib'));
        $ent->append_child ($doc->create_xdp_s ("\n\t"));
      }
      for my $ns (@ns[0]) {
        $ent->append_child ($doc->create_xdp_peref
                                    ($ns->{prefix}.'.xmlns.extra.attrib'));
      }
      for my $ns (@ns[1..$#ns]) {
        $ent->append_child ($doc->create_xdp_s ("\n\t"));
        $ent->append_child ($doc->create_xdp_peref
                                    ($ns->{prefix}.'.xmlns.extra.attrib'));
      }
    }
  }
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## -- Modules
  for my $mod_res (@mod) {
    my $mod_prefix = daf_dm_get_file_entity_name ($mod_res, '');
    my $mod_mg = daf_dm_get_module_group ($mod_res);

    ## Description
    my $desc = daf_dm_get_short_desc ($mod_res);
    $desc = $mod_res->local_name . ' Module'
      unless defined $desc and length $desc;
    $desc .= ' ' . ('.' x (61 - length ($desc)));
    $entity->append_child ($doc->create_xdp_comment (' ' . $desc . ' '));
    $entity->append_child ($doc->create_xdp_s ("\n"));

    ## MODULE.module
    $entity->append_child
      ($doc->create_xdp_entity (1, $mod_prefix.'.module', 'INCLUDE'));
    $entity->append_child ($doc->create_xdp_s ("\n"));
    
    my $if = $entity->append_child ($doc->create_xdp_if ($mod_prefix.'.module'));
    for ($if->first_child) { # true
      my $mod_mg_prefix = daf_dm_get_entity_name ($mod_mg, '');

      ## MODULE.mod.fpi
      my $pubid = $mod_res->get_property_text
                              (ExpandedURI q<mv:publicIdentifier>);
      if (defined $pubid) {
        for ($_->append_child ($doc->create_xdp_entity
                                       (1, $mod_prefix.'.mod.fpi', $pubid))) {
          $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
        }
        $_->append_child ($doc->create_xdp_s ("\n"));
      }

      ## MODULE.mod.sysid
      for ($_->append_child ($doc->create_xdp_entity
                                     (1, $mod_prefix.'.mod.sysid'))) {
        $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
        for ($_->last_child) {
          $_->append_child ($doc->create_xdp_peref
                                    ($mod_mg_prefix.'.sysid.base'));
          $_->append_child
                ($doc->create_text_node
                         (daf_dm_get_file_entity_name
                            ($mod_res, $Opt{mod_suffix})));
        }
      }
      $_->append_child ($doc->create_xdp_s ("\n"));

      ## MODULE.mod.decl
      for ($_->append_child ($doc->create_xdp_entity
                                     (1, $mod_prefix.'.mod.decl'))) {
        $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
        for ($_->last_child) {
          if (defined $pubid) {
            $_->append_child ($doc->create_xdp_name ('PUBLIC'));
            $_->append_child ($doc->create_xdp_s);
            $_->append_child ($doc->create_xdp_delimiter ('"'));
            $_->append_child ($doc->create_xdp_peref ($mod_prefix.'.mod.fpi'));
            $_->append_child ($doc->create_xdp_delimiter ('"'));
          } else {
            $_->append_child ($doc->create_xdp_name ('SYSTEM'));
          }
          $_->append_child ($doc->create_xdp_s);
          $_->append_child ($doc->create_xdp_delimiter ('"'));
          $_->append_child ($doc->create_xdp_peref ($mod_prefix.'.mod.sysid'));
          $_->append_child ($doc->create_xdp_delimiter ('"'));
        }
      }
      $_->append_child ($doc->create_xdp_s ("\n"));

      ## MODULE.mod
      for ($_->append_child ($doc->create_xdp_entity (1, $mod_prefix.'.mod'))) {
        $_->remove_child ($_->last_child);
        $_->append_child ($doc->create_xdp_s ("\n\t"));
        $_->append_child ($doc->create_xdp_peref ($mod_prefix.'.mod.decl'));
      }
      $_->append_child ($doc->create_xdp_s ("\n"));

      $_->append_child ($doc->create_xdp_peref ($mod_prefix.'.mod'));
      $_->append_child ($doc->create_xdp_s ("\n"));
    }
    $entity->append_child ($doc->create_xdp_s ("\n\n"));
  }
} # daf_dm_dtd_driver_content

sub daf_dm_qname_module_content ($$$$) {
  my ($mg, $res => $doc, $entity) = @_;

  my $prefix = daf_dm_get_entity_name ($mg, '') . '.';
  my $file_prefix = daf_dm_get_file_entity_name ($mg, '') . '-';

  ## Section A

  ## NS.prefixed
  $entity->append_child ($doc->create_xdp_entity (1, 'NS.prefixed', 'IGNORE'));
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## MODULE.prefixed
  my $prefixed_default = $mg->get_property_text
                                 (ExpandedURI q<mv:namespacePrefixed>, '0');
  if ($prefixed_default ne '0') {
    $entity->append_child
               ($doc->create_xdp_entity
                        (1, $prefix.'prefixed',
                         $prefixed_default > 0 ? 'INCLUDE' : 'IGNORE'));
  } else {
    $entity->append_child ($doc->create_xdp_entity (1, $prefix.'prefixed'))
           ->last_child
           ->append_child ($doc->create_xdp_peref ('NS.prefixed'));
  }
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## MODULE.xmlns
  $entity->append_child
             ($doc->create_xdp_entity
                      (1, $prefix.'xmlns',
                       $mg->get_property_text
                               (ExpandedURI q<mv:targetNamespace>,
                                $mg->namespace_uri)));
  $entity->append_child ($doc->create_xdp_s ("\n"));

  ## MODULE.prefix
  my $ns_prefix = $mg->get_property_text
                         (ExpandedURI q<mv:defaultNamespacePrefix>,
                          substr $prefix, 0, length ($prefix) - 1);
  $entity->append_child
             ($doc->create_xdp_entity
                      (1, $prefix.'prefix', $ns_prefix));
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## MODULE.pfx
  my $if = $entity->append_child ($doc->create_xdp_if ($prefix.'prefixed'));
  for ($if->first_child) { # true
    for ($_->append_child ($doc->create_xdp_entity (1, $prefix.'pfx'))
           ->last_child) {
      $_->append_child ($doc->create_xdp_peref ($prefix.'prefix'));
      $_->append_child ($doc->create_text_node (':'));
    }
    $_->append_child ($doc->create_xdp_s ("\n"));
  }
  for ($if->last_child) { # false
    $_->append_child ($doc->create_xdp_entity (1, $prefix.'pfx', ''));
  }
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## module-qname-extra.mod
  $entity->append_child ($doc->create_xdp_entity
                                 (1, $file_prefix.'qname-extra.mod', ''));
  $entity->append_child ($doc->create_xdp_s ("\n"));
  $entity->append_child ($doc->create_xdp_peref
                                 ($file_prefix.'qname-extra.mod'));
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## URI.datatype
  $entity->append_child ($doc->create_xdp_entity (1, 'URI.datatype', 'CDATA'));
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## MODULE.xmlns.extra.attrib
  $entity->append_child
    ($doc->create_xdp_entity (1, $prefix.'xmlns.extra.attrib'));
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## MODULE.xmlns.attrib.prefixed
  for ($entity->append_child ($doc->create_xdp_entity
                                      (1, $prefix.'xmlns.attrib.prefixed'))) {
    $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
    for ($_->last_child->append_child ($doc->create_xdp_attr_definition)) {
      for ($_->append_child ($doc->create_xdp_name ('xmlns:'))) {
        $_->append_child ($doc->create_xdp_peref ($prefix.'prefix'));
      }
      $_->append_child ($doc->create_xdp_s ("\t"));
      $_->append_child ($doc->create_xdp_peref ('URI.datatype'));
      $_->append_child ($doc->create_xdp_s ("\t"));
      $_->append_child ($doc->create_xdp_rni_keyword ('FIXED'));
      $_->append_child ($doc->create_xdp_s (' '));
      $_->append_child ($doc->create_xdp_attr_literal)
        ->append_child ($doc->create_xdp_peref ($prefix.'xmlns'));
    }
  }
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## MODULE.xmlns.attrib.default
  for ($entity->append_child ($doc->create_xdp_entity
                                      (1, $prefix.'xmlns.attrib.default'))) {
    $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
    for ($_->last_child->append_child ($doc->create_xdp_attr_definition)) {
      $_->append_child ($doc->create_xdp_name ('xmlns'));
      $_->append_child ($doc->create_xdp_s ("\t"));
      $_->append_child ($doc->create_xdp_peref ('URI.datatype'));
      $_->append_child ($doc->create_xdp_s ("\t"));
      $_->append_child ($doc->create_xdp_rni_keyword ('FIXED'));
      $_->append_child ($doc->create_xdp_s (' '));
      $_->append_child ($doc->create_xdp_attr_literal)
        ->append_child ($doc->create_xdp_peref ($prefix.'xmlns'));
    }
  }
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## MODULE.xmlns.decl.attrib
  $if = $entity->append_child ($doc->create_xdp_if ($prefix.'prefixed'));
  for ($if->first_child) { # true
    for ($_->append_child ($doc->create_xdp_entity
                                   (1, $prefix.'xmlns.decl.attrib'))) {
      $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
      for ($_->last_child) {
        $_->append_child ($doc->create_xdp_peref
                                  ($prefix.'xmlns.attrib.prefixed'));
      }
    }
    $_->append_child ($doc->create_xdp_s ("\n"));
  }
  for ($if->last_child) { # false
    for ($_->append_child ($doc->create_xdp_entity
                                   (1, $prefix.'xmlns.decl.attrib'))) {
      $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
      for ($_->last_child) {
        $_->append_child ($doc->create_xdp_peref
                                  ($prefix.'xmlns.attrib.default'));
      }
    }
  }
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## MODULE.xmlns.prefixed.attrib
  $if = $entity->append_child ($doc->create_xdp_if ($prefix.'prefixed'));
  for ($if->first_child) { # true
    for ($_->append_child ($doc->create_xdp_entity
                                   (1, $prefix.'xmlns.prefixed.attrib'))) {
      $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
      for ($_->last_child) {
        $_->append_child ($doc->create_xdp_peref
                                  ($prefix.'xmlns.attrib.prefixed'));
      }
    }
    $_->append_child ($doc->create_xdp_s ("\n"));
  }
  for ($if->last_child) { # false
    $_->append_child ($doc->create_xdp_entity
                              (1, $prefix.'xmlns.prefixed.attrib'));
  }
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## NS.decl.attrib
  for ($entity->append_child ($doc->create_xdp_entity (1, 'NS.decl.attrib'))) {
    $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
    for ($_->last_child) {
      $_->append_child ($doc->create_xdp_peref
                                ($prefix.'xmlns.prefixed.attrib'));
      $_->append_child ($doc->create_xdp_s ("\n\t"));
      $_->append_child ($doc->create_xdp_peref
                                ($prefix.'xmlns.extra.attrib'));
    }
  }
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## MODULE.xmlns.attrib
  $if = $entity->append_child ($doc->create_xdp_if ($prefix.'prefixed'));
  for ($if->first_child) { # true
    for ($_->append_child ($doc->create_xdp_entity
                                   (1, $prefix.'xmlns.attrib'))) {
      $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
      $_->last_child->append_child ($doc->create_xdp_peref
                                            ('NS.decl.attrib'));
    }
    $_->append_child ($doc->create_xdp_s ("\n"));
  }
  for ($if->last_child) { # false
    for ($_->append_child ($doc->create_xdp_entity
                                   (1, $prefix.'xmlns.attrib'))) {
      $_->insert_before ($doc->create_xdp_s ("\n\t"), $_->last_child);
      for ($_->last_child) {
        $_->append_child ($doc->create_xdp_peref
                                  ($prefix.'xmlns.attrib.default'));
        $_->append_child ($doc->create_xdp_s ("\n\t"));
        $_->append_child ($doc->create_xdp_peref
                                  ('NS.decl.attrib'));
      }
    }
  }
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## SGML.tag.minimizable
  $entity->append_child
             ($doc->create_xdp_entity (1, 'SGML.tag.minimizable', 'IGNORE'));
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## module-qname.redecl
  $entity->append_child ($doc->create_xdp_entity
                                 (1, $file_prefix.'qname.redecl', ''));
  $entity->append_child ($doc->create_xdp_s ("\n"));
  $entity->append_child ($doc->create_xdp_peref
                                 ($file_prefix.'qname.redecl'));
  $entity->append_child ($doc->create_xdp_s ("\n\n"));

  ## Section B
  my %qname_done;
  my @qname_res = @{daf_dm_get_components ($res)};
  while (@qname_res) {
    my $mgcd = shift @qname_res;
    my $mgcd_uri = $mgcd->uri;
    next if $qname_done{$mgcd_uri};
    $qname_done{$mgcd_uri} = 1;
          
    if ($mgcd->is_type_uri (ExpandedURI q<mv:ElementType>)) {
      my $mgcd_local_name = daf_dm_get_et_local_name ($mgcd);
      my $mgcd_entity_name = daf_dm_get_entity_name ($mgcd, 'qname');
      for ($entity->append_child
                      ($doc->create_xdp_entity (1, $mgcd_entity_name))
                  ->last_child) {
        $_->append_child ($doc->create_xdp_peref ($prefix.'pfx'));
        $_->append_child ($doc->create_text_node ($mgcd_local_name));
      }
      $entity->append_child ($doc->create_xdp_s ("\n"));
    } elsif ($mgcd->is_type_uri (ExpandedURI q<mv:AttributeType>)) {
      my $mgcd_local_name = daf_dm_get_at_local_name ($mgcd);
      my $mgcd_entity_name = daf_dm_get_entity_name ($mgcd, 'qname');
      $entity->append_child
                 ($doc->create_xdp_entity
                          (1, $mgcd_entity_name, $mgcd_local_name));
      $entity->append_child ($doc->create_xdp_s ("\n"));
      ## TODO: section for global
    } else {
      push @qname_res, @{daf_dm_get_components ($mgcd)};
    }
  }

  $entity->append_child ($doc->create_xdp_s ("\n"));
} # daf_dm_qname_module_content

sub daf_dtd_cm ($$) {
  my ($doc, $label, $db, $src => $dest) = @_;

  my $src_v = $src->get_property_value (ExpandedURI q<mv:elementContentModel>);
  if (defined $src_v) {
    my $src_cm = $src_v->isa ('Message::Util::IF::DVURIValue')
                   ? $src_v->get_resource ($db) : undef;
    if (defined $src_cm and
        $src_cm->is_type_uri (ExpandedURI q<mv:ElementContentModel>)) {
      $dest->append_child 
               ($doc->create_xdp_peref (daf_dm_get_entity_name ($src_cm)));
    } elsif (defined $src_v and
             $src_v->isa ('Message::Util::IF::DVXMLValue')) {
      my @in = ([$src_v->get_node (od => $doc) => $dest, undef]);
      ## TODO: connector
      A: while (@in) {
        my $in = shift @in;

        my $xuri = $in->[0]->manakai_expanded_uri;
        if ($xuri eq ExpandedURI q<lang:dcmodel:group>) {
          if (defined $in->[2] and length $in->[2]) {
            $in->[1]->append_child ($doc->create_xdp_s (' '))
              unless $in->[2] eq ',';
            $in->[1]->append_child ($doc->create_xdp_delimiter ($in->[2]));
            $in->[1]->append_child ($doc->create_xdp_s (' '));
          }

          my $group = $doc->create_xdp_model_group;
          $in->[1]->append_child ($group);
          my $occur = $in->[0]->get_attribute_ns (undef, 'occurence');
          if (defined $occur and length $occur) {
            $in->[1]->append_child ($doc->create_xdp_delimiter ($occur));
          }
          my $connector = $in->[0]->get_attribute_ns (undef, 'connector');
          my $i = 0;
          for (@{$in->[0]->child_nodes}) {
            next unless $_->node_type == $_->ELEMENT_NODE;
            push @in, [$_ => $group, $i++ == 0 ? undef : $connector];
          }
        } elsif ($xuri eq ExpandedURI q<lang:dcmodel:terminal>) {
          my $res = $db->get_resource ($in->[0]->text_content);
          $res->is_referred ($label);

          if (defined $in->[2] and length $in->[2] and
              not $res->is_type_uri
                          (ExpandedURI q<mv:ElementTypeAdditionalClass>)) {
            $in->[1]->append_child ($doc->create_xdp_s (' '))
              unless $in->[2] eq ',';
            $in->[1]->append_child ($doc->create_xdp_delimiter ($in->[2]));
            $in->[1]->append_child ($doc->create_xdp_s (' '));
          }

          my $res_uri = $res->uri;
          if ($res_uri eq ExpandedURI q<dxm:PCDATA>) {
            $in->[1]->append_child ($doc->create_xdp_rni_keyword ('PCDATA'));
          } elsif ($res_uri eq ExpandedURI q<dxm:ANY>) {
            $in->[1]->append_child ($doc->create_xdp_keyword ('ANY'));
          } elsif ($res_uri eq ExpandedURI q<dxm:EMPTY>) {
            $in->[1]->append_child ($doc->create_xdp_keyword ('EMPTY'));
          } else {
            my $name = daf_dm_get_entity_name ($res);
            my $el = $doc->create_xdp_peref ($name);
            my $occur = $in->[0]->get_attribute_ns (undef, 'occurence');
            if (defined $occur and length $occur) {
              for ($in->[1]->append_child ($doc->create_xdp_model_group)) {
                $_->append_child ($el);
              }
              $in->[1]->append_child ($doc->create_xdp_delimiter ($occur));
            } else {
              $in->[1]->append_child ($el);
            }
          }
        } else {
          warn "<$xuri>: Unknown element type";
        }
      } # A
    } else {
      $dest->append_child ($doc->create_xdp_keyword ('EMPTY'));
    }
  } else {
    $dest->append_child ($doc->create_xdp_keyword ('EMPTY'));
  }
} # daf_dtd_cm

sub daf_dm_get_name ($) {
  my ($res) = @_;
  my $r = $res->get_property_text (ExpandedURI q<mv:longName>);
  $r = $res->get_property_text (ExpandedURI q<dis:FullName>) unless defined $r;
  $r = $res->local_name unless defined $r;
  ## TODO: m12n support
  $r;
} # daf_dm_get_name

sub daf_dm_get_ver ($) {
  my ($res) = @_;
  my $r = $res->get_property_text (ExpandedURI q<mv:version>);
  ## TODO: m12n support
  $r;
} # daf_dm_get_ver

sub daf_dm_get_short_desc ($) {
  my ($res) = @_;
  my $r = $res->get_property_text (ExpandedURI q<mv:shortDescription>);
  $r = $res->get_property_text (ExpandedURI q<dis:FullName>) unless defined $r;
  $r = $res->get_property_text (ExpandedURI q<dis:Description>)
      unless defined $r;
  ## TODO: m12n support
  $r;
} # daf_dm_get_ver

sub daf_dm_get_components ($) {
  my ($res) = @_;
  my $r = $res->get_property_resource_list (ExpandedURI q<mv:contains>);
  $r;
} # daf_dm_get_components

sub daf_dm_get_et_local_name ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:elementTypeName>);
  if (defined $v) {
    return $v->can ('local_name') ? $v->local_name : $v->string_value;
  } else {
    return $res->local_name;
  }
} # daf_dm_get_et_local_name

sub daf_dm_get_et_nsuri ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:elementTypeName>);
  if (defined $v) {
    return $v->can ('namespace_uri') ? $v->namespace_uri : $v->string_value;
  } else {
    return $res->namespace_uri;
  }
} # daf_dm_get_et_nsuri

sub daf_dm_get_at_local_name ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:attributeTypeName>);
  if (defined $v) {
    return $v->can ('local_name') ? $v->local_name : $v->string_value;
  } else {
    return $res->local_name;
  }
} # daf_dm_get_at_local_name

sub daf_dm_get_at_nsuri ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:attributeTypeName>);
  if (defined $v) {
    return $v->can ('namespace_uri') ? $v->namespace_uri : $v->string_value;
  } else {
    return $res->namespace_uri;
  }
} # daf_dm_get_at_nsuri

sub daf_dm_get_cm_name ($) {
  my ($res) = @_;
  my $v = $res->get_property_value (ExpandedURI q<mv:elementContentModelName>);
  if (defined $v) {
    return $v->can ('local_name') ? $v->local_name : $v->string_value;
  } else {
    return $res->local_name;
  }
} # daf_dm_get_cm_name

sub daf_dm_get_xml_attr_type ($) {
  my ($res) = @_;
  if ($res->is_subset_of_uri (ExpandedURI q<iat:ID>)) {
    return 'ID';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:IDREF>)) {
    return 'IDREF';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:IDREFS>)) {
    return 'IDREFS';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:ENTITY>)) {
    return 'ENTITY';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:ENTITIES>)) {
    return 'ENTITIES';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:NMTOKEN>)) {
    return 'NMTOKEN';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:NMTOKENS>)) {
    return 'NMTOKENS';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:NOTATION>)) {
    return 'NOTATION';
  } elsif ($res->is_subset_of_uri (ExpandedURI q<iat:ENUMERATION>)) {
    return undef;
  } else {
    return 'CDATA';
  }
} # daf_dm_get_xml_attr_type

sub daf_dm_add_attrdefs ($$$) {
  my ($mgcd, $xdp_al_decl, $xdp_doc, $mg) = @_;

  for my $mgcde (@{$mgcd->get_child_resource_list_by_type
                            (ExpandedURI q<mv:AttributeType>)}) {
    daf_dm_register_component ($mgcd => $mg);

      if (not $xdp_al_decl->has_child_nodes and
          $xdp_al_decl->manakai_expanded_uri
              eq ExpandedURI q<xdp:entity-value>) {
        $xdp_al_decl->previous_sibling->text_content ("\n\t");
      } else {
        $xdp_al_decl->append_child ($xdp_doc->create_xdp_s ("\n\t"));
      }
      my $ad = $xdp_doc->create_xdp_attr_definition;
      $xdp_al_decl->append_child ($ad);

    my $mgcde_local_name = daf_dm_get_at_local_name ($mgcde);
    my $mgcde_nsuri = daf_dm_get_at_nsuri ($mgcde);
    unless (defined $mgcde_nsuri) {
      $ad->append_child ($xdp_doc->create_xdp_name ($mgcde_local_name));
    } elsif ($mgcde_nsuri eq ExpandedURI q<xml:>) {
      $ad->append_child ($xdp_doc->create_xdp_name ('xml:'.$mgcde_local_name));
    } else {
      ## TODO:
    }
    $ad->append_child ($xdp_doc->create_xdp_s ("\t"));

      my $vtype = $mgcde->get_property_resource
                            (ExpandedURI q<mv:attributeValueType>);
      if (defined $vtype) {
        if ($vtype->is_type_uri (ExpandedURI q<mv:XMLDTDDatatypeEntity>)) {
          $ad->append_child
                 ($xdp_doc->create_xdp_peref
                              (daf_dm_get_entity_name ($vtype)));
        } elsif ($vtype->is_type_uri (ExpandedURI q<infoset:AttributeType>)) {
          $ad->append_child ($xdp_doc->create_xdp_keyword
                                         ($vtype->get_property_text
                                            (ExpandedURI q<dxm:keyword>)));
          ## TODO: Enumeration
        } else {
          daf_dm_unsupported_type_error ($vtype, 'attribute value type');
          $ad->append_child ($xdp_doc->create_xdp_keyword ('CDATA'));
        }
      } else {
        $ad->append_child ($xdp_doc->create_xdp_keyword ('CDATA'));
      }

      ## TODO:
      $ad->append_child ($xdp_doc->create_xdp_s ("\t"));
      $ad->append_child ($xdp_doc->create_xdp_rni_keyword ('IMPLIED'));
  } # mv:Attribute

  for my $mgcde (@{$mgcd->get_property_resource_list
                            (ExpandedURI q<mv:refers>)}) {
    if ($mgcde->is_type_uri (ExpandedURI q<mv:AttributeTypeGroup>)) {
      my $long_name = daf_dm_get_entity_name ($mgcde);
      if (not $xdp_al_decl->has_child_nodes and
          $xdp_al_decl->manakai_expanded_uri
              eq ExpandedURI q<xdp:entity-value>) {
        $xdp_al_decl->previous_sibling->text_content ("\n\t");
      } else {
        $xdp_al_decl->append_child ($xdp_doc->create_xdp_s ("\n\t"));
      }
      $xdp_al_decl->append_child ($xdp_doc->create_xdp_peref ($long_name));
    } elsif ($mgcde->is_type_uri (ExpandedURI q<mv:XMLDTDModuleSet>)) {
      my $long_name = daf_dm_get_entity_name ($mgcde) . '.xmlns.attrib';
      if (not $xdp_al_decl->has_child_nodes and
          $xdp_al_decl->manakai_expanded_uri
              eq ExpandedURI q<xdp:entity-value>) {
        $xdp_al_decl->previous_sibling->text_content ("\n\t");
      } else {
        $xdp_al_decl->append_child ($xdp_doc->create_xdp_s ("\n\t"));
      }
      $xdp_al_decl->append_child ($xdp_doc->create_xdp_peref ($long_name));
    } else {
      daf_dm_unsupported_type_error ($mgcde, 'attribute context');
    }
  }

} # adaf_dm_add_attrdefs

sub daf_dm_unsupported_type_error ($$) {
  my ($res, $context) = @_;
  my $v = 'Resource <'.$res->uri.'> is ignored since its type is not '.
          'supported in '.$context."; Type:\n";
  $v .= "\t<".$_.">\n" for @{$res->get_type_uri_list};
  warn $v;
} # daf_dm_unsupported_type_error

{
  my %DMBelongTo;

  sub daf_dm_register_component ($$) {
    my ($res, $mod) = @_;
    $DMBelongTo{$res->uri} ||= $mod;
  } # daf_dm_register_component

  sub daf_dm_register_all_components ($$) {
    my ($res, $mod) = @_;
    my @list = ($res);
    while (@list) {
      my $r = shift @list;
      next if $DMBelongTo{$r->uri};
      $DMBelongTo{$r->uri} ||= $mod;
      push @list, @{daf_dm_get_components ($res)};
    }
  } # daf_dm_register_all_components

  sub daf_dm_get_module_group ($) {
    my $res = shift;
    return $DMBelongTo{$res->uri};
  } # daf_dm_get_module_group

  my %EntityName;

  sub daf_dm_get_entity_name ($;$) {
    my ($res, $suffix) = @_;
    
    my $r = $EntityName{$res->uri}->{defined $suffix ? $suffix : '#default'};
    return $r if defined $r;

    if ($DMBelongTo{$res->uri}) {
      $r = daf_dm_get_entity_name ($DMBelongTo{$res->uri});
    } else {
      warn qq[$0: Resource <@{[$res->uri]}> is not referenced from any module\n]
        unless $res->is_type_uri (ExpandedURI q<mv:XMLDTDModuleSet>) or
               $res->is_type_uri (ExpandedURI q<mv:XMLDTDDriver>);
      $r = '';
    }

    if ($res->is_type_uri (ExpandedURI q<mv:ElementType>)) {
      my $v = $res->get_property_text (ExpandedURI q<mv:elementTypeName>);
      $v = $res->local_name unless defined $v;
      $r .= '.' . $v . '.' . (defined $suffix ? $suffix : 'qname');
    } elsif ($res->is_type_uri (ExpandedURI q<mv:AttributeTypeGroup>)) {
      my $v = $res->get_property_text (ExpandedURI q<mv:attributeTypeGroupName>);
      $v = $res->local_name unless defined $v;
      $r .= '.' . $v . '.attrib';
    } elsif ($res->is_type_uri (ExpandedURI q<mv:ElementTypeClassMix>)) {
      my $v = $res->get_property_text
                      (ExpandedURI q<mv:elementTypeClassName>);
      $v = $res->local_name unless defined $v;
      $r .= '.' . $v . '.mix';
    } elsif ($res->is_type_uri (ExpandedURI q<mv:ElementTypeClass>)) {
      my $v = $res->get_property_text
                      (ExpandedURI q<mv:elementTypeClassName>);
      $v = $res->local_name unless defined $v;
      $r .= '.' . $v . '.class';
    } elsif ($res->is_type_uri (ExpandedURI q<mv:ElementContentModel>)) {
      my $v = $res->get_property_text
                      (ExpandedURI q<mv:elementContentModelName>);
      $v = $res->local_name unless defined $v;
      $r .= '.' . $v . '.content';
    } elsif ($res->is_type_uri (ExpandedURI q<mv:XMLDTDDatatypeEntity>)) {
      my $v = $res->get_property_text
                      (ExpandedURI q<mv:datatypeEntityName>);
      $v = $res->local_name unless defined $v;
      $r .= '.' . $v . '.datatype';
    } elsif ($res->is_type_uri (ExpandedURI q<mv:XMLDTDModule>)) {
      my $v1 = $res->get_property_text (ExpandedURI q<mv:id>);
      my $v2 = $res->get_property_text (ExpandedURI q<mv:vid>);
      $v1 .= '-' . $v2 if defined $v1 and defined $v2;
      $v1 = $res->local_name unless defined $v1;
      $r .= '-' . $v1 . (defined $suffix ? $suffix : '.mod');
    } elsif ($res->is_type_uri (ExpandedURI q<mv:XMLDTDModuleSet>)) {
      my $v1 = $res->get_property_text (ExpandedURI q<mv:id>);
      my $v2 = $res->get_property_text (ExpandedURI q<mv:vid>);
      $v1 .= $v2 if defined $v1 and defined $v2;
      $v1 = $res->local_name unless defined $v1;
      $r .= uc $v1;
    } elsif ($res->is_type_uri (ExpandedURI q<mv:XMLDTDDriver>)) {
      my $v1 = $res->get_property_text (ExpandedURI q<mv:id>);
      my $v2 = $res->get_property_text (ExpandedURI q<mv:vid>);
      $v1 .= $v2 if defined $v1 and defined $v2;
      $v1 = $res->local_name unless defined $v1;
      $r .= $v1;
    } else {
      $r .= '.' . $res->local_name;
    }

    return $EntityName{$res->uri}->{defined $suffix ? $suffix : '#default'} = $r;
  } # daf_dm_get_entity_name

  sub daf_dm_get_file_entity_name ($;$) {
    my ($res, $suffix) = @_;

    my $v = daf_dm_get_entity_name ($res, '');

    $v =~ tr/./-/;

    return lc ($v) . $suffix;
  } # daf_dm_get_file_entity_name
}

1;

__END__

=head1 NAME

daf-dtd-modules.pl - A daf module to generate DTD modukes

=head1 DESCRIPTION

This script, C<daf-dtd-modules.pl>, is dynamically loaded by
C<daf.pl> to create DTD modules.

=head1 SEE ALSO

L<bin/daf.pl> - daf main script

=head1 LICENSE

Copyright 2006 Wakaba <w@suika.fam.cx>.  All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
