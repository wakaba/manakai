<?xml version="1.0" encoding="iso-2022-jp"?>
<?xml-stylesheet href="/s/simpledoc.css" type="text/css" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
   "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="ja" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title xml:lang="en">Message::* Perl modules</title>
<link rel="index" href="./" />
<link rel="stylesheet" href="/s/simpledoc.css" type="text/css" />
<link rev="made" href="mailto:w@suika.fam.cx" />
<link rel="copyright" href="/c/pd" title="Public Domain." />
<meta name="author" content="若葉" />
<meta name="keywords" content="Perl, module, pm, Message, RFC 822, RFC 2822, RFC 1036, son-of-RFC1036, MIME, Usefor, HTTP, CGI, header, field" />
</head>
<body>
<h1>Message::* Perl modules</h1>

<h2>はじめのはじめに</h2>

<p>たとえば Perl で書かれた CGI script, それも掲示板なんかには、
こんなみっともない code が載っていたりします。</p>

<pre class="application-x-perl">
jcode'convert(*from, "jis");
jcode'convert(*subject, "jis");
jcode'convert(*message, "jis");
open (MAIL, "| $sendmail");
print MAIL "From: $mail ($from)\n";
print MAIL "To: $mailto\n";
print MAIL "Subject: $subject\n";
print MAIL "\n";
print MAIL "$message";
print MAIL "\n";
close (MAIL);
</pre>

<p>これでは視認性も良くないですし、うっかり修正し間違えると
変なメッセージを送信してしまいます。
(筆者はしょっちゅうはまってました:-)
(それに多くの code では、
HTML でのクロスサイトスクリプティング (CSS) 問題と
類似の問題への対処をしていません。)</p>

<p>オブジェクト指向を取り入れて次のような感じでメッセージを
構成したいところです。</p>

<pre class="application-x-perl">
use Message::Entity;
my $msg = new Message::Entity;
my $hdr = $msg-&gt;header;
$hdr-&gt;add ('From')-&gt;add ('me@bar.example');
$hdr-&gt;add ('To')-&gt;add (['foo@bar.example', display_name =&gt; 'Mr. foo']);
$hdr-&gt;add (Subject =&gt; $subject);
$msg-&gt;body ($body);

# $smtp-&gt;send は SMTP で送信する method と仮定。
$smtp-&gt;send ($msg);
</pre>

<p><a href="http://www.cpan.org/" xml:lang="en">CPAN</a> を探すと、
これに似たようなことができそうなモジュールはあるようですが、
実際に使ってみると、与える値によっては <a href="urn:ietf:rfc:822">RFC 822</a>/<a href="urn:ietf:rfc:2822">2822</a> に違反する
結果を出力するとか、そもそもそれ以前に、
<code>$hdr->addr ('Foo Bar &lt;foo@bar.example>')</code> 
のようにメッセージ形式をモジュール内に隠匿しきれていないとか、非
ASCII 文字を考慮していないとかの不満があります。</p>

<p class="note">(実装方針としては不正な値はモジュールに渡す前に弾くべきという考え方もあるでしょうけど、一般的な利用に際しては賢い設計だとは思えません。)</p>

<p>ということで、はじめは既存のモジュールの wrapper (あるいは補完) 
を書くつもりでしたが、なんだかごちゃごちゃしていて、
それなら車輪の再発明になっても一から書いてみようと考えました。</p>

<h2>特色 (という程のものでもない。)</h2>

<ol>
<li>結構オブジェクト指向です。</li>
<li>RFC 822/2822 の <code class="bnf rfc2822">group</code> を解釈出来ます。</li>
<li><a href="urn:ietf:id:draft-ietf-usefor-msg-id-alt-00">draft-ietf-usefor-msg-id-alt-00</a> に基づいた送信アドレスなどによる <code class="rfc2822">Message-ID</code> を生成出来ます。</li>
<li>文字コード独立 (CSI) です。 (但し RFC 822 である都合上(謎)、
ASCII 互換である必要はあります。 EBCDIC とかは無理です:-&lt; 
(というのはメッセージ構造の部分のことです。
MIME を使って EBCDIC などをメッセージ本文に入れることは可能です。))</li>
<li>MIME (<a href="urn:ietf:rfc:2045">RFC 2045</a>, 
<a href="urn:ietf:rfc:2046">2046</a>) にほぼ完全に対応しています。</li>
</ol>

<h2>各仕様への対応状況</h2>

<ol>
<li>電子メイルのメッセージ (RFC 822, RFC 2822) 
の全機能に対応しています。</li>
<li>電子ニュース記事 (<a href="/uri-res/N2L?urn:ietf:rfc:1036">RFC 1036</a>,
<a href="spec/son-of-RFC1036">son-of-RFC1036</a>,
<a href="/uri-res/N2L?urn:ietf:id:draft-usefor-article-06">
draft-usefor-article (06)</a>) の頭領域の多くに対応しています。</li>
<li>MIME の本文部分 (body part) に対応しています。
	<ul>
	<li>多部分 (multipart) や分割 (message/partial),
	外部本分 (message/external-body) を扱うことが出来ます。</li>
	<li>text/plain; format=flowed 
	(<a href="urn:ietf:rfc:2646">RFC 2646</a>)
	に対応しています。</li>
	<li>Content-Transfer-Encoding は Base64, Quoted-Printable
	は勿論、 x-uuencode, x-gzip64 にも対応。
	RFC 2822 メイル出力モードでは、本文が8ビットでも自動的に適切な
	CTE で符号化します。</li>
	</ul>
</li>
<li>MIME の頭領域 
(<a href="/uri-res/N2L?urn:ietf:rfc:2045">RFC 2045</a>,
<code class="mime">Content-Disposition</code>) に対応しています。
パラメーター値拡張 (<a href="/uri-res/N2L?urn:ietf:rfc:2231">RFC 2231</a>)
も入出力ともに実装しました。</li>
<li>MIME 符号化語 (<code class="mime bnf">encoded-word</code>)
の解読に対応しています:-)</li>
<li>HTTP/1.0, HTTP/1.1, CGI/1.1, CGI/1.2 の頭領域のうち、
ごく一部に対応しています。 MHTML の 
<code class="mime">Content-Location</code> にも対応しています。</li>
<li>日付形式では RFC 822/<a href="urn:ietf:rfc:1123">1123</a>, 
<a href="urn:ietf:rfc:733">RFC 733</a>, asctime, ISO 8601 (HTML) 
などに対応しています。日付の出力は sprintf
の様な書式文字列を与えることで、多種多様な形式に対応。</li>
<li>X-Moe シリーズに対応しています:-)</li>
</ol>

<h2>制限事項</h2>

<ol>
<li>類似モジュール(謎)のように、ファイル名やファイル・ハンドルを
渡して読み込ませることが出来ません。</li>
<li>大きなメッセージでも一気に読み込み、全て主記憶領域で
保持しています。ですからあまり大きなメッセージの処理には
向いていないでしょう。</li>
<li><code>CR</code> や <code>LF</code> が単体で出現する場合、
正しく処理出来<del>ません</del><ins>ないことがあります 
(近い将来の版で改善の予定)</ins>。 (<code>CRLF</code> と等価とみなします。)
将来の版ではオプションで制御可能になるかもしれません。</li>
<li>あったら良さそうな機能が未実装かもしれません。
(欲しい機能が未実装だったら、
<a href="mailto:w@suika.fam.cx">電子メイル</a>や
<a href="news://suika.fam.cx/suika.msg">suika.msg</a>
などで教えて下さい。)</li>
<li>各モジュールのオプション体系があまり整備されていません。
(それでも気持ち悪くない程度には体系的だと思います。)</li>
<li>説明文 (document) が良い加減です。</li>
</ol>

<h2>今後の予定</h2>

<ol>
<li>電子ニュースの頭領域 (RFC 1036, 
<a href="spec/son-of-RFC1036">son-of-RFC1036</a>, 
draft-usefor-article) の完全実装</li>
<li>追加/非標準の頭領域の実装。</li>
<li>documentation。</li>
<li>使用例の作成。</li>
<li>既存モジュールが利用出来る部分は、それを呼び出すようにするか
その code を流用する。</li>
<li>類似モジュールとの界面の共通化</li>
</ol>

<h2>必要環境</h2>

<ol>
<li>Perl (perl 5.6 以降または<span title="human parser">人間解析者</span>:-))
	<p class="note"><code class="bnf rfc822">comment</code>
	を表すのに正規表現 <code class="regex">(??{ <var>code</var> })</code> 
	を使っているので、これを解釈出来る、 
	5.6 以降の版である必要があります。</p>
</li>
<li>Digest::MD2, Digest::MD5, Digest::SHA1
	<p>Message-ID の生成にこれらを使用する場合のみ、
	<code>Message::Field::MsgID</code> が使います。</p>
	<p>これらが用意されていない環境ではエラーになるので、
	(現状では) 上記モジュールの該当部分を書き換えて対処して下さい。</p>
</li>
<li>MIME::Base64
	<p>ちなみに、 Quoted-Printable や RFC 2231 の
	% 符号化は自力で復号します。</p>
</li>
<li>文字コード変換処理
	<p>日本語メッセージを扱うなら必須でしょう。
	詳しくは<a href="#code">文字コードの扱い</a>
	の章をご参照下さい。</p>
</li>
</ol>

<h2>入手</h2>

<p>suika.fam.cx の SSH account をお持ちの場合、 CVS から入手出来ます。</p>

<p class="example">$ cvs -d :ext:<var xml:lang="en">username</var>@suika.fam.cx:/home/cvs -d perl/lib/Message/</p>

<p>Web からも取り出せます。 &lt;<a href="/gate/cvs/perl/lib/Message/">http://suika.fam.cx/gate/cvs/perl/lib/Message/</a>&gt; (tarball で一括取得も出来ます。)</p>

<h2>ライセンス</h2>

<p>Message::* Perl modules は自由ソフトウェアです。
GNU GPL に従って利用出来ます。詳しくは各ファイルを御覧下さい。</p>

<h2>参考文献</h2>

<ul>
<li><a href="spec/">関連する仕様書 (RFC, Internet-Draft 等)</a></li>
</ul>

<h2 id="code">文字コードの扱い</h2>

<p>卑しいことで頭を悩ますのは嫌なので(藁)、
[[ →<a href="#code-easy">手っ取り早く方法だけ読む</a>。 ]]
Message::* は符号化方法独立 (CSI) を目指して実装しています。
(但し ASCII のしがらみだけは断ち切っていません:-))
0x00 〜 0x7F が ASCII (または ASCII と見なして良いもの) である
場合は、 Message::* を通したことでデータが壊れることは
無いと思います。</p>

<p>(もちろん、 RFC 822 など各仕様に照らして正統(的)で
ある必要があります。 <code class="bnf rfc822">atom</code>
に8ビット・コードが含まれていると正しく扱えません。)
(早い話が、 <code class="bnf rfc822">quoted-string</code> 
などでは8ビット透過だということです。回りくどくてごめんなさい。)</p>

<p>既定の状態では文字コードに関係する変換処理は行われません。
しかし、フック関数っぽいもの(謎)を指定することで、
変換処理をさせられます。</p>

<p>指定出来るフック関数っぽいものは2種類です。
<code>DECODER</code> は、元のメッセージを解析する時
(<code class="perl">parse ()</code>) に適宜呼び出されます。
<code>ENCODER</code> は、メッセージとして文字列化する際
(<code class="perl">stringify ()</code> など) に適宜呼び出されます。</p>

<p>これらの関数は、当然、当該処理が呼び出される前に指定しておく
必要があります。
<samp class="perl">Message::Entity-&gt;parse</samp> などする前に
定義しておくと良いでしょう。</p>

<pre class="example perl">
require Message::MIME::Charset;
$Message::MIME::Charset::DECODER{'*default'} = sub {jcode::euc ($_[1])};
$Message::MIME::Charset::ENCODER{'*default'} = sub {jcode::jis ($_[1], 'euc')};
</pre>

<p>この例では、 jcode.pl を変換処理に使います。
(もちろん、既に <code class="perl">require</code> 
されていると仮定しています。)</p>
<p>最初の <code class="perl">require</code> で、変換処理を担当している
<code class="perl">Message::MIME::Charset</code> を読み込みます。
(こうしておかないと、後から既定値 (= 無変換) で
<code class="perl">*default</code> が上書きされてしまいます。)</p>

<p>この code を使ったスクリプトは内部処理を日本語 EUC 
で行うと仮定しています。ですから、 <code class="perl">DECODER</code>
で日本語 EUC に変換します。</p>
<p>また、日本語メッセージでは <code>ISO-2022-JP</code>
を使うのが慣習ですから、 <code class="perl">ENCODER</code>
では 7ビット JIS に変換しています。</p>
<p>処理を行う関数は、引数が2つ以上与えられます。
1つ目の引数は呼び出した class module, いわゆる 
<code class="perl">$self</code> です。(この場合 self ではありませんが:-)
でも普通は必要ないでしょう。</p>
<p>2つ目の引数は処理対象の文字列です。</p>
<p>3つ目以降の引数は、追加オプションのハッシュです。
ただし、現在追加オプションは定義されていません。</p>
<p>関数が返す値は(今のところ)一つだけです。
処理が終わった文字列です。変換結果として何もなくなってしまったら、
もちろん空文字列を返して構いません。 (<code class="perl">undef</code>
よりも空文字列の方が望ましいでしょう。)</p>

<p>さて、上記の例では「<code>*default</code>」の EN/DECODER 
を指定しましたが、ここには代わりに charset 名を指定出来ます。</p>

<pre class="perl example">
$Message::MIME::Charset::DECODER{'iso-2022-jp'} = sub {jcode::euc ($_[1], 'jis')};
</pre>

<p>ここでは、 <code>ISO-2022-JP</code> を内部コードに変換する
方法を定義しています。 charset 名 (および「<code>*default</code>」
は必ず小文字で書いて下さい!)</p>
<p>MIME body や、 encoded-word, RFC 2231 の拡張パラメーター値
など、 charset が指定されている時はその charset 名の変換関数が
呼び出されます。 (指定された charset 名の変換関数が未定義の時は、
何も処理しません。) これ以外の場面では、 <code>*default</code>
で定義された関数が使われます。</p>

<!--
<p>最後に、日本語メッセージを扱う際の例を挙げておきます。</p>

<pre class="example perl">
<span class="comment">## jcode.pl を使用</span>
require 'jcode.pl';
require Message::MIME::Charset;
$Message::MIME::Charset::DECODER{'*default'} = sub {jcode::euc ($_[1])};
$Message::MIME::Charset::DECODER{'iso-2022-jp'} = sub {jcode::euc ($_[1], 'jis')};
$Message::MIME::Charset::DECODER{'euc-jp'} = sub {$_[1]};
$Message::MIME::Charset::DECODER{'shift_jis'} = sub {jcode::euc ($_[1], 'sjis')};
$Message::MIME::Charset::ENCODER{'*default'} = sub {
  my $s = $_[1];
  <span class="comment">## 正規化</span>
  jcode::tr(\$s,
      "\xa3\xb0-\xa3\xb9\xa3\xc1-\xa3\xda\xa3\xe1-\xa3\xfa\xa1\xf5".
      "\xa1\xa4\xa1\xa5\xa1\xa7\xa1\xa8\xa1\xa9\xa1\xaa\xa1\xae".
      "\xa1\xb0\xa1\xb2\xa1\xbf\xa1\xc3\xa1\xca\xa1\xcb\xa1\xce".
      "\xa1\xcf\xa1\xd0\xa1\xd1\xa1\xdc\xa1\xf0\xa1\xf3\xa1\xf4".
      "\xa1\xf6\xa1\xf7\xa1\xe1\xa2\xaf\xa2\xb0\xa2\xb2\xa2\xb1".
      "\xa1\xe4\xa1\xe3\xA1\xC0\xA1\xA1"
      => '0-9A-Za-z&amp;,.:;?!`^_/|()[]{}+$%#*@=\'"~-&gt;&lt;\\ ');
  jcode::jis ($s, 'euc', 'z')
};
</pre>

<pre class="example perl">
<span class="comment">## Jcode.pm を使用</span>
use Jcode;
require Message::MIME::Charset;
$Message::MIME::Charset::DECODER{'*default'} = sub {jcode::euc ($_[1])};
$Message::MIME::Charset::DECODER{'iso-2022-jp'} = sub {Jcode->new ($_[1], 'jis')->euc};
$Message::MIME::Charset::DECODER{'euc-jp'} = sub {$_[1]};
$Message::MIME::Charset::DECODER{'shift_jis'} = sub {Jcode->new ($_[1], 'sjis')->euc};
$Message::MIME::Charset::DECODER{'utf-8'} = sub {Jcode->new ($_[1], 'utf8')->euc};
$Message::MIME::Charset::ENCODER{'*default'} = sub {Jcode-&gt;new ($_[1], 'euc')-&gt;jis};
$Message::MIME::Charset::ENCODER{'utf-8'} = sub {Jcode-&gt;new ($_[1], 'euc')-&gt;utf8};
</pre>
-->

<p id="code-easy">ややこしい説明をしてきましたが、実際面倒なので、日本語文字コード変換に良く使われる、
jcode.pl や Jcode.pm などのための設定は予め用意してあります。</p>

<pre class="example perl">
<span class="comment">## どちらか好きな方をどうぞ。</span>
use Message::MIME::Charset::Jcode 'jcode.pl';
use Message::MIME::Charset::Jcode 'Jcode';
</pre>

<p>この1行だけで、 ISO-2022-JP, EUC-JP, Shift_JIS
および幾つかの関連 charset が利用可能になります。</p>

<p>Perl 5.8 になって Encode モジュールが使えるようになれば、
もっと色々な文字コードが楽に利用できるようになると期待しています。</p>

<p>ところで、このように charset 対応処理をしなくても、
MIME で charset 札付けされてメッセージに含められている未知の
charset のデータが破壊されることはありません。 (はずです。)
(そこいらが、 Unicoder のソフトウェアとの違いです(笑)。)</p>

<div class="navigation">
[<a href="/" title="このサーバーの首頁">/</a>
<a href="/map" title="このサーバーの案内" rel="index">地図</a>
<a href="/search/" title="このサーバーの検索">検索</a>]
<a href="http://validator.w3.org/check/referer" xml:lang="en"><img
        src="http://www.w3.org/Icons/valid-xhtml11" id="w3c-html"
        alt="Valid XHTML 1.1!" style="height: 31px; width: 88px" /></a>
<a href="http://jigsaw.w3.org/css-validator/validator?uri=http://suika.fam.cx/~wakaba/Message-pm/introduction.ja.html" xml:lang="en">
  <img style="width: 88px; height: 31px" id="w3c-css"
       src="http://jigsaw.w3.org/css-validator/images/vcss" 
       alt="Valid CSS!" /></a>
</div>
<div class="update">$Date: 2002/06/14 12:46:34 $</div>
<ul class="myuri">
<li>&lt;URL:<a href="http://suika.fam.cx/~wakaba/Message-pm/introduction">http://suika.fam.cx/~wakaba/Message-pm/introduction</a>&gt;</li>
<li>&lt;CVS:<a href="http://suika.fam.cx/gate/cvs/perl/web/Message-pm/">suika.fam.cx:/home/cvs/perl/web/Message-pm/</a>&gt;</li>
</ul>
</body></html>
